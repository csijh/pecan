<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Manual</title>
<style>
    body { font-size: 120%; }
    pre { margin-left:40px; }
</style>
</head>
<body>

<img src="pecan.png" width="300" height="65" />
<hr/>

<h1>Recursive Ascent</h1>

<p>Often, a hierarchy of grammar rules is used to specify the precedence and
associativity of operators in a language.  As an example, here is a simple
grammar of arithmetic expressions, including a power operator <code>^</code> to
illustrate right-associativity, and assuming that a separate scanner is used to
ensure that, at the character level, each character is processed only once:</p>

<pre>expression = term (`+` term @2add / `-` term @2subtract)*
term = factor (`*` factor @2multiply / `/` factor @2divide)*
factor = atom (`^` factor @2power)?
atom = `number` @atom / `(` expression `)`
</pre>

<p>For every expression in the source program, the <code>expression</code> rule
is applied, which causes <code>term</code> to be applied, which causes
<code>factor</code> to be applied, which causes <code>atom</code> to be applied,
all before making any progress in the input.</p>

<p>One traditional way round the inefficiency is to switch to a different type
of parser, an <a
hjref="https://en.wikipedia.org/wiki/Operator-precedence_parser">operator
precedence</a> parser, for the expression part of the grammar.  Another
traditional approach (which works well if the language includes
programmer-defined operators) is to parse expressions without regard to
precedence and associativity, then post-process the resulting parse tree
later.</p>

<p>Another technique, which deserves to be much better known and understood, is
to use a normal recursive descent parser, but to re-work the rules in a
bottom-up fashion.  This is related to <a
href="https://en.wikipedia.org/wiki/Recursive_ascent_parser">recursive
ascent</a> parsing from which the name of this tutorial has been borrowed, and
<a href="https://dl.acm.org/citation.cfm?id=512931">top-down operator
precedence</a> parsing (by Pratt, also described by <a
href="http://crockford.com/javascript/tdop/tdop.html">Crockford</a>).  The
technique will be illustrated by transforming the expression grammar above.</p>

<p>The first step is to split each of the <code>expression</code>,
<code>term</code> and <code>factor</code> rules into two, for convenience:</p>

<pre>expression = term expression2
expression2 = (`+` term @2add / `-` term @2subtract)*
term = factor term2
term2 = (`*` factor @2multiply / `/` factor @2divide)*
factor = atom factor2
factor2 = (`^` factor @2power)?
</pre>

<p>Next, substitute the definition of <code>factor</code> into
<code>term</code>, and the resulting definition of <code>term</code> into
<code>expression</code>:</p>

<pre>expression = atom factor2 term2 expression2
term = atom factor2 term2
</pre>

<p>Next, split these definitions into two again:</p>

<pre>expression = atom expression3
expression3 = factor2 term2 expression2
term = atom term3
term3 = factor2 term2
</pre>

<p>Next, substitute the definition of <code>atom</code> into
<code>expression</code>, <code>term</code> and <code>factor</code>:</p>

<pre>expression = (`number` @atom / `(` expression `)`) expression3
term = (`number` @atom / `(` expression `)`) factor3
factor = (`number` @atom / `(` expression `)`) factor2
</pre>

<p>Next, distribute the two alternatives of <code>atom</code> in each of the
three rules. The full set of rules at this point is:</p>

<pre>expression = `number` @atom expression3 / `(` expression `)` expression3
expression2 = (`+` term @2add / `-` term @2subtract)*
expression3 = factor2 term2 expression2
term = `number` @atom term3 / `(` expression `)` term3
term2 = (`*` factor @2multiply / `/` factor @2divide)*
term3 = factor2 term2
factor = `number` @atom factor2 / `(` expression `)` factor2
factor2 = (`^` factor @2power)?
atom = `number` @atom / `(` expression `)`
</pre>

<p>Finally, just for completeness, the definition of <code>factor2</code> can be
substituted into the <code>expression3</code> and <code>term3</code> rules:</p>

<pre>expression = `number` @atom expression3 / `(` expression `)` expression3
expression2 = (`+` term @2add / `-` term @2subtract)*
expression3 = (`^` factor @2power)? term2 expression2
term = `number` @atom term3 / `(` expression `)` term3
term2 = (`*` factor @2multiply / `/` factor @2divide)*
term3 = (`^` factor @2power)? term2
factor = `number` @atom factor2 / `(` expression `)` factor2
factor2 = (`^` factor @2power)?
atom = `number` @atom / `(` expression `)`
</pre>

<p>Now each of the rules begins more-or-less immediately with the recognition of
its first token.  There are further opportunities, such as tail call
optimization, in translating this grammar into actual code. The result may or
may not be as good as the best bottom-up parser generators or custom algorithms,
but the bulk of the problem has been eliminated.</p>

</body>
</html>
