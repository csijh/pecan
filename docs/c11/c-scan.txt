// A scanner for C11.  It is assumed that the implementation-defined source
// character set is Unicode in the UTF-8 encoding, and that the source text has
// been prepared by converting newlines to \n, expanding trigraphs, splicing
// lines ending with \, eliding consecutive string literals, and carrying out
// preprocessing.

//  ----- A.1.1 Tokens -----

tokens = @tokens token* Uc!

// String-literals and constants and keywords must come before identifiers.
token =
    gap @ / comment @ / constant @1constant / string-literal @1string-literal /
    keyword @1key / identifier @1identifier / punctuator @1key

gap = (' ' / newline / tab / vtab / formfeed)+
newline = 10
tab = 9
vtab = 11
formfeed = 12

comment =
    "//" (newline! visible)* /
    "/*" ("*/"! visible)* "*/"
visible = (Cc/Cn/Co/Cs/Zl/Zp)! Uc / newline

// ----- A.1.2 Keywords -----

// Check that keywords aren't followed by letters or digits
keyword = [keyword-symbol (identifier-nondigit / digit)!]

keyword-symbol =
    "alignof"     / "auto"        / "break"           / "case"          /
    "char"        / "const"       / "continue"        / "default"       /
    "do"          / "double"      / "else"            / "enum"          /
    "extern"      / "float"       / "for"             / "goto"          /
    "if"          / "inline"      / "int"             / "long"          /
    "register"    / "restrict"    / "return"          / "short"         /
    "signed"      / "sizeof"      / "static"          / "struct"        /
    "switch"      / "typedef"     / "union"           / "unsigned"      /
    "void"        / "volatile"    / "while"           / "_Alignas"      /
    "_Atomic"     / "_Bool"       / "_Complex"        / "_Generic"      /
    "_Imaginary"  / "_Noreturn"   / "_Static_assert"  / "_Thread_local"

// ----- A.1.3 Identifiers -----

// Assume keywords have already been excluded.  Include Unicode letters.
identifier =
    identifier-nondigit (identifier-nondigit / digit)*

identifier-nondigit = nondigit / universal-character-name / other

nondigit = '_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'

digit = '0123456789'

other = Lu / Ll / Lt / Lm / Lo

// ----- A.1.4 Universal character names -----

universal-character-name = "\u" hex-quad / "\U" hex-quad hex-quad

hex-quad =
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit

// ----- A.1.5 Constants -----

// Omit enumeration constants.
constant =
    character-constant / is-float! integer-constant / floating-constant

// Look ahead to see if a number is floating or not
is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')

integer-constant =
    hexadecimal-constant integer-suffix? /
    octal-constant integer-suffix? /
    decimal-constant integer-suffix?

decimal-constant = nonzero-digit digit*

octal-constant = '0' octal-digit*

hexadecimal-constant = hexadecimal-prefix hexadecimal-digit+

hexadecimal-prefix = "0x" / "0X"

nonzero-digit = '123456789'

octal-digit = '01234567'

hexadecimal-digit = '0123456789abcdefABCDEF'

integer-suffix =
    unsigned-suffix (long-long-suffix / long-suffix)? /
    long-long-suffix unsigned-suffix? /
    long-suffix unsigned-suffix?

unsigned-suffix = 'uU'

long-suffix = 'lL'

long-long-suffix = "ll" / "LL"

floating-constant =
    hexadecimal-floating-constant /
    decimal-floating-constant

decimal-floating-constant =
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?

hexadecimal-floating-constant = hexadecimal-prefix hex-part1 hex-part2
hex-part1 =
    '.' hexadecimal-digit-sequence /
    hexadecimal-digit-sequence ('.' hexadecimal-digit-sequence?)?
hex-part2 = binary-exponent-part floating-suffix?

// Fractional constants have been absorbed into the above rules.

exponent-part = 'eE' sign? digit-sequence

sign = '+-'

digit-sequence = digit+

binary-exponent-part = 'pP' sign? digit-sequence

// Hexadecimal fractional constants have been absorbed into the above rules.
// Binary exponent parts have been absorbed into the above rules.

hexadecimal-digit-sequence = hexadecimal-digit+

floating-suffix = 'flFL'

// Enumeration constants have been omitted - they are recognised during parsing.

// A notation such as "L'" represents a two-character lookahead.
character-constant =
    ("'" / "L'" / "u'" / "U'") c-char-sequence "'"

c-char-sequence = c-char+

c-char = ("'" / '\' / newline)! visible / escape-sequence

escape-sequence =
    simple-escape-sequence / octal-escape-sequence /
    hex-escape-sequence / universal-character-name

simple-escape-sequence =
    "\'" / ["\" '"'] / "\?" / "\\" /
    "\a" / "\b" / "\f" / "\n" / "\r" / "\t" / "\v"

octal-escape-sequence = ["\" octal-digit] (octal-digit octal-digit?)?

hex-escape-sequence = "\x" hexadecimal-digit+

// ----- A.1.6 String literals -----

string-literal =
    '"' s-char-sequence? '"' /
    [encoding-prefix '"'] s-char-sequence? '"'

encoding-prefix = "u8" / "u" / "U" / "L"

s-char-sequence = s-char+

s-char = ('"' / '\' / newline)! visible / escape-sequence

// ----- A.1.7 Punctuators -----

punctuator =
    "%:%:" / "<<=" / ">>=" / "..." /
    "->" / "++" / "--" / "<<" / ">>" / "<=" / ">=" / "==" /
    "!=" / "&&" / "||" / "*=" / "/=" / "%=" / "+=" / "-=" /
    "&=" / "^=" / "|=" / "##" / "<:" / ":>" / "<%" / "%>" /
    "%:" /
    "[" / "]" / "(" / ")" / "{" / "}" / "." / "&" /
    "*" / "+" / "-" / "~" / "!" / "/" / "%" / "<" /
    ">" / "^" / "|" / "?" / ":" / ";" / "=" / "," /
    "#"
