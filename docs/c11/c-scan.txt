// A scanner for C11.  It is assumed that the implementation-defined source
// character set is Unicode in the UTF-8 encoding, and that the source text has
// been prepared by converting newlines to \n, expanding trigraphs, splicing
// lines ending with \, eliding consecutive string literals, and carrying out
// preprocessing.

//  ----- A.1.1 Tokens -----

tokens = @tokens token* Uc!

// String-literals and constants and keywords must come before identifiers.
token =
    gap @ / comment @ / constant @1constant / string-literal @1string-literal /
    keyword @1key / identifier @1identifier / punctuator @1key

gap = (' ' / newline / tab / vtab / formfeed)+
newline = 10
tab = 9
vtab = 11
formfeed = 12

comment =
    "//" (newline! visible)* /
    "/*" ("*/"! visible)* "*/"
visible = (Cc/Cn/Co/Cs/Zl/Zp)! Uc / newline

// ----- A.1.2 Keywords -----

// Check that keywords aren't followed by letters or digits
keyword = [keyword-symbol (identifier-nondigit / digit)!]

keyword-symbol =
    "alignof"     / "auto"        / "break"           / "case"          /
    "char"        / "const"       / "continue"        / "default"       /
    "do"          / "double"      / "else"            / "enum"          /
    "extern"      / "float"       / "for"             / "goto"          /
    "if"          / "inline"      / "int"             / "long"          /
    "register"    / "restrict"    / "return"          / "short"         /
    "signed"      / "sizeof"      / "static"          / "struct"        /
    "switch"      / "typedef"     / "union"           / "unsigned"      /
    "void"        / "volatile"    / "while"           / "_Alignas"      /
    "_Atomic"     / "_Bool"       / "_Complex"        / "_Generic"      /
    "_Imaginary"  / "_Noreturn"   / "_Static_assert"  / "_Thread_local"

// ----- A.1.3 Identifiers -----

// Assume keywords have already been excluded.  Include Unicode letters.
identifier =
    identifier-nondigit (identifier-nondigit / digit)*

identifier-nondigit = nondigit / universal-character-name / other

nondigit = '_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'

digit = '0123456789'

other = Lu / Ll / Lt / Lm / Lo

// ----- A.1.4 Universal character names -----

universal-character-name = "\u" hex-quad / "\U" hex-quad hex-quad

hex-quad =
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit

// ----- A.1.5 Constants -----

// Omit enumeration constants.
constant =
    character-constant / is-float! integer-constant / floating-constant

// Look ahead to see if a number is floating or not
is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')

integer-constant =
    hexadecimal-constant integer-suffix? /
    octal-constant integer-suffix? /
    decimal-constant integer-suffix?

decimal-constant = nonzero-digit digit*

octal-constant = '0' octal-digit*

hexadecimal-constant = hexadecimal-prefix hexadecimal-digit+

hexadecimal-prefix = "0x" / "0X"

nonzero-digit = '123456789'

octal-digit = '01234567'

hexadecimal-digit = '0123456789abcdefABCDEF'

integer-suffix =
    unsigned-suffix (long-long-suffix / long-suffix)? /
    long-long-suffix unsigned-suffix? /
    long-suffix unsigned-suffix?

unsigned-suffix = 'uU'

long-suffix = 'lL'

long-long-suffix = "ll" / "LL"

floating-constant =
    hexadecimal-floating-constant /
    decimal-floating-constant

decimal-floating-constant =
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?

hexadecimal-floating-constant = hexadecimal-prefix hex-part1 hex-part2
hex-part1 =
    '.' hexadecimal-digit-sequence /
    hexadecimal-digit-sequence ('.' hexadecimal-digit-sequence?)?
hex-part2 = binary-exponent-part floating-suffix?

// Fractional constants have been absorbed into the above rules.

exponent-part = 'eE' sign? digit-sequence

sign = '+-'

digit-sequence = digit+

binary-exponent-part = 'pP' sign? digit-sequence

// Hexadecimal fractional constants have been absorbed into the above rules.
// Binary exponent parts have been absorbed into the above rules.

hexadecimal-digit-sequence = hexadecimal-digit+

floating-suffix = 'flFL'

// Enumeration constants have been omitted - they are recognised during parsing.

// A notation such as "L'" represents a two-character lookahead.
character-constant =
    ("'" / "L'" / "u'" / "U'") c-char-sequence "'"

c-char-sequence = c-char+

c-char = ("'" / '\' / newline)! visible / escape-sequence

escape-sequence =
    simple-escape-sequence / octal-escape-sequence /
    hex-escape-sequence / universal-character-name

simple-escape-sequence =
    "\'" / ["\" '"'] / "\?" / "\\" /
    "\a" / "\b" / "\f" / "\n" / "\r" / "\t" / "\v"

octal-escape-sequence = ["\" octal-digit] (octal-digit octal-digit?)?

hex-escape-sequence = "\x" hexadecimal-digit+

// ----- A.1.6 String literals -----

string-literal =
    '"' s-char-sequence? '"' /
    [encoding-prefix '"'] s-char-sequence? '"'

encoding-prefix = "u8" / "u" / "U" / "L"

s-char-sequence = s-char+

s-char = ('"' / '\' / newline)! visible / escape-sequence

// ----- A.1.7 Punctuators -----

punctuator =
    "%:%:" / "<<=" / ">>=" / "..." /
    "->" / "++" / "--" / "<<" / ">>" / "<=" / ">=" / "==" /
    "!=" / "&&" / "||" / "*=" / "/=" / "%=" / "+=" / "-=" /
    "&=" / "^=" / "|=" / "##" / "<:" / ":>" / "<%" / "%>" /
    "%:" /
    "[" / "]" / "(" / ")" / "{" / "}" / "." / "&" /
    "*" / "+" / "-" / "~" / "!" / "/" / "%" / "<" /
    ">" / "^" / "|" / "?" / ":" / ";" / "=" / "," /
    "#"

// Testing
==========
x // comment
y
----------
tokens
identifier x
identifier y
==========
x /*
comment
*/ y
----------
tokens
identifier x
identifier y
==========
// String literals: note escaped backslashes in input and expected output
"abc" L"abc" "\\"" "abc\\"xyz"
----------
tokens
string-literal "abc"
string-literal L"abc"
string-literal "\\""
string-literal "abc\\"xyz"
==========
// Keywords and identifiers
int x intx
----------
tokens
key int
identifier x
identifier intx
==========
// Punctuators
[](){}+ ++ +++ < << <<< %:%:
----------
tokens
key [
key ]
key (
key )
key {
key }
key +
key ++
key ++
key +
key <
key <<
key <<
key <
key %:%:
==========
// Character constants
'a' L'a' '\\''
----------
tokens
constant 'a'
constant L'a'
constant '\\''
==========
// Integer constants
0 4 42 42u 42U 42l 42LL
0123 0128 0x12abCD
----------
tokens
constant 0
constant 4
constant 42
constant 42u
constant 42U
constant 42l
constant 42LL
constant 0123
constant 012
constant 8
constant 0x12abCD
==========
// Floating constants
0.0 0. .0 1e10 1E10 1.23e10 1e-10 e10
0x0.0p10 0x0.p10 0x.0p10 0x1p10 0x1P10
----------
tokens
constant 0.0
constant 0.
constant .0
constant 1e10
constant 1E10
constant 1.23e10
constant 1e-10
identifier e10
constant 0x0.0p10
constant 0x0.p10
constant 0x.0p10
constant 0x1p10
constant 0x1P10
