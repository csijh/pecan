-- A scanner for C11. It is assumed that the implementation-defined source
-- character set is Unicode in the UTF-8 encoding, and that the source text has
-- been prepared by converting newlines to \n, expanding trigraphs, splicing
-- lines ending with \, eliding consecutive string literals, and carrying out
-- preprocessing. The definition for enumeration-constant is handled later in
-- c-tokens.txt.

-- A.1.1 Tokens ---------------

tokens = @Tokens token* <>

-- String-literals and constants and keywords must come before identifiers.
token =
    gap / comment / constant / string-literal / keyword /
    identifier / punctuator

gap = (' ' / newline / tab / vtab / formfeed)+ @
newline = 10
tab = 9
vtab = 11
formfeed = 12

comment =
    "//" (newline! visible)* @ /
    "/*" ("*/"! visible)* "*/" @
visible = (Cc/Cn/Co/Cs/Zl/Zp)! Uc / newline

-- A.1.2 Keywords -------------

-- Check that keywords aren't followed by letters or digits
k = (identifier-nondigit / digit)!

keyword
= ["alignof" k] @1Kalignof
/ ["auto" k] @1Kauto
/ ["break" k] @1Kbreak
/ ["case" k] @1Kcase
/ ["char" k] @1Kchar
/ ["const" k] @1Kconst
/ ["continue" k] @1Kcontinue
/ ["default" k] @1Kdefault
/ ["do" k] @1Kdo
/ ["double" k] @1Kdouble
/ ["else" k] @1Kelse
/ ["enum" k] @1Kenum
/ ["extern" k] @1Kextern
/ ["float" k] @1Kfloat
/ ["for" k] @1Kfor
/ ["goto" k] @1Kgoto
/ ["if" k] @1Kif
/ ["inline" k] @1Kinline
/ ["int" k] @1Kint
/ ["long" k] @1Klong
/ ["register" k] @1Kregister
/ ["restrict" k] @1Krestrict
/ ["return" k] @1Kreturn
/ ["short" k] @1Kshort
/ ["signed" k] @1Ksigned
/ ["sizeof" k] @1Ksizeof
/ ["static" k] @1Kstatic
/ ["struct" k] @1Kstruct
/ ["switch" k] @1Kswitch
/ ["typedef" k] @1Ktypedef
/ ["union" k] @1Kunion
/ ["unsigned" k] @1Kunsigned
/ ["void" k] @1Kvoid
/ ["volatile" k] @1Kvolatile
/ ["while" k] @1Kwhile
/ ["_Alignas" k] @1Kalignas
/ ["_Atomic" k] @1Katomic
/ ["_Bool" k] @1Kbool
/ ["_Complex" k] @1Kcomplex
/ ["_Generic" k] @1Kgeneric
/ ["_Imaginary" k] @1Kimaginary
/ ["_Noreturn" k] @1Knoreturn
/ ["_Static_assert" k] @1Kstaticassert
/ ["_Thread_local" k] @1Kthreadlocal

-- A.1.3 Identifiers ---------------

-- Assume keywords have already been excluded. Include Unicode letters.
identifier =
    identifier-nondigit (identifier-nondigit / digit)* @1Identifier

identifier-nondigit = nondigit / universal-character-name / other

nondigit = '_' / 'A..Z' / 'a..z'

digit = '0..9'

other = Lu / Ll / Lt / Lm / Lo

-- A.1.4 Universal character names ----------------

universal-character-name = "\u" hex-quad / "\U" hex-quad hex-quad

hex-quad =
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit

-- A.1.5 Constants --------------------

-- Omit enumeration constants.
constant =
    character-constant @1Constant /
    is-float! integer-constant @1Constant /
    floating-constant @1Constant

-- Look ahead to see if a number is floating or not
is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')

integer-constant =
    hexadecimal-constant integer-suffix? /
    octal-constant integer-suffix? /
    decimal-constant integer-suffix?

decimal-constant = nonzero-digit digit*

octal-constant = '0' octal-digit*

hexadecimal-constant = hexadecimal-prefix hexadecimal-digit+

hexadecimal-prefix = "0x" / "0X"

nonzero-digit = '123456789'

octal-digit = '01234567'

hexadecimal-digit = '0123456789abcdefABCDEF'

integer-suffix =
    unsigned-suffix (long-long-suffix / long-suffix)? /
    long-long-suffix unsigned-suffix? /
    long-suffix unsigned-suffix?

unsigned-suffix = 'uU'

long-suffix = 'lL'

long-long-suffix = "ll" / "LL"

floating-constant =
    hexadecimal-floating-constant /
    decimal-floating-constant

decimal-floating-constant =
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?

hexadecimal-floating-constant = hexadecimal-prefix hex-part1 hex-part2
hex-part1 =
    '.' hexadecimal-digit-sequence /
    hexadecimal-digit-sequence ('.' hexadecimal-digit-sequence?)?
hex-part2 = binary-exponent-part floating-suffix?

-- Fractional constants have been absorbed into the above rules.

exponent-part = 'eE' sign? digit-sequence

sign = '+-'

digit-sequence = digit+

binary-exponent-part = 'pP' sign? digit-sequence

-- Hexadecimal fractional constants have been absorbed into the above rules.
-- Binary exponent parts have been absorbed into the above rules.

hexadecimal-digit-sequence = hexadecimal-digit+

floating-suffix = 'flFL'

-- Enumeration constants have been omitted - they are recognised during parsing.

-- A notation such as "L'" represents a two-character lookahead.
character-constant =
    ("'" / "L'" / "u'" / "U'") c-char-sequence "'"

c-char-sequence = c-char+

c-char = ("'" / '\' / newline)! visible / escape-sequence

escape-sequence =
    simple-escape-sequence / octal-escape-sequence /
    hex-escape-sequence / universal-character-name

simple-escape-sequence =
    "\'" / ["\" '"'] / "\?" / "\\" /
    "\a" / "\b" / "\f" / "\n" / "\r" / "\t" / "\v"

octal-escape-sequence = ["\" octal-digit] (octal-digit octal-digit?)?

hex-escape-sequence = "\x" hexadecimal-digit+

-- A.1.6 String literals -----------------

string-literal =
    '"' s-char-sequence? '"' @1StringLiteral /
    [encoding-prefix '"'] s-char-sequence? '"' @1StringLiteral

encoding-prefix = "u8" / "u" / "U" / "L"

s-char-sequence = s-char+

s-char = ('"' / '\' / newline)! visible / escape-sequence

-- A.1.7 Punctuators -----------------

punctuator
= "%:%:" @1SPercentColonPercentColon
/ "<<=" @1SLessLessEq
/ ">>=" @1SGreaterGreaterEq
/ "..." @1SDotDotDot
/ "->" @1SArrow
/ "++" @1SPlusPlus
/ "--" @1SMinusMinus
/ "<<" @1SLessLess
/ ">>" @1SGreaterGreater
/ "<=" @1SLessEq
/ ">=" @1SGreaterEq
/ "==" @1SEqEq
/ "!=" @1SNotEq
/ "&&" @1SAndAnd
/ "||" @1SOrOr
/ "*=" @1SStarEq
/ "/=" @1SSlashEq
/ "%=" @1SPercentEq
/ "+=" @1SPlusEq
/ "-=" @1SMinusEq
/ "&=" @1SAndEq
/ "^=" @1SHatEq
/ "|=" @1SOrEq
/ "##" @1SHashHash
/ "<:" @1SLessColon
/ ":>" @1SColonGreater
/ "<%" @1SLessPercent
/ "%>" @1SPercentGreater
/ "%:" @1SPercentColon
/ "[" @1SOpenS
/ "]" @1SCloseS
/ "(" @1SOpenR
/ ")" @1SCloseR
/ "{" @1SOpenC
/ "}" @1SCloseC
/ "." @1SDot
/ "&" @1SAnd
/ "*" @1SStar
/ "+" @1SPlus
/ "-" @1SMinus
/ "~" @1STilde
/ "!" @1SNot
/ "/" @1SSlash
/ "%" @1SPercent
/ "<" @1SLess
/ ">" @1SGreater
/ "^" @1SHat
/ "|" @1SOr
/ "?" @1SQuery
/ ":" @1SColon
/ ";" @1SSemi
/ "=" @1SEq
/ "," @1SComma
/ "#" @1SHash
