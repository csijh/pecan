<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial: C</title>
<style>
  pre, .indent { margin-left: 40px; }
  pre.c11, code.c11 { color: #00a; }
  pre.pecan, code.pecan { color: #060; }
</style>
</head>
<body>

<img src="../pecan.png" width="300" height="65" />
<hr/>

<h1>Pecan Case study: C11</h1>

<p>The development of a scanner and parser for C11 presented here is based on
the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf">C11
standard</a>. It demonstrates the use of Pecan and, in particular, the use of
(manual) grammar transformation as a way of developing parsers.</p>

<p>The result is simply a literal translation of the official C11 grammar into
the Pecan notation.  It does not take into account common extensions or other
variations to the C11 language, or differing interpretations of the standard,
nor does it attempt to deal with all of the practical issues that arise in real
C compilers. It has also only been lightly tested. It is not intended to be a
compiler-grade parser, merely a starting point for experimentation.  It captures
the official grammar in a more convenient executable form.</p>

<p>Infamously, parsing of C requires type names introduced using
<code>typedef</code> to be differentiated from other identifiers.  This cannot
be done during scanning.  Instead, token tags must be altered during parsing,
which must include some form of symbol table construction.  Pecan parsers allows
for this in their interaction with external code.  It is assumed that suitable
external code will be added to the parser to achieve this.</p>

<p>The rules from the C11 standard are presented with a few obvious cosmetic
changes to the notation for compatibility with Pecan.  Terminal symbols in bold
such as <b><code>int</code></b> are quoted as <code>"int"</code> instead.
Definitions <code>x: y</code> have the colon replaced by an equal sign to give
<code>x = y</code>, the optional suffix <code>x<sub>opt</sub></code> is replaced
by a question mark <code>x?</code>, and choices which are implicit from the
layout have explicit choice operators <code>|</code> added.  Rules are
effectively presented in a mythical language which is Pecan with an extra
<code>|</code> operator having CFG semantics. The aim is to apply
transformations until the alternatives of any <code>|</code> operator can
clearly be distinguished by the PEG operator <code>/</code> instead, so that the
<code>|</code> operator can be eliminated.</p>

<p>Rules taken from the standard, or needing more transformation work, are
displayed in <code class="c11">blue</code>, whereas final Pecan rules are
displayed in <code class="pecan">green</code>.</p>

<p>The development described here amounts to translating the C11 syntax into a
nearly-recursive-descent form, which has been done before, perhaps most notably
in the clang compiler.  The difference is that a potentially reusable grammar
has been produced rather than a one-off parser for a specific purpose.</p>

<h2>Scanner</h2>

<p>The complete Pecan scanner for C11, and a small collection of tests, are in
the file:</p>

<p class="indent"><a href="c-scan.txt">c-scan.txt</a></p>

<p>The scanner is based on the lexical grammar which is gathered together in
appendix A.1 of the standard.  It is assumed that the implementation-defined
source character set consists of the visible Unicode characters. It is assumed
that the character encoding is UTF-8, and that conversion of all newlines to
<code>\n</code>, translation of trigraphs, splicing of lines which end in
<code>\</code> and preprocessing have already been done.  Scanning does not then
involve any changes to the source text.  The initial rule of the scanner is:</p>

<pre class="pecan">tokens = @tokens token* Uc!
</pre>

<p>To ensure that the scanner produces a single output, there is an initial
action <code class="pecan">@tokens</code> which produces an empty list of
tokens. Thereafter, as each token is recognized, an action adds the token to the
list. The end of file is recognized using <code class="pecan">Uc!</code>. The
original rule for a token from the standard is:</p>

<pre class="c11">token = keyword | identifier | constant | string-literal | punctuator
</pre>

<p>In order to take a uniform approach to scanning, white space and comments,
described elsewhere in the standard, are included, so that all of the text is
processed.  Also, the order is changed to recognise string literals and
constants before keywords or identifiers, because of the possibility of an
encoding prefix at the start of a string literal or character constant. Keywords
are recognized before identifiers, to keep the definition of identifiers simple,
as in the original grammar.  So the translated rule is:</p>

<pre class="pecan">token =
    gap / comment / constant / string-literal /
    keyword / identifier / punctuator
</pre>

<p>White space and comments can be recognized as tokens, and then discarded,
like this:</p>

<pre class="pecan">gap = (' ' / newline / tab / vtab / formfeed)+ @

comment =
    "//" (newline! visible)* @ /
    "/*" ("*/"! visible)* "*/" @
</pre>

<p>Leaving constants until later, string literals are described in the original
grammar by:</p>

<pre class="c11">string-literal = encoding-prefix? '"' s-char-sequence? '"'

encoding-prefix = "u8" | "u" | "U" | "L"
</pre>

<p>This can be translated into:</p>

<pre class="pecan">string-literal =
    '"' s-char-sequence? '"' @1string /
    [encoding-prefix '"'] s-char-sequence? '"' @1string

encoding-prefix = "u8" / "u" / "U" / "L"
</pre>

<p>The try construct <code class="pecan">[encoding-prefix '"']</code> ensures
that a prefix such as <code>u8</code> on its own does not match.
The characters inside a string literal are described in the original grammar
by:</p>

<pre class="c11">s-char-sequence =
    s-char |
    s-char-sequence s-char
</pre>

<p>Many of the original grammar rules use left recursion in this simple way to
express repetition.  Such rules can usually be translated in a routine way using
repetition operators like this:</p>

<pre class="pecan">s-char-sequence = s-char+
</pre>

<p>In C, as in many languages, a word like <code>int</code> is not recognized as
a keyword if it is followed by more letters or digits, e.g. <code>intx</code> is
a single identifier, not the keyword <code>int</code> followed by
<code>x</code>. This fact is not entirely clear from the original grammar, which
has a local ambiguity at this point.  Although it can be argued according to CFG
semantics that such ambiguities get resolved at a more global level, it is much
clearer to resolve them locally.  Many such ambiguities, including this one, can
be resolved using a greedy convention, sometimes called maximal munch, where it
is assumed that the longest alternative is the one intended. To deal with this
explicitly in the rule for keywords, lookahead is used:</p>

<pre class="pecan">keyword =
    ["alignof" more!] @1alignof /
    ["auto" more!] @1auto /
    ["break" more!] @1break /
    ...
    ["_Thread_local" more!] @1ThreadLocal
</pre>

<p>Identifiers exclude the keywords, and include type names introduced using
<code>typedef</code>, and enumeration constants, which can't be distinguished in
the scanner.  Those are recognized during parsing.  Using Unicode letters in
place of "other implementation-defined characters", the translated rules for
identifiers are:</p>

<pre class="pecan">identifier = identifier-nondigit more* @1id
identifier-nondigit = nondigit / universal-character-name / other
more = identifier-nondigit / digit
nondigit = '_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
digit = '0123456789'
universal-character-name = "\u" hex-quad / "\U" hex-quad hex-quad
hex-quad =
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
hexadecimal-digit = '0123456789abcdefABCDEF'
other = Lu / Ll / Lt / Lm / Lo
</pre>

<p>Punctuators are easier to recognize than keywords, because it doesn't matter
what they are followed by. However, they have to be ordered so that if one is a
prefix of another, the longer one is recognized preferentially, according to the
greedy convention.  Perhaps the easiest way to be sure of that is to list them
in length order.</p>

<pre class="pecan">punctuator =
    "%:%:" @1hshs /
    "&lt;&lt;=" @1ltlteq /
    ">>=" @1gtgteq /
    "..." @1dtdtdt /
    "->" @1migt /
    ...
    "#" @1hs
</pre>

<p>Constants are described in the original grammar by:</p>

<pre class="c11">constant =
    integer-constant | floating-constant |
    enumeration-constant | character-constant
</pre>

<p>Enumeration constants can't be distinguished from identifiers in the scanner,
so they need to be removed from this rule and dealt with in the parser.
Character constants may have a prefix before the <code>"'"</code>, and can be
recognised in a similar way to string literals. It is convenient to deal with
them as the first alternative to get them out of the way.  Numerical constants
cause a problem, because both integer and floating constants can start with
digits.  It is possible to translate directly into a Pecan grammar rule by using
lookahead to try one alternative and then the other:</p>

<pre class="c11">constant =
    character-constant / [integer-constant] / floating-constant
</pre>

<p>It is tempting to try to improve on this by using a transformation approach
to find an equivalent form where no lookahead is needed.  However, this turns
out to be impossible. That's because, for example, <code>08</code> is
technically two tokens because <code>8</code> is not an octal digit, whereas
<code>08.</code> is a single floating constant.  That means, after accepting the
<code>0</code>, lookahead is needed at least as far as the dot before knowing
whether the token has ended.  Detection of non-octal digits in octal constants
could be left until a later semantic pass, but perhaps a better approach is to
find a cheap lookahead which looks for the first non-digit.</p>

<pre class="pecan">constant =
    character-constant / is-float! integer-constant / floating-constant

is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')
</pre>

<p>The original rule for <code>integer-constant</code> is:</p>

<pre class="c11">integer-constant =
    decimal-constant integer-suffix? |
    octal-constant integer-suffix? |
    hexadecimal-constant integer-suffix?
</pre>

<p>This is another place in the C11 grammar where there is a local ambiguity. If
the source text contains <code>0x1</code> then this could match
<code>hexadecimal-constant</code>, or the first <code>0</code> on its own could
match <code>octal-constant</code>.  The greedy convention suggests that the
hexadecimal case should be checked first:</p>

<pre class="pecan">integer-constant =
    hexadecimal-constant integer-suffix? @1hex /
    octal-constant integer-suffix? @1octal /
    decimal-constant integer-suffix? @1decimal
</pre>

<p>One of the alternatives for a floating constant is a decimal floating
constant, with this original rule:</p>

<pre class="c11">decimal-floating-constant:
    fractional-constant exponent-part? floating-suffix? |
    digit-sequence exponent-part floating-suffix?
</pre>

<p>The alternatives have possible initial digits in common, so this needs some
work.  The original rule for <code>fractional-constant</code> is:</p>

<pre class="c11">fractional-constant =
    digit-sequence? '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>This is typical of many rules where there is a common left factor which is
reasonably easy to transform away using routine transformations.  The first
alternative can be expanded into two alternatives, according to whether the
optional <code>digit-sequence</code> is absent or present:</p>

<pre class="c11">fractional-constant =
    '.' digit-sequence |
    digit-sequence '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>Then the last two alternatives can be combined, and the choice operator
changed:</p>

<pre class="c11">fractional-constant =
    '.' digit-sequence /
    digit-sequence '.' digit-sequence?
</pre>

<p>This can now be substituted into the <code>decimal-floating-constant</code>
rule, and similar transformations applied to the result, to give:</p>

<pre class="pecan">decimal-floating-constant:
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?
</pre>

<p>The same approach can be taken to the remaining original rules.</p>

<p>Although this translation of the C11 lexical rules has involved some work, it
has had the effect of exposing and resolving some issues.</p>

<h2>Parser: external definitions</h2>

<p>The remainder of the C11 grammar covering the parser rules will be tackled in
sections.  A first prototype of the grammar, just demonstrating the handling of
external definitions in section A.2.4 of the standard, is:</p>

<p class="indent"><a href="c-parse-a.txt">c-parse-a.txt</a></p>

<p>With a few obvious cosmetic changes to the notation for compatibility with
Pecan, the CFG-based grammar begins with:</p>

<pre class="c11">translation-unit =
    external-declaration | translation-unit external-declaration
</pre>

<p>Removing the left recursion, adding an action to initialize an empty list of
external declarations, and adding end-of-file detection, this can be translated
into:</p>

<pre class="pecan">translation-unit = @0list external-declaration+ ``
</pre>

<p>The original grammar continues with:</p>

<pre class="c11">external-declaration = function-definition | declaration
</pre>

<p>The two alternatives are disjoint, because the grammar is unambiguous, but it
isn't immediately clear how to distinguish them. If it is just assumed that
there is no ambiguous overlap, then there is a direct translation into a Pecan
grammar rule by using lookahead to try one alternative and then the other:</p>

<pre class="c11">external-declaration = [function-definition] / declaration
</pre>

<p>However, since replacing the body of a function definition by a semicolon
yields a declaration, it is clear that the two alternatives share a lot in
common, to the point where it is worth merging them.  A fairly straightforward
transformation approach can be used to reach an equivalent form with no
lookahead needed. The relevant rules from the original grammar needed during the
transformation, with left recursion removed, are:</p>

<pre class="c11">function-definition =
    declaration-specifiers declarator declaration-list? compound-statement

declaration =
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration

init-declarator-list = init-declarator (`,` init-declarator)*

init-declarator = declarator (`=` initializer)?
</pre>

<p>This allows us to transform the rule for external declarations by expanding
<code>function-definition</code> and <code>declaration</code> to give:</p>

<pre class="c11">external-declaration =
    declaration-specifiers declarator declaration-list? compound-statement |
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration
</pre>

<p>The <code>static_assert-declaration</code> clause can be put first because it
begins with a distinctive keyword, and the common left factor
<code>declaration-specifiers</code> can be taken out, to yield:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        init-declarator-list? `;`
    )
</pre>

<p>Expanding <code>init-declarator-list</code> gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (init-declarator (`,` init-declarator)*)? `;`
    )
</pre>

<p>Expanding the first <code>init-declarator</code> gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (declarator (`=` initializer)? (`,` init-declarator)*)? `;`
    )
</pre>

<p>In order to get at the common left factor <code>declarator</code>, the second
alternative, which has the form <code>(x)? `;`</code>, can be replaced by
<code>x `;` / `;`</code> to give:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        declarator (`=` initializer)? (`,` init-declarator)* `;` |
        `;`
    )
</pre>

<p>Taking out the left factor <code>declarator</code> from the first two
alternatives gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator (
            declaration-list? compound-statement |
            (`=` initializer)? (`,` init-declarator)* `;`
        ) |
        `;`
    )
</pre>

<p>Looking at the two innermost alternatives, the second can clearly only start
with a token <code>`=`</code> or <code>`,`</code> or
<code>`;`</code>.  It is easy to check that the first alternative
cannot start with any of these, so no lookahead is necessary any more.</p>

<p>Converting to Pecan notation, adding some actions, and rearranging a bit,
gives:</p>

<pre class="pecan">external-declaration =
    static_assert-declaration @1declaration /
    declaration-specifiers (
        `;` @1declaration /
        declarator (
            (`=` initializer)? (`,` init-declarator)* `;` @1declaration /
            declaration-list? compound-statement @1definition
        )
    )
</pre>

<p>It is worth pointing out that, since <code class="pecan">declarator</code>
includes function declarators, this grammar does not preclude a declaration of
the form <code>int f() = 3;</code>.  A brief investigation of actual C compilers
suggests that this error is normally detected after, rather than during,
parsing.</p>

<p>The next stage is to deal with declarations</p>

<h2>Parser: declarations</h2>

<p>A second prototype of the grammar, demonstrating the full range of
declarations from appendix section A.2.2 of the C11 standard, is:</p>

<p class="indent"><a href="c-parse-b.txt">c-parse-b.txt</a></p>

<p>Most of the problems faced in parsing declarations are fairly easy.  For
example, the original grammar rule from the C11 standard (A.2.2) for a struct or
union specifier is:</p>

<pre class="c11">struct-or-union-specifier =
    struct-or-union identifier? `{` struct-declaration-list `}` |
    struct-or-union identifier
</pre>

<p>Expanding the first alternative, then rearranging to remove the common left
factors gives:</p>

<pre class="pecan">struct-or-union-specifier = struct-or-union (
    identifier (`{` struct-declaration-list `}`)? /
    `{` struct-declaration-list `}`
)
</pre>

<p>The original grammar rules for enumeration specifiers are:</p>

<pre class="c11">enum-specifier =
    `enum` identifier? `{` enumerator-list `}`
    `enum` identifier? `{` enumerator-list `,` `}`
    `enum` identifier

enumerator-list = enumerator (`,` enumerator)*
</pre>

<p>Perhaps the most obvious way to translate the first definition, expanding,
rearranging and combining left factors as before, is:</p>

<pre class="pecan">enum-specifier = `enum` (
    identifier (`{` enumerator-list `,`? `}`)? /
    `{` enumerator-list `,`? `}`
)
</pre>

<p>However, the fact that there is an optional final comma before the close
curly bracket causes a problem.  It means that care is needed to prevent it from
being matched in the second rule:</p>

<pre class="pecan">enumerator-list = enumerator ((`,` `}`)! `,` enumerator)*
</pre>

<p>The original rule for <code>direct-declarator</code> is:</p>

<pre class="c11">direct-declarator:
    identifier |
    `(` declarator `)` |
    direct-declarator `[` type-qualifier-list? assignment-expression? `]` |
    direct-declarator `[` `static` type-qualifier-list? assignment-expression `]` |
    direct-declarator `[` type-qualifier-list `static` assignment-expression `]` |
    direct-declarator `[` type-qualifier-list? `*` `]` |
    direct-declarator `(` parameter-type-list `)` |
    direct-declarator `(` identifier-list? `)` |
</pre>

<p>Removing the left recursion, combining the contents of each kind of bracket,
disambiguating alternatives <code>parameter-type-list</code> and
<code>identifier-list</code> by reversing the alternatives and using lookahead
to check for the first identifier, inventing extra rules for clarity, and
tidying up, yields:</p>

<pre class="pecan">direct-declarator =
    (identifier / `(` declarator `)`) dd-bracket*

dd-bracket =
    `(` dd-parameters? `)` / `[` dd-array-size? `]`

dd-parameters =
    identifier&amp; identifier-list / parameter-type-list

dd-array-size =
    `*` /
    `static` type-qualifier-list? assignment-expression /
    type-qualifier-list dd-simple-array-size? /
    assignment-expression

dd-simple-array-size =
    `*` /
    `static` assignment-expression /
    assignment-expression
</pre>

<p>The original rule for <code>direct-abstract-declarator</code> is:</p>

<pre class="c11">direct-abstract-declarator =
    `(` abstract-declarator `)` |
    direct-abstract-declarator? `[` type-qualifier-list? assignment-expression? `]` |
    direct-abstract-declarator? `[` `static` type-qualifier-list? assignment-expression `]` |
    direct-abstract-declarator? `[` type-qualifier-list `static` assignment-expression `]` |
    direct-abstract-declarator? `[` `*` `]` |
    direct-abstract-declarator? `(` parameter-type-list? `)`
</pre>

<p>Going through a similar sequence of small transformations yields:</p>

<pre class="pecan">direct-abstract-declarator =
    `(` abstract-declarator `)` dad-bracket* / dad-bracket+

dad-bracket =
    `(` parameter-type-list? `)` / `[` dad-array-size? `]`

dad-array-size =
    `*` /
    `static` type-qualifier-list? assignment-expression /
    type-qualifier-list dad-simple-array-size? /
    assignment-expression

dad-simple-array-size =
    assignment-expression / `static` assignment-expression
</pre>

<p>The original rule for <code>parameter-declaration</code> is:</p>

<pre class="c11">parameter-declaration =
    declaration-specifiers declarator |
    declaration-specifiers abstract-declarator?
</pre>

<p>Taking out the common left factor, this becomes:</p>

<pre class="c11">parameter-declaration = declaration-specifiers (
    declarator |
    abstract-declarator?
)
</pre>

<p>The approach taken earlier to combine alternatives by transformation to find
their common prefixes doesn't work here, because recursion intervenes before the
issue is resolved.  So, it is better to use lookahead.  However, it is worth
finding a 'cheap' lookahead.  The main difference between the alternatives is
that <code>declarator</code> includes an identifier.  Checking the
possibilities, only <code>`*`</code> or <code>type-qualifier</code> or
<code>`(`</code> tokens can occur before the identifier. On the other hand, in
an <code>abstract-declarator</code>, a close bracket must appear before the end.
This leads to:</p>

<pre class="pecan">parameter-declaration = declaration-specifiers (
    has-identifier&amp; declarator /
    abstract-declarator?
)

has-identifier =
    (`*` / type-qualifier / `(`)* `identifier`
</pre>

<p>The transformation of the remainder of the declaration rules is relatively
straightforward.</p>

<h2>Parser: statements</h2>

<hr/>
<p><b>Development incomplete</b></p>
<hr/>

<p>A third prototype, adding statement rules from A.2.3 of the standard, is</p>

<p class="indent"><a href="c-parse-c.txt">c-parse-c.txt</a></p>

<p>The original main rule for statements is:</p>

<pre class="c11">
statement =
    labeled-statement |
    compound-statement |
    expression-statement |
    selection-statement |
    iteration-statement |
    jump-statement
</pre>

<p>Most statements begin with a distinctive keyword. A simple check reveals that
the only overlap of first tokens is that <code>labeled-statement</code> and
<code>expression-statement</code> can both start with an identifier.  However,
only in the <code>labeled-statement</code> case is it immediately followed by a
colon.  Thus the above rule can be translated trivially, and
<code>labeled-statement</code> can be given a simple two-token lookahead:</p>

<pre class="pecan">
statement =
    labeled-statement /
    compound-statement /
    expression-statement /
    selection-statement /
    iteration-statement /
    jump-statement

labeled-statement =
    [identifier `:`] statement /
    `case` constant-expression `:` statement /
    `default` `:` statement

compound-statement =
    `{` block-item* `}`

*** block-item:
    declaration /
    statement

expression-statement =
    expression? `;`

*** selection-statement =
    `if` `(` expression `)` statement /
    `if` `(` expression `)` statement `else` statement /
    `switch` `(` expression `)` statement

*** iteration-statement =
    `while` `(` expression `)` statement /
    `do` statement `while` `(` expression `)` `;` /
    `for` `(` expression? `;` expression? `;` expression? `)` statement /
    `for` `(` declaration expression? `;` expression? `)` statement

jump-statement =
    `goto` identifier `;` /
    `continue` `;` /
    `break` `;` /
    `return` expression? `;`
</pre>

</body>
</html>
