<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial: C</title>
<style>
  pre, .indent { margin-left: 40px; }
  pre.c11, code.c11 { color: #00a; }
  pre.pecan, code.pecan { color: #060; }
</style>
</head>
<body>

<img src="../pecan.png" width="300" height="65" />
<hr/>

<h1>Pecan Case study: C11</h1>

<p>The development of a scanner and parser for C11 presented here is based on
the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf">C11
standard</a>. It demonstrates the use of Pecan and, in particular, the use of
(manual) grammar transformation as a way of developing parsers.</p>

<p>The result is simply a literal translation of the official C11 grammar into
the Pecan notation.  It does not take into account common extensions or other
variations to the C11 language, or differing interpretations of the standard,
nor does it attempt to deal with the preprocessing phase or all of the practical
issues that arise in real C compilers. It has also only been lightly tested. It
is not intended to be a compiler-grade parser, merely a reinterpretation of the
official grammar.</p>

<p>Infamously, parsing of C requires type names introduced using
<code>typedef</code> to be differentiated from other identifiers.  This cannot
be done during scanning.  Instead, token tags must be altered during parsing,
which must include some form of symbol table construction.  Pecan parsers allow
for this in their interaction with external code.  It is assumed that suitable
external code will be added to the parser to achieve this.</p>

<p>The development described here amounts to translating the C11 syntax into a
nearly-recursive-descent form, which has been done before, perhaps most notably
in the clang compiler.  The difference is that a potentially reusable grammar
has been produced rather than a one-off parser for a specific purpose.</p>

<h2>Transliteration</h2>

<p>The first step is to carry out a few obvious cosmetic changes to the rules
from Appendix A of the C11 standard for compatibility with Pecan.  The result is
presented in this file, for reference while going through the
transformations.</p>

<p class="indent"><a href="c11-grammar.txt">c11-grammar.txt</a></p>

<p>Terminal symbols in bold such as <b><code>int</code></b> are quoted as
<code>"int"</code> instead. Definitions <code>x: y</code> have the colon
replaced by an equal sign to give <code>x = y</code>, the optional suffix
<code>x<sub>opt</sub></code> is replaced by a question mark <code>x?</code>, and
choices which are implicit from the layout have explicit choice operators
<code>|</code> added.  Rules are effectively presented in a mythical language
which is Pecan with an extra <code>|</code> operator having CFG semantics. The
aim is to apply transformations until the alternatives of any <code>|</code>
operator can clearly be distinguished by the PEG operator <code>/</code>
instead, so that the <code>|</code> operator can be eliminated.</p>

<p>The transformations of the rules will be described in the order of their
appearance in appendix A of the C11 standard, and the result will be presented
as a separate scanner and parser. Below, rules taken from the standard, or
needing more transformation work, are displayed in <code
class="c11">blue</code>, whereas final Pecan rules are displayed in <code
class="pecan">green</code>.  In describing transformations, only the first
example of each straightforward technique, plus difficult issues, will be
described.</p>

<h2>The Scanner</h2>

<p>The complete Pecan scanner for C11, and a small collection of tests, are in
the file:</p>

<p class="indent"><a href="c-scan.txt">c-scan.txt</a></p>

<p>The scanner is based on the lexical grammar which is gathered together in
appendix A.1 of the standard.  It is assumed that the implementation-defined
source character set consists of the visible Unicode characters, and that the
character encoding is UTF-8. It is also assumed that conversion of all newlines
to <code>\n</code>, translation of trigraphs, splicing of lines which end in
<code>\</code>, combining of consecutive string literals, and preprocessing have
already been done.  Scanning does not then involve any changes to the source
text.</p>

<h4>Tokens</h4>

<p>The initial rule of the scanner is:</p>

<pre class="pecan">tokens = @tokens token* Uc!
</pre>

<p>To ensure that the scanner produces a single output, there is an initial
action <code class="pecan">@tokens</code> which produces an empty list of
tokens. Thereafter, as each token is recognized, an action adds the token to the
list. The end of file is recognized using <code class="pecan">Uc!</code>. The
original rule for a token from the standard is:</p>

<pre class="c11">token = keyword | identifier | constant | string-literal | punctuator
</pre>

<p>In order to take a uniform approach to scanning, white space and comments,
described elsewhere in the standard, are included, so that all of the text is
processed.  (Technically, these are supposed to handled during preprocessing,
but they have been left in here for illustrative purposes.)</p>

<p>The order of the alternatives is changed to recognise string literals and
constants before keywords or identifiers, because of the ambiguity between
encoding prefixes and identifiers. And keywords are recognized before
identifiers, to keep the definition of identifiers simple, as in the original
grammar.  So the translated rule is:</p>

<pre class="pecan">token =
    gap / comment / constant / string-literal /
    keyword / identifier / punctuator
</pre>

<p>White space and comments can be recognized as tokens, and then discarded:</p>

<pre class="pecan">gap = (' ' / newline / tab / vtab / formfeed)+ @

comment =
    "//" (newline! visible)* @ /
    "/*" ("*/"! visible)* "*/" @
</pre>

<h4>Keywords</h4>

<p>In C, as in many languages, a word like <code>int</code> is not recognized as
a keyword if it is followed by more letters or digits, e.g. <code>intx</code> is
a single identifier, not the keyword <code>int</code> followed by
<code>x</code>. This fact is not entirely clear from the original grammar, which
has a local ambiguity at this point.  Although it can be argued according to CFG
semantics that such ambiguities get resolved at a more global level, it is much
clearer to resolve them locally.  Many such ambiguities, including this one, can
be resolved using a greedy convention, sometimes called maximal munch, where it
is assumed that the longest alternative is the one intended. To deal with this,
a rule is added to represent letters and digits which shouldn't follow the end
of a keyword, then lookahead is used to check each keyword:</p>

<pre class="pecan">more = identifier-nondigit / digit

keyword =
    ["alignof" more!] @1alignof /
    ["auto" more!] @1auto /
    ["break" more!] @1break /
    ...
    ["_Thread_local" more!] @1ThreadLocal
</pre>

<p>A naive translation of this grammar into a parser as a series of tests would
be inefficient. If the translation involves switches to recognise characters,
the efficiency would be much better.  However, each word would potentially still
be examined twice, once as a possible keyword, and then again as an identifier.
The traditional way to improve the efficiency further is to move the keyword
checking from the grammar into the externally attached code, which looks up
words in a hash table to decide if they are keywords or identifiers.</p>

<h4>Identifiers</h4>

<p>Identifiers exclude the keywords, which have already been matched. They
include type names introduced using <code>typedef</code>, and enumeration
constants, which can't be distinguished in the scanner, and must be recognized
later during parsing. The original rule for identifiers is:</p>

<pre class="c11">identifier =
    identifier-nondigit |
    identifier identifier-nondigit |
    identifier digit
</pre>

<p>Many of the original grammar rules use left recursion in this simple way to
express repetition.  Such rules can usually be translated in a routine way using
repetition operators like this:</p>

<pre class="pecan">identifier =
    identifier-nondigit (identifier-nondigit / digit)* @1id
</pre>

<p>Using Unicode letters in place of "other implementation-defined characters",
the remaining translated rules for identifiers are:</p>

<pre class="pecan">identifier = identifier-nondigit more* @1id

identifier-nondigit = nondigit / universal-character-name / other

nondigit = '_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'

digit = '0123456789'

hexadecimal-digit = '0123456789abcdefABCDEF'

other = Lu / Ll / Lt / Lm / Lo
</pre>

<h4>Universal character names</h4>

<p>The rules for universal character names are easily transformed:</p>

<pre class="pecan">universal-character-name = "\u" hex-quad / "\U" hex-quad hex-quad

hex-quad =
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
</pre>

<h4>Constants</h4>

<p>Constants are described in the original grammar by:</p>

<pre class="c11">constant =
    integer-constant | floating-constant |
    enumeration-constant | character-constant
</pre>

<p>Enumeration constants can't be distinguished from identifiers in the scanner,
so they need to be removed from this rule and dealt with in the parser.
Numerical
constants cause a problem, because both integer and floating constants can start
with digits.  It is possible to translate directly into a Pecan grammar rule by
using lookahead to try one alternative and then the other:</p>

<pre class="c11">constant =
    character-constant / [integer-constant] / floating-constant
</pre>

<p>It is tempting to try to improve on this by using a transformation approach
to find an equivalent form where no lookahead is needed.  However, this turns
out to be impossible. That's because, for example, <code>08</code> is
technically two tokens because <code>8</code> is not an octal digit, whereas the
three characters <code>08.</code> form a single floating constant.  That means,
after accepting the <code>0</code>, lookahead is needed at least as far as the
dot before knowing whether the token has ended.  Detection of non-octal digits
in octal constants could be left until a later semantic pass, but perhaps a
better approach is to find a cheap lookahead which looks for the first
non-digit.</p>

<pre class="pecan">constant =
    character-constant / is-float! integer-constant / floating-constant

is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')
</pre>

<p>The original rule for <code>integer-constant</code> is:</p>

<pre class="c11">integer-constant =
    decimal-constant integer-suffix? |
    octal-constant integer-suffix? |
    hexadecimal-constant integer-suffix?
</pre>

<p>This is another place in the C11 grammar where there is a local ambiguity. If
the source text contains <code>0x1</code> then this could match
<code>hexadecimal-constant</code>, or the first <code>0</code> on its own could
match <code>octal-constant</code>.  The greedy convention suggests that the
hexadecimal case should be checked first:</p>

<pre class="pecan">integer-constant =
    hexadecimal-constant integer-suffix? @1hex /
    octal-constant integer-suffix? @1octal /
    decimal-constant integer-suffix? @1decimal
</pre>

<p>One of the alternatives for a floating constant is a decimal floating
constant, with this original rule:</p>

<pre class="c11">decimal-floating-constant =
    fractional-constant exponent-part? floating-suffix? |
    digit-sequence exponent-part floating-suffix?
</pre>

<p>The alternatives have possible initial digits in common, so this needs some
work.  The original rule for <code>fractional-constant</code> is:</p>

<pre class="c11">fractional-constant =
    digit-sequence? '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>This is typical of many rules where there is a common left factor which is
reasonably easy to transform away using a sequence of routine transformations.
The first alternative can be expanded into two alternatives, according to
whether the optional <code>digit-sequence</code> is absent or present:</p>

<pre class="c11">fractional-constant =
    '.' digit-sequence |
    digit-sequence '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>Then the last two alternatives can be combined, and the choice operator
changed:</p>

<pre class="c11">fractional-constant =
    '.' digit-sequence /
    digit-sequence '.' digit-sequence?
</pre>

<p>This can now be substituted into the <code>decimal-floating-constant</code>
rule, and similar transformations applied to the result, to give:</p>

<pre class="pecan">decimal-floating-constant:
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?
</pre>

<p>Character constants may have an encoding prefix before the <code>"'"</code>.
To avoid a clash with identifiers, a small amount of lookahead, just two
characters, is needed.  Pecan's string notation is sufficient for this:</p>

<pre class="pecan">character-constant =
    ("'" / "L'" / "u'" / "U'") c-char-sequence "'" @1char
</pre>

<p>The remaining rules for constants can be easily dealt with.</p>

<h4>String literals</h4>

<p>String literals are described in the original grammar by:</p>

<pre class="c11">string-literal = encoding-prefix? '"' s-char-sequence? '"'

encoding-prefix = "u8" | "u" | "U" | "L"
</pre>

<p>This can be translated into:</p>

<pre class="pecan">string-literal =
    '"' s-char-sequence? '"' @1string /
    [encoding-prefix '"'] s-char-sequence? '"' @1string

encoding-prefix = "u8" / "u" / "U" / "L"
</pre>

<p>The try construct <code class="pecan">[encoding-prefix '"']</code> deals with
the overlap between prefixes and identifiers.</p>

<h4>Punctuators</h4>

<p>Punctuators are easier to recognize than keywords, because it doesn't matter
what they are followed by. However, they have to be ordered so that if one is a
prefix of another, the longer one is earlier and recognized preferentially,
according to the greedy convention.  Perhaps the easiest way to be sure of that
is to list them in order of length.</p>

<pre class="pecan">punctuator =
    "%:%:" @1hshs /
    "&lt;&lt;=" @1ltlteq /
    ">>=" @1gtgteq /
    "..." @1dtdtdt /
    "->" @1migt /
    ...
    "#" @1hs
</pre>

<p>The same approach can be taken to the remaining original lexical rules.</p>

<p>Although this translation of the C11 lexical rules has involved some work, it
has had the effect of exposing and resolving some issues.</p>

<h2>The Parser</h2>

<p>The parser is defined separately, with tokens from the scanner as its input.
The rules are presented in the order given in appendix A of the standard.
However, the first rule in Pecan must be the top rule of the grammar, so an
extra rule is added to achieve this:</p>

<pre class="pecan">start = translation-unit
</pre>

<p>It is assumed that tokens which have fixed names, that is keywords and
punctuators, are given token types that match their names.  For example, the
keyword <code>int</code> is passed as a token with type <code>`int`</code>, and
the operator <code>++</code> is passed as a token with type <code>`++`</code>.
This helps with readability, and with comparisons with the original rules.</p>

<p>For tokens which do not have fixed names, it is assumed that tokens are
passed with types such as <code>`identifier`</code> which match rule names in
the scanner.  It also assumed, as discussed earlier, that the external linked
with the parser tracks <code>typedef</code>s and reclassifies identifiers as
type names where appropriate.  To achieve a close match with the original rules,
synonyms are defined for these cases:</p>

<pre class="pecan">identifier = `identifier`
constant = `constant`
string-literal = `string-literal`
type-name = `type-name`
</pre>

<p>This establishes the communication between the scanner and the parser.</p>

<h4>Expressions</h4>

<p>Precedence and associativity are dealt with in the original grammar by
defining hierarchically layered rules for expressions.  The transformation into
Pecan follows the same style, and is reasonably straightforward.</p>

<p>The resulting parser is not efficient, because of the number of calls
involved in the hierarchy.  It can be made acceptably efficient by transforming
the recursive descent style into recursive ascent, but it seems better to do
that separately as a later exercise.</p>

<p>The original rule for primary expressions is:</p>

<pre class="c11">primary-expression =
    identifier |
    constant |
    string-literal |
    `(` expression `)` |
    generic-selection
</pre>

<p>There are no translation problems, since each alternative starts with a
different type of token:</p>

<pre class="pecan">primary-expression =
    identifier /
    constant /
    string-literal /
    `(` expression `)` /
    generic-selection
</pre>

<p>Generic selections are new in C11, but also cause no translation
problems:</p>

<pre class="pecan">generic-selection =
    `_Generic` `(` assignment-expression `,` generic-assoc-list `)`

generic-assoc-list = generic-association+

generic-association =
    type-name `:` assignment-expression /
    `default` `:` assignment-expression
</pre>

<p>The original rule for postfix expressions is:</p>

<pre class="c11">postfix-expression =
    primary-expression |
    postfix-expression `[` expression `]` |
    postfix-expression `(` argument-expression-list? `)` |
    postfix-expression `.` identifier |
    postfix-expression `->` identifier |
    postfix-expression `++` |
    postfix-expression `--` |
    `(` type-name `)` `{` initializer-list `}` |
    `(` type-name `)` `{` initializer-list `,` `}`
</pre>

<p>There is a problem here because the first alternative can be a bracketed
expression which begins with <code>`(`</code>, and the last two alternatives
also begin with <code>`(`</code>. An expression and a type name begin with
different tokens but, when bracketed, they require a two-token lookahead to
distinguish them.</p>

<p>In addition, the last two alternatives, which describe compound literals,
will cause an overlap later in the grammar with cast expressions, which also
begin with a bracketed type name.</p>

<p>Rather than stray too far from the structure of the original rules, a
lookahead rule is used to check for the open curly bracket:</p>

<pre class="pecan">is-compound-literal = `(`type-name `)` `{`
</pre>

<p>This may be regarded as a bit inefficient, but it is in the context of a top
down hierarchy of rules which is already inefficient.  So, it is best to defer a
good solution to this problem until later, when a transformation to a recursive
ascent style is investigated.</p>

<p>Now the left recursion can be removed from the postfix expression rule, the
last two alternatives can be merged and put at the beginning, and an extra rule
can be added for clarity to define the items that can come after a primary
expression.  The result is:</p>

<pre class="pecan">postfix-expression =
    is-compound-literal&amp; `(` type-name `)` `{` initializer-list `,`? `}` /
    primary-expression pe-suffix*

pe-suffix =
    `[` expression `]` /
    `(` argument-expression-list? `)` /
    `.` identifier /
    `->` identifier /
    `++` /
    `--`
</pre>

<p>The rule for an initializer list will later need to be defined to exclude the
optional final comma shown here.</p>

<p>The next layer up in the expression hierarchy is unary expressions, with
original rule:</p>

<pre class="c11">unary-expression  =
    postfix-expression |
    `++` unary-expression |
    `--` unary-expression |
    unary-operator cast-expression |
    `sizeof` unary-expression |
    `sizeof` `(` type-name `)` |
    `alignof` `(` type-name `)`
</pre>

<p>This is easily transformed, combining the two overlapping alternatives, to
give:</p>

<pre class="pecan">unary-expression  =
    postfix-expression /
    `++` unary-expression /
    `--` unary-expression /
    unary-operator cast-expression /
    `sizeof` (unary-expression / `(` type-name `)`) /
    `alignof` `(` type-name `)`
</pre>

<p>The next layer up is cast expressions, with original rule:</p>

<pre class="c11">cast-expression =
    unary-expression |
    "(" type-name ")" cast-expression
</pre>

<p>Again there is a problem with brackets, and again the route taken is to use
the lookahead rule defined earlier, in order to stay close to the structure of
the original rule:</p>

<pre class="pecan">cast-expression =
    (is-compound-literal! `(` type-name `)`)* unary-expression
</pre>

<p>The next level up in the hierarchy of expression is multiplicative
expressions, defined by the original rule:</p>

<pre class="c11">multiplicative-expression =
    cast-expression |
    multiplicative-expression "*" cast-expression |
    multiplicative-expression "/" cast-expression |
    multiplicative-expression "%" cast-expression
</pre>

<p>This can be transformed in a straightforward way to:</p>

<pre class="pecan">multiplicative-expression =
    cast-expression ((`*` / `/` / `%`) cast-expression)*
</pre>

<p>The same approach can be taken to additive expressions, shift expressions,
relational expressions, equality expressions, AND expressions, exclusive OR
expressions, inclusive OR expressions, logical AND expressions, and logical OR
expressions.  These all define the precedences of infix operators in the same
way.</p>

<p>The original rule for conditional expressions is:</p>

<pre class="c11">conditional-expression =
    logical-OR-expression |
    logical-OR-expression "?" expression ":" conditional-expression
</pre>

<p>This defines the ternary operator, but it easy to handle by combining the
prefixes and making the suffix optional:</p>

<pre class="pecan">conditional-expression =
    logical-OR-expression (`?` expression `:` conditional-expression)?
</pre>

<p>The original rule for assignment expressions is:</p>

<pre class="c11">assignment-expression =
    conditional-expression |
    unary-expression assignment-operator assignment-expression
</pre>

<p>This uses right recursion rather than left recursion, to capture the right
associativity of the assignment operators.  So the recursion can stay as it is.
However, there is a problematic overlap between the two alternatives.  Rather
than try to do anything efficient, the alternatives are swapped and lookahead is
used to recognise the assignment operator before accepting the new first
alternative:</p>

<pre class="pecan">assignment-expression =
    [unary-expression assignment-operator] assignment-expression /
    conditional-expression
</pre>

<p>At the top of the expression hierarchy is the expression rule:</p>

<pre class="c11">expression =
    assignment-expression |
    expression "," assignment-expression
</pre>

<p>This poses no problems, beyond the usual removal of left recursion:</p>

<pre class="pecan">expression =
    assignment-expression (`,` assignment-expression)*
</pre>

<p>The expression section of the C11 grammar has one more rule in it.  It is
just a synonym which makes some of the later rules more readable.  There is no
harm in including it in the Pecan translation:</p>

<pre class="pecan">constant-expression =
    conditional-expression
</pre>

<p>Thre rules (for initializer lists, type specifiers and type qualifiers) are
used in the expression rules, but are not defined until later.</p>

<hr/>
<p><b>Development incomplete</b></p>
<hr/>

<h2>Parser: external definitions</h2>

<p>The remainder of the C11 grammar covering the parser rules will be tackled in
sections.  A first prototype of the grammar, just demonstrating the handling of
external definitions in section A.2.4 of the standard, is:</p>

<p class="indent"><a href="c-parse-a.txt">c-parse-a.txt</a></p>

<p>With a few obvious cosmetic changes to the notation for compatibility with
Pecan, the CFG-based grammar begins with:</p>

<pre class="c11">translation-unit =
    external-declaration | translation-unit external-declaration
</pre>

<p>Removing the left recursion, adding an action to initialize an empty list of
external declarations, and adding end-of-file detection, this can be translated
into:</p>

<pre class="pecan">translation-unit = @0list external-declaration+ ``
</pre>

<p>The original grammar continues with:</p>

<pre class="c11">external-declaration = function-definition | declaration
</pre>

<p>The two alternatives are disjoint, because the grammar is unambiguous, but it
isn't immediately clear how to distinguish them. If it is just assumed that
there is no ambiguous overlap, then there is a direct translation into a Pecan
grammar rule by using lookahead to try one alternative and then the other:</p>

<pre class="c11">external-declaration = [function-definition] / declaration
</pre>

<p>However, since replacing the body of a function definition by a semicolon
yields a declaration, it is clear that the two alternatives share a lot in
common, to the point where it is worth merging them.  A fairly straightforward
transformation approach can be used to reach an equivalent form with no
lookahead needed. The relevant rules from the original grammar needed during the
transformation, with left recursion removed, are:</p>

<pre class="c11">function-definition =
    declaration-specifiers declarator declaration-list? compound-statement

declaration =
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration

init-declarator-list = init-declarator (`,` init-declarator)*

init-declarator = declarator (`=` initializer)?
</pre>

<p>This allows us to transform the rule for external declarations by expanding
<code>function-definition</code> and <code>declaration</code> to give:</p>

<pre class="c11">external-declaration =
    declaration-specifiers declarator declaration-list? compound-statement |
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration
</pre>

<p>The <code>static_assert-declaration</code> clause can be put first because it
begins with a distinctive keyword, and the common left factor
<code>declaration-specifiers</code> can be taken out, to yield:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        init-declarator-list? `;`
    )
</pre>

<p>Expanding <code>init-declarator-list</code> gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (init-declarator (`,` init-declarator)*)? `;`
    )
</pre>

<p>Expanding the first <code>init-declarator</code> gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (declarator (`=` initializer)? (`,` init-declarator)*)? `;`
    )
</pre>

<p>In order to get at the common left factor <code>declarator</code>, the second
alternative, which has the form <code>(x)? `;`</code>, can be replaced by
<code>x `;` / `;`</code> to give:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        declarator (`=` initializer)? (`,` init-declarator)* `;` |
        `;`
    )
</pre>

<p>Taking out the left factor <code>declarator</code> from the first two
alternatives gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator (
            declaration-list? compound-statement |
            (`=` initializer)? (`,` init-declarator)* `;`
        ) |
        `;`
    )
</pre>

<p>Looking at the two innermost alternatives, the second can clearly only start
with a token <code>`=`</code> or <code>`,`</code> or
<code>`;`</code>.  It is easy to check that the first alternative
cannot start with any of these, so no lookahead is necessary any more.</p>

<p>Converting to Pecan notation, adding some actions, and rearranging a bit,
gives:</p>

<pre class="pecan">external-declaration =
    static_assert-declaration @1declaration /
    declaration-specifiers (
        `;` @1declaration /
        declarator (
            (`=` initializer)? (`,` init-declarator)* `;` @1declaration /
            declaration-list? compound-statement @1definition
        )
    )
</pre>

<p>It is worth pointing out that, since <code class="pecan">declarator</code>
includes function declarators, this grammar does not preclude a declaration of
the form <code>int f() = 3;</code>.  A brief investigation of actual C compilers
suggests that this error is normally detected after, rather than during,
parsing.</p>

<p>The next stage is to deal with declarations</p>

<h2>Parser: declarations</h2>

<p>A second prototype of the grammar, demonstrating the full range of
declarations from appendix section A.2.2 of the C11 standard, is:</p>

<p class="indent"><a href="c-parse-b.txt">c-parse-b.txt</a></p>

<p>Most of the problems faced in parsing declarations are fairly easy.  For
example, the original grammar rule from the C11 standard (A.2.2) for a struct or
union specifier is:</p>

<pre class="c11">struct-or-union-specifier =
    struct-or-union identifier? `{` struct-declaration-list `}` |
    struct-or-union identifier
</pre>

<p>Expanding the first alternative, then rearranging to remove the common left
factors gives:</p>

<pre class="pecan">struct-or-union-specifier = struct-or-union (
    identifier (`{` struct-declaration-list `}`)? /
    `{` struct-declaration-list `}`
)
</pre>

<p>The original grammar rules for enumeration specifiers are:</p>

<pre class="c11">enum-specifier =
    `enum` identifier? `{` enumerator-list `}`
    `enum` identifier? `{` enumerator-list `,` `}`
    `enum` identifier

enumerator-list = enumerator (`,` enumerator)*
</pre>

<p>Perhaps the most obvious way to translate the first definition, expanding,
rearranging and combining left factors as before, is:</p>

<pre class="pecan">enum-specifier = `enum` (
    identifier (`{` enumerator-list `,`? `}`)? /
    `{` enumerator-list `,`? `}`
)
</pre>

<p>However, the fact that there is an optional final comma before the close
curly bracket causes a problem.  It means that care is needed to prevent it from
being matched in the second rule:</p>

<pre class="pecan">enumerator-list = enumerator ((`,` `}`)! `,` enumerator)*
</pre>

<p>The original rule for <code>direct-declarator</code> is:</p>

<pre class="c11">direct-declarator:
    identifier |
    `(` declarator `)` |
    direct-declarator `[` type-qualifier-list? assignment-expression? `]` |
    direct-declarator `[` `static` type-qualifier-list? assignment-expression `]` |
    direct-declarator `[` type-qualifier-list `static` assignment-expression `]` |
    direct-declarator `[` type-qualifier-list? `*` `]` |
    direct-declarator `(` parameter-type-list `)` |
    direct-declarator `(` identifier-list? `)` |
</pre>

<p>Removing the left recursion, combining the contents of each kind of bracket,
disambiguating alternatives <code>parameter-type-list</code> and
<code>identifier-list</code> by reversing the alternatives and using lookahead
to check for the first identifier, inventing extra rules for clarity, and
tidying up, yields:</p>

<pre class="pecan">direct-declarator =
    (identifier / `(` declarator `)`) dd-bracket*

dd-bracket =
    `(` dd-parameters? `)` / `[` dd-array-size? `]`

dd-parameters =
    identifier&amp; identifier-list / parameter-type-list

dd-array-size =
    `*` /
    `static` type-qualifier-list? assignment-expression /
    type-qualifier-list dd-simple-array-size? /
    assignment-expression

dd-simple-array-size =
    `*` /
    `static` assignment-expression /
    assignment-expression
</pre>

<p>The original rule for <code>direct-abstract-declarator</code> is:</p>

<pre class="c11">direct-abstract-declarator =
    `(` abstract-declarator `)` |
    direct-abstract-declarator? `[` type-qualifier-list? assignment-expression? `]` |
    direct-abstract-declarator? `[` `static` type-qualifier-list? assignment-expression `]` |
    direct-abstract-declarator? `[` type-qualifier-list `static` assignment-expression `]` |
    direct-abstract-declarator? `[` `*` `]` |
    direct-abstract-declarator? `(` parameter-type-list? `)`
</pre>

<p>Going through a similar sequence of small transformations yields:</p>

<pre class="pecan">direct-abstract-declarator =
    `(` abstract-declarator `)` dad-bracket* / dad-bracket+

dad-bracket =
    `(` parameter-type-list? `)` / `[` dad-array-size? `]`

dad-array-size =
    `*` /
    `static` type-qualifier-list? assignment-expression /
    type-qualifier-list dad-simple-array-size? /
    assignment-expression

dad-simple-array-size =
    assignment-expression / `static` assignment-expression
</pre>

<p>The original rule for <code>parameter-declaration</code> is:</p>

<pre class="c11">parameter-declaration =
    declaration-specifiers declarator |
    declaration-specifiers abstract-declarator?
</pre>

<p>Taking out the common left factor, this becomes:</p>

<pre class="c11">parameter-declaration = declaration-specifiers (
    declarator |
    abstract-declarator?
)
</pre>

<p>The approach taken earlier to combine alternatives by transformation to find
their common prefixes doesn't work here, because recursion intervenes before the
issue is resolved.  So, it is better to use lookahead.  However, it is worth
finding a 'cheap' lookahead.  The main difference between the alternatives is
that <code>declarator</code> includes an identifier.  Checking the
possibilities, only <code>`*`</code> or <code>type-qualifier</code> or
<code>`(`</code> tokens can occur before the identifier. On the other hand, in
an <code>abstract-declarator</code>, a close bracket must appear before the end.
This leads to:</p>

<pre class="pecan">parameter-declaration = declaration-specifiers (
    has-identifier&amp; declarator /
    abstract-declarator?
)

has-identifier =
    (`*` / type-qualifier / `(`)* `identifier`
</pre>

<p>The transformation of the remainder of the declaration rules is relatively
straightforward.</p>

<h2>Parser: statements</h2>

<p>A third prototype, adding statement rules from A.2.3 of the standard, is</p>

<p class="indent"><a href="c-parse-c.txt">c-parse-c.txt</a></p>

<p>The original main rule for statements is:</p>

<pre class="c11">
statement =
    labeled-statement |
    compound-statement |
    expression-statement |
    selection-statement |
    iteration-statement |
    jump-statement
</pre>

<p>Most statements begin with a distinctive keyword. A simple check reveals that
the only overlap of first tokens is that <code>labeled-statement</code> and
<code>expression-statement</code> can both start with an identifier.  However,
only in the <code>labeled-statement</code> case is it immediately followed by a
colon.  Thus the above rule can be translated trivially, and
<code>labeled-statement</code> can be given a simple two-token lookahead:</p>

<pre class="pecan">
statement =
    labeled-statement /
    compound-statement /
    expression-statement /
    selection-statement /
    iteration-statement /
    jump-statement

labeled-statement =
    [identifier `:`] statement /
    `case` constant-expression `:` statement /
    `default` `:` statement
</pre>

<p>The original rule for a compound statement is easily transformed directly
into:</p>

<pre class="pecan">compound-statement = `{` block-item* `}`
</pre>

<p>The original rule for a block item is:</p>

<pre class="c11">block-item = declaration | statement
</pre>

<p>The only overlap between the first tokens of the two alternatives is that a
declaration may start with an identifier which is a typedef name, and a
statement may begin with an identifier.  Typedef names need to be recognised
separately.  That is done by adding an action to the grammar at the point where
a typedef name is declared, as well as actions which keep track of scopes.  The
action causes the externally linked code to record the new typedef name in a
symbol table.  Thereafter, within the scope of the typedef name, tokens matching
the typedef name are presented to the parser with a different token type.  In
addition, it is necessary to <em>remove</em> the rule from the grammar for
typedef names:</p>

<pre class="c11">typedef-name = identifier
</pre>

<p>It can be replaced by a rule which indicated that it is a token type:</p>

<pre class="pecan">typedef-name = `typedef-name`
</pre>

<p>With this understanding, the rule for block items can be accepted as it
is:</p>

<pre class="pecan">block-item = declaration / statement
</pre>

<p>The rule for expression statements is unproblematic:</p>

<pre class="pecan">expression-statement = expression? `;`
</pre>

<p>With selection statements, the original rule is:</p>

<pre class="c11">selection-statement =
    `if` `(` expression `)` statement |
    `if` `(` expression `)` statement `else` statement |
    `switch` `(` expression `)` statement
</pre>

<p>This suffers from the infamous <a
href="https://en.wikipedia.org/wiki/Dangling_else">dangling else</a> ambiguity.
There is a well-known technique for resolving the ambiguity by having separate
rules for open and closed statements. That technique only applies to CFG
grammars, and doesn't directly help in transforming into Pecan (except perhaps
to clarify the meaning of the original grammar). However, the problem simply
goes away, if the obvious Pecan rule is written down. By the very nature of the
'greedy' <code>/</code> operator, an <code>else</code> clause will naturally be
attached to the closest <code>if</code> statement.</p>

<pre class="pecan">selection-statement =
    `if` `(` expression `)` statement (`else` statement)? /
    `switch` `(` expression `)` statement
</pre>

<p>The rule for iteration statements starts out as:</p>

<pre class="c11">iteration-statement =
    `while` `(` expression `)` statement |
    `do` statement `while` `(` expression `)` `;` |
    `for` `(` expression? `;` expression? `;` expression? `)` statement |
    `for` `(` declaration expression? `;` expression? `)` statement
</pre>

<p>The only problem is with the last pair of alternatives concerning
<code>for</code> statements.  The last alternatives look slightly odd, as if it
lacks a semicolon. That's because a declaration includes its terminating
semicolon. Given the treatment of typedef names already described, declarations
and expressions are easily distinguished by their first tokens, so the rule can
be transformed to:</p>

<pre class="pecan">iteration-statement =
    `while` `(` expression `)` statement /
    `do` statement `while` `(` expression `)` `;` /
    `for` `(` for-start expression? `;` expression? `)` statement

for-start = declaration / expression? `;`
</pre>

<p>The rule for jump statements can be transformed directly into:</p>

<pre class="pecan">jump-statement =
    `goto` identifier `;` /
    `continue` `;` /
    `break` `;` /
    `return` expression? `;`
</pre>


</body>
</html>
