<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial: C</title>
<style>
  pre, .indent { margin-left: 40px; }
  pre.c11, code.c11 { color: #00a; }
  pre.pecan, code.pecan { color: #060; }
</style>
</head>
<body>

<img src="../pecan.png" width="300" height="65" />
<hr/>

<h1>Pecan Case study: C11</h1>

<p>The development of a scanner and parser for C11 presented here is based on
the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf">C11
standard</a>. It demonstrates the use of Pecan and, in particular, the use of
(manual) grammar transformation as a way of developing parsers.</p>

<p>The result is simply a literal translation of the official C11 grammar into
the Pecan notation.  It does not take into account common extensions or other
variations to the C11 language, or differing interpretations of the standard,
nor does it attempt to deal with the preprocessing phase or all of the practical
issues that arise in real C compilers. It has also only been lightly tested. It
is not intended to be a compiler-grade parser, merely a reinterpretation of the
official grammar.</p>

<p>Infamously, parsing of C requires type names introduced using
<code>typedef</code> to be differentiated from other identifiers.  This cannot
be done during scanning.  Instead, token tags must be altered during parsing,
which must include some form of symbol table construction.  Pecan parsers allows
for this in their interaction with external code.  It is assumed that suitable
external code will be added to the parser to achieve this.</p>

<p>The development described here amounts to translating the C11 syntax into a
nearly-recursive-descent form, which has been done before, perhaps most notably
in the clang compiler.  The difference is that a potentially reusable grammar
has been produced rather than a one-off parser for a specific purpose.</p>

<h2>Transliteration</h2>

<p>The first step is to carry out a few obvious cosmetic changes to the rules
from Appendix A of the C11 standard for compatibility with Pecan.  The result is
presented in this file, for reference while going through the
transformations.</p>

<p class="indent"><a href="c11-grammar.txt">c11-grammar.txt</a></p>

<p>Terminal symbols in bold such as <b><code>int</code></b> are quoted as
<code>"int"</code> instead. Definitions <code>x: y</code> have the colon
replaced by an equal sign to give <code>x = y</code>, the optional suffix
<code>x<sub>opt</sub></code> is replaced by a question mark <code>x?</code>, and
choices which are implicit from the layout have explicit choice operators
<code>|</code> added.  Rules are effectively presented in a mythical language
which is Pecan with an extra <code>|</code> operator having CFG semantics. The
aim is to apply transformations until the alternatives of any <code>|</code>
operator can clearly be distinguished by the PEG operator <code>/</code>
instead, so that the <code>|</code> operator can be eliminated.</p>

<p>The transformations of the rules will be described in the order of their
appearance in appendix A of the C11 standard, and the result will be presented
as a separate scanner and parser. Below, rules taken from the standard, or
needing more transformation work, are displayed in <code
class="c11">blue</code>, whereas final Pecan rules are displayed in <code
class="pecan">green</code>.</p>

<h2>The Scanner</h2>

<p>The complete Pecan scanner for C11, and a small collection of tests, are in
the file:</p>

<p class="indent"><a href="c-scan.txt">c-scan.txt</a></p>

<p>The scanner is based on the lexical grammar which is gathered together in
appendix A.1 of the standard.  It is assumed that the implementation-defined
source character set consists of the visible Unicode characters, and that the
character encoding is UTF-8. It is also assumed that conversion of all newlines
to <code>\n</code>, translation of trigraphs, splicing of lines which end in
<code>\</code>, combining of consecutive string literals, and preprocessing have
already been done.  Scanning does not then involve any changes to the source
text.</p>

<h4>Tokens</h4>

<p>The initial rule of the scanner is:</p>

<pre class="pecan">tokens = @tokens token* Uc!
</pre>

<p>To ensure that the scanner produces a single output, there is an initial
action <code class="pecan">@tokens</code> which produces an empty list of
tokens. Thereafter, as each token is recognized, an action adds the token to the
list. The end of file is recognized using <code class="pecan">Uc!</code>. The
original rule for a token from the standard is:</p>

<pre class="c11">token = keyword | identifier | constant | string-literal | punctuator
</pre>

<p>In order to take a uniform approach to scanning, white space and comments,
described elsewhere in the standard, are included, so that all of the text is
processed.  Also, the order is changed to recognise string literals and
constants before keywords or identifiers, because of the possibility of an
encoding prefix at the start of a string literal or character constant. Keywords
are recognized before identifiers, to keep the definition of identifiers simple,
as in the original grammar.  So the translated rule is:</p>

<pre class="pecan">token =
    gap / comment / constant / string-literal /
    keyword / identifier / punctuator
</pre>

<p>White space and comments can be recognized as tokens, and then discarded,
like this:</p>

<pre class="pecan">gap = (' ' / newline / tab / vtab / formfeed)+ @

comment =
    "//" (newline! visible)* @ /
    "/*" ("*/"! visible)* "*/" @
</pre>

<h4>Keywords</h4>

<p>In C, as in many languages, a word like <code>int</code> is not recognized as
a keyword if it is followed by more letters or digits, e.g. <code>intx</code> is
a single identifier, not the keyword <code>int</code> followed by
<code>x</code>. This fact is not entirely clear from the original grammar, which
has a local ambiguity at this point.  Although it can be argued according to CFG
semantics that such ambiguities get resolved at a more global level, it is much
clearer to resolve them locally.  Many such ambiguities, including this one, can
be resolved using a greedy convention, sometimes called maximal munch, where it
is assumed that the longest alternative is the one intended. To deal with this,
a rule is added to represent letters and digits which shouldn't follow the end
of a keyword, then lookahead is used to check it for each keyword:</p>

<pre class="pecan">more = identifier-nondigit / digit

keyword =
    ["alignof" more!] @1alignof /
    ["auto" more!] @1auto /
    ["break" more!] @1break /
    ...
    ["_Thread_local" more!] @1ThreadLocal
</pre>

<h4>Identifiers</h4>

<p>Identifiers exclude the keywords, and include type names introduced using
<code>typedef</code>, and enumeration constants, which can't be distinguished in
the scanner.  Those are recognized during parsing.  Using Unicode letters in
place of "other implementation-defined characters", the translated rules for
identifiers are:</p>

<pre class="pecan">identifier = identifier-nondigit (identifier-nondigit / digit)* @1id

identifier-nondigit = nondigit / universal-character-name / other

nondigit = '_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'

digit = '0123456789'

hexadecimal-digit = '0123456789abcdefABCDEF'

other = Lu / Ll / Lt / Lm / Lo
</pre>

<h4>Universal character names</h4>

<pre class="pecan">universal-character-name = "\u" hex-quad / "\U" hex-quad hex-quad

hex-quad =
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
</pre>

<h4>Constants</h4>

<p>Constants are described in the original grammar by:</p>

<pre class="c11">constant =
    integer-constant | floating-constant |
    enumeration-constant | character-constant
</pre>

<p>Enumeration constants can't be distinguished from identifiers in the scanner,
so they need to be removed from this rule and dealt with in the parser.
Character constants may have a prefix before the <code>"'"</code>, and can be
recognised in a similar way to string literals. It is convenient to deal with
them as the first alternative to get them out of the way.  Numerical constants
cause a problem, because both integer and floating constants can start with
digits.  It is possible to translate directly into a Pecan grammar rule by using
lookahead to try one alternative and then the other:</p>

<pre class="c11">constant =
    character-constant / [integer-constant] / floating-constant
</pre>

<p>It is tempting to try to improve on this by using a transformation approach
to find an equivalent form where no lookahead is needed.  However, this turns
out to be impossible. That's because, for example, <code>08</code> is
technically two tokens because <code>8</code> is not an octal digit, whereas
<code>08.</code> is a single floating constant.  That means, after accepting the
<code>0</code>, lookahead is needed at least as far as the dot before knowing
whether the token has ended.  Detection of non-octal digits in octal constants
could be left until a later semantic pass, but perhaps a better approach is to
find a cheap lookahead which looks for the first non-digit.</p>

<pre class="pecan">constant =
    character-constant / is-float! integer-constant / floating-constant

is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')
</pre>

<p>The original rule for <code>integer-constant</code> is:</p>

<pre class="c11">integer-constant =
    decimal-constant integer-suffix? |
    octal-constant integer-suffix? |
    hexadecimal-constant integer-suffix?
</pre>

<p>This is another place in the C11 grammar where there is a local ambiguity. If
the source text contains <code>0x1</code> then this could match
<code>hexadecimal-constant</code>, or the first <code>0</code> on its own could
match <code>octal-constant</code>.  The greedy convention suggests that the
hexadecimal case should be checked first:</p>

<pre class="pecan">integer-constant =
    hexadecimal-constant integer-suffix? @1hex /
    octal-constant integer-suffix? @1octal /
    decimal-constant integer-suffix? @1decimal
</pre>

<p>One of the alternatives for a floating constant is a decimal floating
constant, with this original rule:</p>

<pre class="c11">decimal-floating-constant =
    fractional-constant exponent-part? floating-suffix? |
    digit-sequence exponent-part floating-suffix?
</pre>

<p>The alternatives have possible initial digits in common, so this needs some
work.  The original rule for <code>fractional-constant</code> is:</p>

<pre class="c11">fractional-constant =
    digit-sequence? '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>This is typical of many rules where there is a common left factor which is
reasonably easy to transform away using routine transformations.  The first
alternative can be expanded into two alternatives, according to whether the
optional <code>digit-sequence</code> is absent or present:</p>

<pre class="c11">fractional-constant =
    '.' digit-sequence |
    digit-sequence '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>Then the last two alternatives can be combined, and the choice operator
changed:</p>

<pre class="c11">fractional-constant =
    '.' digit-sequence /
    digit-sequence '.' digit-sequence?
</pre>

<p>This can now be substituted into the <code>decimal-floating-constant</code>
rule, and similar transformations applied to the result, to give:</p>

<pre class="pecan">decimal-floating-constant:
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?
</pre>

<h4>String literals</h4>

<p>Leaving constants until later, string literals are described in the original
grammar by:</p>

<pre class="c11">string-literal = encoding-prefix? '"' s-char-sequence? '"'

encoding-prefix = "u8" | "u" | "U" | "L"
</pre>

<p>This can be translated into:</p>

<pre class="pecan">string-literal =
    '"' s-char-sequence? '"' @1string /
    [encoding-prefix '"'] s-char-sequence? '"' @1string

encoding-prefix = "u8" / "u" / "U" / "L"
</pre>

<p>The try construct <code class="pecan">[encoding-prefix '"']</code> ensures
that a prefix such as <code>u8</code> on its own does not match.
The characters inside a string literal are described in the original grammar
by:</p>

<pre class="c11">s-char-sequence =
    s-char |
    s-char-sequence s-char
</pre>

<p>Many of the original grammar rules use left recursion in this simple way to
express repetition.  Such rules can usually be translated in a routine way using
repetition operators like this:</p>

<pre class="pecan">s-char-sequence = s-char+
</pre>

<p>Punctuators are easier to recognize than keywords, because it doesn't matter
what they are followed by. However, they have to be ordered so that if one is a
prefix of another, the longer one is recognized preferentially, according to the
greedy convention.  Perhaps the easiest way to be sure of that is to list them
in length order.</p>

<pre class="pecan">punctuator =
    "%:%:" @1hshs /
    "&lt;&lt;=" @1ltlteq /
    ">>=" @1gtgteq /
    "..." @1dtdtdt /
    "->" @1migt /
    ...
    "#" @1hs
</pre>

<p>The same approach can be taken to the remaining original rules.</p>

<p>Although this translation of the C11 lexical rules has involved some work, it
has had the effect of exposing and resolving some issues.</p>

<h2>Parser: external definitions</h2>

<p>The remainder of the C11 grammar covering the parser rules will be tackled in
sections.  A first prototype of the grammar, just demonstrating the handling of
external definitions in section A.2.4 of the standard, is:</p>

<p class="indent"><a href="c-parse-a.txt">c-parse-a.txt</a></p>

<p>With a few obvious cosmetic changes to the notation for compatibility with
Pecan, the CFG-based grammar begins with:</p>

<pre class="c11">translation-unit =
    external-declaration | translation-unit external-declaration
</pre>

<p>Removing the left recursion, adding an action to initialize an empty list of
external declarations, and adding end-of-file detection, this can be translated
into:</p>

<pre class="pecan">translation-unit = @0list external-declaration+ ``
</pre>

<p>The original grammar continues with:</p>

<pre class="c11">external-declaration = function-definition | declaration
</pre>

<p>The two alternatives are disjoint, because the grammar is unambiguous, but it
isn't immediately clear how to distinguish them. If it is just assumed that
there is no ambiguous overlap, then there is a direct translation into a Pecan
grammar rule by using lookahead to try one alternative and then the other:</p>

<pre class="c11">external-declaration = [function-definition] / declaration
</pre>

<p>However, since replacing the body of a function definition by a semicolon
yields a declaration, it is clear that the two alternatives share a lot in
common, to the point where it is worth merging them.  A fairly straightforward
transformation approach can be used to reach an equivalent form with no
lookahead needed. The relevant rules from the original grammar needed during the
transformation, with left recursion removed, are:</p>

<pre class="c11">function-definition =
    declaration-specifiers declarator declaration-list? compound-statement

declaration =
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration

init-declarator-list = init-declarator (`,` init-declarator)*

init-declarator = declarator (`=` initializer)?
</pre>

<p>This allows us to transform the rule for external declarations by expanding
<code>function-definition</code> and <code>declaration</code> to give:</p>

<pre class="c11">external-declaration =
    declaration-specifiers declarator declaration-list? compound-statement |
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration
</pre>

<p>The <code>static_assert-declaration</code> clause can be put first because it
begins with a distinctive keyword, and the common left factor
<code>declaration-specifiers</code> can be taken out, to yield:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        init-declarator-list? `;`
    )
</pre>

<p>Expanding <code>init-declarator-list</code> gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (init-declarator (`,` init-declarator)*)? `;`
    )
</pre>

<p>Expanding the first <code>init-declarator</code> gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (declarator (`=` initializer)? (`,` init-declarator)*)? `;`
    )
</pre>

<p>In order to get at the common left factor <code>declarator</code>, the second
alternative, which has the form <code>(x)? `;`</code>, can be replaced by
<code>x `;` / `;`</code> to give:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        declarator (`=` initializer)? (`,` init-declarator)* `;` |
        `;`
    )
</pre>

<p>Taking out the left factor <code>declarator</code> from the first two
alternatives gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator (
            declaration-list? compound-statement |
            (`=` initializer)? (`,` init-declarator)* `;`
        ) |
        `;`
    )
</pre>

<p>Looking at the two innermost alternatives, the second can clearly only start
with a token <code>`=`</code> or <code>`,`</code> or
<code>`;`</code>.  It is easy to check that the first alternative
cannot start with any of these, so no lookahead is necessary any more.</p>

<p>Converting to Pecan notation, adding some actions, and rearranging a bit,
gives:</p>

<pre class="pecan">external-declaration =
    static_assert-declaration @1declaration /
    declaration-specifiers (
        `;` @1declaration /
        declarator (
            (`=` initializer)? (`,` init-declarator)* `;` @1declaration /
            declaration-list? compound-statement @1definition
        )
    )
</pre>

<p>It is worth pointing out that, since <code class="pecan">declarator</code>
includes function declarators, this grammar does not preclude a declaration of
the form <code>int f() = 3;</code>.  A brief investigation of actual C compilers
suggests that this error is normally detected after, rather than during,
parsing.</p>

<p>The next stage is to deal with declarations</p>

<h2>Parser: declarations</h2>

<p>A second prototype of the grammar, demonstrating the full range of
declarations from appendix section A.2.2 of the C11 standard, is:</p>

<p class="indent"><a href="c-parse-b.txt">c-parse-b.txt</a></p>

<p>Most of the problems faced in parsing declarations are fairly easy.  For
example, the original grammar rule from the C11 standard (A.2.2) for a struct or
union specifier is:</p>

<pre class="c11">struct-or-union-specifier =
    struct-or-union identifier? `{` struct-declaration-list `}` |
    struct-or-union identifier
</pre>

<p>Expanding the first alternative, then rearranging to remove the common left
factors gives:</p>

<pre class="pecan">struct-or-union-specifier = struct-or-union (
    identifier (`{` struct-declaration-list `}`)? /
    `{` struct-declaration-list `}`
)
</pre>

<p>The original grammar rules for enumeration specifiers are:</p>

<pre class="c11">enum-specifier =
    `enum` identifier? `{` enumerator-list `}`
    `enum` identifier? `{` enumerator-list `,` `}`
    `enum` identifier

enumerator-list = enumerator (`,` enumerator)*
</pre>

<p>Perhaps the most obvious way to translate the first definition, expanding,
rearranging and combining left factors as before, is:</p>

<pre class="pecan">enum-specifier = `enum` (
    identifier (`{` enumerator-list `,`? `}`)? /
    `{` enumerator-list `,`? `}`
)
</pre>

<p>However, the fact that there is an optional final comma before the close
curly bracket causes a problem.  It means that care is needed to prevent it from
being matched in the second rule:</p>

<pre class="pecan">enumerator-list = enumerator ((`,` `}`)! `,` enumerator)*
</pre>

<p>The original rule for <code>direct-declarator</code> is:</p>

<pre class="c11">direct-declarator:
    identifier |
    `(` declarator `)` |
    direct-declarator `[` type-qualifier-list? assignment-expression? `]` |
    direct-declarator `[` `static` type-qualifier-list? assignment-expression `]` |
    direct-declarator `[` type-qualifier-list `static` assignment-expression `]` |
    direct-declarator `[` type-qualifier-list? `*` `]` |
    direct-declarator `(` parameter-type-list `)` |
    direct-declarator `(` identifier-list? `)` |
</pre>

<p>Removing the left recursion, combining the contents of each kind of bracket,
disambiguating alternatives <code>parameter-type-list</code> and
<code>identifier-list</code> by reversing the alternatives and using lookahead
to check for the first identifier, inventing extra rules for clarity, and
tidying up, yields:</p>

<pre class="pecan">direct-declarator =
    (identifier / `(` declarator `)`) dd-bracket*

dd-bracket =
    `(` dd-parameters? `)` / `[` dd-array-size? `]`

dd-parameters =
    identifier&amp; identifier-list / parameter-type-list

dd-array-size =
    `*` /
    `static` type-qualifier-list? assignment-expression /
    type-qualifier-list dd-simple-array-size? /
    assignment-expression

dd-simple-array-size =
    `*` /
    `static` assignment-expression /
    assignment-expression
</pre>

<p>The original rule for <code>direct-abstract-declarator</code> is:</p>

<pre class="c11">direct-abstract-declarator =
    `(` abstract-declarator `)` |
    direct-abstract-declarator? `[` type-qualifier-list? assignment-expression? `]` |
    direct-abstract-declarator? `[` `static` type-qualifier-list? assignment-expression `]` |
    direct-abstract-declarator? `[` type-qualifier-list `static` assignment-expression `]` |
    direct-abstract-declarator? `[` `*` `]` |
    direct-abstract-declarator? `(` parameter-type-list? `)`
</pre>

<p>Going through a similar sequence of small transformations yields:</p>

<pre class="pecan">direct-abstract-declarator =
    `(` abstract-declarator `)` dad-bracket* / dad-bracket+

dad-bracket =
    `(` parameter-type-list? `)` / `[` dad-array-size? `]`

dad-array-size =
    `*` /
    `static` type-qualifier-list? assignment-expression /
    type-qualifier-list dad-simple-array-size? /
    assignment-expression

dad-simple-array-size =
    assignment-expression / `static` assignment-expression
</pre>

<p>The original rule for <code>parameter-declaration</code> is:</p>

<pre class="c11">parameter-declaration =
    declaration-specifiers declarator |
    declaration-specifiers abstract-declarator?
</pre>

<p>Taking out the common left factor, this becomes:</p>

<pre class="c11">parameter-declaration = declaration-specifiers (
    declarator |
    abstract-declarator?
)
</pre>

<p>The approach taken earlier to combine alternatives by transformation to find
their common prefixes doesn't work here, because recursion intervenes before the
issue is resolved.  So, it is better to use lookahead.  However, it is worth
finding a 'cheap' lookahead.  The main difference between the alternatives is
that <code>declarator</code> includes an identifier.  Checking the
possibilities, only <code>`*`</code> or <code>type-qualifier</code> or
<code>`(`</code> tokens can occur before the identifier. On the other hand, in
an <code>abstract-declarator</code>, a close bracket must appear before the end.
This leads to:</p>

<pre class="pecan">parameter-declaration = declaration-specifiers (
    has-identifier&amp; declarator /
    abstract-declarator?
)

has-identifier =
    (`*` / type-qualifier / `(`)* `identifier`
</pre>

<p>The transformation of the remainder of the declaration rules is relatively
straightforward.</p>

<h2>Parser: statements</h2>

<p>A third prototype, adding statement rules from A.2.3 of the standard, is</p>

<p class="indent"><a href="c-parse-c.txt">c-parse-c.txt</a></p>

<p>The original main rule for statements is:</p>

<pre class="c11">
statement =
    labeled-statement |
    compound-statement |
    expression-statement |
    selection-statement |
    iteration-statement |
    jump-statement
</pre>

<p>Most statements begin with a distinctive keyword. A simple check reveals that
the only overlap of first tokens is that <code>labeled-statement</code> and
<code>expression-statement</code> can both start with an identifier.  However,
only in the <code>labeled-statement</code> case is it immediately followed by a
colon.  Thus the above rule can be translated trivially, and
<code>labeled-statement</code> can be given a simple two-token lookahead:</p>

<pre class="pecan">
statement =
    labeled-statement /
    compound-statement /
    expression-statement /
    selection-statement /
    iteration-statement /
    jump-statement

labeled-statement =
    [identifier `:`] statement /
    `case` constant-expression `:` statement /
    `default` `:` statement
</pre>

<p>The original rule for a compound statement is easily transformed directly
into:</p>

<pre class="pecan">compound-statement = `{` block-item* `}`
</pre>

<p>The original rule for a block item is:</p>

<pre class="c11">block-item = declaration | statement
</pre>

<p>The only overlap between the first tokens of the two alternatives is that a
declaration may start with an identifier which is a typedef name, and a
statement may begin with an identifier.  Typedef names need to be recognised
separately.  That is done by adding an action to the grammar at the point where
a typedef name is declared, as well as actions which keep track of scopes.  The
action causes the externally linked code to record the new typedef name in a
symbol table.  Thereafter, within the scope of the typedef name, tokens matching
the typedef name are presented to the parser with a different token type.  In
addition, it is necessary to <em>remove</em> the rule from the grammar for
typedef names:</p>

<pre class="c11">typedef-name = identifier
</pre>

<p>It can be replaced by a rule which indicated that it is a token type:</p>

<pre class="pecan">typedef-name = `typedef-name`
</pre>

<p>With this understanding, the rule for block items can be accepted as it
is:</p>

<pre class="pecan">block-item = declaration / statement
</pre>

<p>The rule for expression statements is unproblematic:</p>

<pre class="pecan">expression-statement = expression? `;`
</pre>

<p>With selection statements, the original rule is:</p>

<pre class="c11">selection-statement =
    `if` `(` expression `)` statement |
    `if` `(` expression `)` statement `else` statement |
    `switch` `(` expression `)` statement
</pre>

<p>This suffers from the infamous <a
href="https://en.wikipedia.org/wiki/Dangling_else">dangling else</a> ambiguity.
There is a well-known technique for resolving the ambiguity by having separate
rules for open and closed statements. That technique only applies to CFG
grammars, and doesn't directly help in transforming into Pecan (except perhaps
to clarify the meaning of the original grammar). However, the problem simply
goes away, if the obvious Pecan rule is written down. By the very nature of the
'greedy' <code>/</code> operator, an <code>else</code> clause will naturally be
attached to the closest <code>if</code> statement.</p>

<pre class="pecan">selection-statement =
    `if` `(` expression `)` statement (`else` statement)? /
    `switch` `(` expression `)` statement
</pre>

<p>The rule for iteration statements starts out as:</p>

<pre class="c11">iteration-statement =
    `while` `(` expression `)` statement |
    `do` statement `while` `(` expression `)` `;` |
    `for` `(` expression? `;` expression? `;` expression? `)` statement |
    `for` `(` declaration expression? `;` expression? `)` statement
</pre>

<p>The only problem is with the last pair of alternatives concerning
<code>for</code> statements.  The last alternatives look slightly odd, as if it
lacks a semicolon. That's because a declaration includes its terminating
semicolon. Given the treatment of typedef names already described, declarations
and expressions are easily distinguished by their first tokens, so the rule can
be transformed to:</p>

<pre class="pecan">iteration-statement =
    `while` `(` expression `)` statement /
    `do` statement `while` `(` expression `)` `;` /
    `for` `(` for-start expression? `;` expression? `)` statement

for-start = declaration / expression? `;`
</pre>

<p>The rule for jump statements can be transformed directly into:</p>

<pre class="pecan">jump-statement =
    `goto` identifier `;` /
    `continue` `;` /
    `break` `;` /
    `return` expression? `;`
</pre>

<h2>Parser: expressions</h2>

<hr/>
<p><b>Development incomplete</b></p>
<hr/>

<p>The original rule for primary expressions is:</p>

<pre class="c11">primary-expression =
    identifier |
    constant |
    string-literal |
    `(` expression `)` |
    generic-selection
</pre>

<p>The first three are tokens produced by the scanner, so simple rules for them
can be added to indicate that they are token types.  Otherwise, there are no
translation problems:</p>

<pre class="pecan">primary-expression =
    identifier /
    constant /
    string-literal /
    `(` expression `)` /
    generic-selection

identifier = `identifier`
constant = `constant`
string-literal = `string-literal`
</pre>

<p>Generic selections are new in C11, but cause no translation problems:</p>

<pre class="pecan">generic-selection =
    `_Generic` `(` assignment-expression `,` generic-assoc-list `)`

generic-assoc-list = generic-association+

generic-association =
    type-name `:` assignment-expression /
    `default` `:` assignment-expression
</pre>

<p>Precedence and associativity are dealt with in the original grammar by
defining hierarchically layered rules for expressions.  The transformation into
Pecan is reasonably straightforward.  The resulting parser is not efficient,
because of the number of calls involved in the hierarchy.  The parser can be
made acceptably efficient by transforming the recursive descent style into
recursive ascent, but it seems better to do that separately as a later exercise.
For now, the translated rules will be kept reasonably close to the original
ones.  The original rule for postfix expressions is:</p>

<pre class="c11">postfix-expression =
    primary-expression |
    postfix-expression `[` expression `]` |
    postfix-expression `(` argument-expression-list? `)` |
    postfix-expression `.` identifier |
    postfix-expression `->` identifier |
    postfix-expression `++` |
    postfix-expression `--` |
    `(` type-name `)` `{` initializer-list `}` |
    `(` type-name `)` `{` initializer-list `,` `}`

argument-expression-list =
    assignment-expression |
    argument-expression-list `,` assignment-expression
</pre>

<p>There is a problem here because the first alternative can be a bracketed
expression which begins <code>`(`</code>, and the last two alternatives also
begin with <code>`(`</code>. An expression and a type name begin with different
tokens but, when bracketed, they require a two-token lookahead to distinguish
them.  The approach taken here is to replace <code>`(` type-name `)`</code> with
<code>cast</code>, define a rule for <code>cast</code> which includes a suitable
lookahead, and make sure that the cast alternative comes before the one
involving a bracketed expression. The cast rule is:</p>

<pre>cast =
    (`(` (type-specifier / type-qualifier) )&amp; `(` type-name `)`
</pre>

<p>The postfix expression rule can now be transformed by removing the left
recursion, putting the last two alternatives first and combining them, adding a
rule for the alternatives that can follow a primary expression, and noting that
the initializer list rule must be defined so that it doesn't accept a final
comma, the translated rules become:</p>

<pre class="pecan">postfix-expression =
    cast `{` initializer-list `,`? `}` /
    primary-expression pe-suffix*

pe-suffix =
    `[` expression `]` /
    `(` argument-expression-list? `)` /
    `.` identifier /
    `->` identifier /
    `++` /
    `--`

argument-expression-list =
    assignment-expression (`,` assignment-expression)*
</pre>

<p>The next layer up in the hierarchy is unary expressions:</p>

<pre class="c11">unary-expression  =
    postfix-expression |
    `++` unary-expression |
    `--` unary-expression |
    unary-operator cast-expression |
    `sizeof` unary-expression |
    `sizeof` `(` type-name `)` |
    `alignof` `(` type-name `)`

unary-operator:
    `&amp;` | `*` | `+` | `-` | `~` | `!`
</pre>

<pre class="pecan">unary-expression  =
    postfix-expression /
    `++` unary-expression /
    `--` unary-expression /
    unary-operator cast-expression /
    `sizeof` (unary-expression / `(` type-name `)`) /
    `alignof` `(` type-name `)`

unary-operator:
    `&amp;` | `*` | `+` | `-` | `~` | `!`
</pre>

</body>
</html>
