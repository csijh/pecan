<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial: C</title>
<style>
  pre, .indent { margin-left: 40px; }
  pre, code { color: #00a; }
</style>
</head>
<body>

<img src="../pecan.png" width="300" height="65" />
<hr/>

<h1>Pecan Case study: C11</h1>

<p>The development of a scanner and parser for C11 presented here is based on
the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf">C11
standard</a>. It is simply a literal translation of the official C11 grammar
into the Pecan notation.  It does not take into account common extensions or
other variations to the C11 language, or differing interpretations of the
standard, nor does it attempt to deal with all of the practical issues that
arise in real C compilers.  It has also only been lightly tested - it is not
intended to be a compiler-grade parser.</p>

<p>The rules from the C11 standard are presented with a few obvious cosmetic
changes to the notation for compatibilty with Pecan.  Terminal symbols in bold
such as <b><code>int</code></b> are quoted <code>"int"</code> instead.
Definitions <code>x: y</code> have the colon replaced by an equal sign to give
<code>x = y</code>, the optional suffix <code>x<sub>opt</sub></code> is replaced
by a question mark <code>x?</code>, and choices which are implicit from the
layout have explicit choice operators <code>|</code> added.  Rules are
effectively presented in a mythical language which is Pecan with an extra
<code>|</code> operator having CFG semantics. The aim is to apply
transformations until the alternatives of any <code>|</code> operator can
clearly be distinguished by the PEG operator <code>/</code> instead, so that the
<code>|</code> operator can be eliminated.</p>

<p>The development described here amounts to translating the C11 syntax into a
near-recursive-descent form, which has been done before, perhaps most notably in
the clang compiler.</p>

<h2>Scanner</h2>

<p>The complete Pecan scanner for C11, and a small collection of tests, are in
the file:</p>

<p class="indent"><a href="c-scan.txt">c-scan.txt</a></p>

<p>The scanner is based on the lexical grammar which is gathered together in
appendix A.1 of the standard.  It is assumed that the implementation-defined
source character set consists of the visible Unicode characters. It is assumed
that the character encoding is UTF-8, and that conversion of all newlines to
<code>\n</code>, translation of trigraphs, splicing of lines which end in
<code>\</code> and preprocessing have already been done.  Scanning does not then
involve any changes to the source text.  The initial rule of the scanner is:</p>

<pre>tokens = @tokens token* Uc!
</pre>

<p>To ensure that the scanner produces a single output, there is an initial
action <code>@tokens</code> which produces an empty list of tokens. Thereafter,
as each token is recognized, an action adds the token to the list. The end of
file is recognized using <code>Uc!</code>. The original rule for a token from
the standard is:</p>

<pre>token = keyword | identifier | constant | string-literal | punctuator
</pre>

<p>In order to take a uniform approach to scanning, white space and comments,
described elsewhere in the standard, are included, so that all of the text is
processed.  Also, the order is changed to recognise string literals and
constants before keywords or identifiers, because of the possibility of a letter
<code>L</code> prefix at the start of a string literal or character constant.
Keywords are recognized before identifiers, to keep the definition of
identifiers simple, as in the original grammar.  So the translated rule is:</p>

<pre>token =
    gap / comment / constant / string-literal /
    keyword / identifier / punctuator
</pre>

<p>White space and comments can be recognized as tokens, and then discarded,
like this:</p>

<pre>gap = (' ' / newline / tab / vtab / formfeed)+ @

comment =
    "//" (newline! visible)* @ /
    "/*" ("*/"! visible)* "*/" @
</pre>

<p>Leaving constants until later, string literals are described in the original
grammar by:</p>

<pre>string-literal = encoding-prefix? '"' s-char-sequence? '"'

encoding-prefix = "u8" | "u" | "U" | "L"
</pre>

<p>This can be translated into:</p>

<pre>string-literal =
    '"' s-char-sequence? '"' @1string /
    [encoding-prefix '"'] s-char-sequence? '"' @1string

encoding-prefix = "u8" / "u" / "U" / "L"
</pre>

<p>The try construct <code>[encoding-prefix '"']</code> ensures that a prefix
such as <code>u8</code> on its own does not match. The characters inside a
string literal are described in the original grammar by:</p>

<pre>s-char-sequence =
    s-char |
    s-char-sequence s-char
</pre>

<p>Many of the original grammar rules use left recursion in this simple way to
express repetition.  Such rules can usually be translated in a routine way using
repetition operators like this:</p>

<pre>s-char-sequence = s-char+
</pre>

<p>In C, as in many languages, a word like <code>int</code> is not recognized as
a keyword if it is followed by more letters or digits, e.g. <code>intx</code> is
a single identifier, not the keyword <code>int</code> followed by
<code>x</code>. This fact is not entirely clear from the original grammar, which
has a local ambiguity at this point.  Although it can be argued according to CFG
semantics that such ambiguities get resolved at a more global level, it is much
clearer to resolve them locally.  Many such ambiguities, including this one, can
be resolved using a greedy convention, sometimes called maximal munch, where it
is assumed that the longest alternative is the one intended. To deal with this
explicitly in the rule for keywords, lookahead is used:</p>

<pre>keyword =
    ["alignof" more!] @1alignof /
    ["auto" more!] @1auto /
    ["break" more!] @1break /
    ...
    ["_Thread_local" more!] @1ThreadLocal
</pre>

<p>Identifiers exclude the keywords, and include type names introduced using
<code>typedef</code>, and enumeration constants, which can't be distinguished in
the scanner.  Those are recognized during parsing.  Using Unicode letters in
place of "other implementation-defined characters", the translated rules for
identifiers are:</p>

<pre>identifier = identifier-nondigit more* @1id
identifier-nondigit = nondigit / universal-character-name / other
more = identifier-nondigit / digit
nondigit = '_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
digit = '0123456789'
universal-character-name = "\u" hex-quad / "\U" hex-quad hex-quad
hex-quad =
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
hexadecimal-digit = '0123456789abcdefABCDEF'
other = Lu / Ll / Lt / Lm / Lo
</pre>

<p>Punctuators are easier to recognize than keywords, because it doesn't matter
what they are followed by. However, they have to be ordered so that if one is a
prefix of another, the longer one is recognized preferentially, according to the
greedy convention.  Perhaps the easiest way to be sure of that is to list them
in length order.</p>

<pre>punctuator =
    "%:%:" @1hshs /
    "&lt;&lt;=" @1ltlteq /
    ">>=" @1gtgteq /
    "..." @1dtdtdt /
    "->" @1migt /
    ...
    "#" @1hs
</pre>

<p>Constants are described in the original grammar by:</p>

<pre>constant =
    integer-constant | floating-constant |
    enumeration-constant | character-constant
</pre>

<p>Enumeration constants can't be distinguished from identifiers in the scanner,
so they need to be removed from this rule and dealt with in the parser.
Character constants can have a prefix before the <code>"'"</code>, and can be
recognised in a similar way to string literals. It is convenient to deal with
them as the first alternative to get them out of the way.  Numerical constants
cause a problem, because both integer and floating constants can start with
digits.  It is possible to translate directly into a Pecan grammar rule by using
lookahead to try one alternative and then the other:</p>

<pre>constant =
    character-constant / [integer-constant] / floating-constant
</pre>

<p>It is tempting to try to improve on this by using a transformation approach
to find an equivalent form where no lookahead is needed.  However, this turns
out to be impossible. That's because, for example, <code>08</code> is
technically two tokens because <code>8</code> is not an octal digit, whereas
<code>08.</code> is a single floating constant.  Detection of non-octal digits
in octal constants could be left until a later semantic pass, but perhaps a
better approach is to find a cheap lookahead which looks for the first
non-digit.</p>

<pre>constant =
    character-constant / is-float! integer-constant / floating-constant

is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')
</pre>

<p>The original rule for <code>integer-constant</code> is:</p>

<pre>integer-constant =
    decimal-constant integer-suffix? |
    octal-constant integer-suffix? |
    hexadecimal-constant integer-suffix?
</pre>

<p>This is another place in the C11 grammar where there is a local ambiguity. If
the source text contains <code>0x1</code> then this could match
<code>hexadecimal-constant</code>, or the first <code>0</code> on its own could
match <code>octal-constant</code>.  The greedy convention suggests that the
hexadecimal case should be checked first:</p>

<pre>integer-constant =
    hexadecimal-constant integer-suffix? @1hex /
    octal-constant integer-suffix? @1octal /
    decimal-constant integer-suffix? @1decimal
</pre>

<p>One of the alternatives for a floating constant is a decimal floating
constant, with this original rule:</p>

<pre>decimal-floating-constant:
    fractional-constant exponent-part? floating-suffix? |
    digit-sequence exponent-part floating-suffix?
</pre>

<p>The alternatives have possible initial digits in common, so this needs some
work.  The original rule for <code>fractional-constant</code> is:</p>

<pre>fractional-constant =
    digit-sequence? '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>This is typical of many rules where there is a common left factor which is
reasonably easy to tranform away using routine transformations.  The first
alternative can be expanded into two alternatives, according to whether the
optional <code>digit-sequence</code> is absent or present:</p>

<pre>fractional-constant =
    '.' digit-sequence |
    digit-sequence '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>Then the last two alternatives can be combined, and the choice operator
changed:</p>

<pre>fractional-constant =
    '.' digit-sequence /
    digit-sequence '.' digit-sequence?
</pre>

<p>This can now be substituted into the <code>decimal-floating-constant</code>
rule, and similar transformations applied to the result, to give:</p>

<pre>decimal-floating-constant:
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?
</pre>

<p>The same approach can be taken to the remaining original rules.</p>

<p>Although the translation has involved some work, it has had the effect of
exposing and resolving some issues.</p>

<h2>Parser: external definitions</h2>

<hr/>
<p><b>Not yet updated from C99</b></p>
<hr/>

<p>Infamously, parsing of C requires type names introduced using
<code>typedef</code> to be differentiated from other identifiers.  This cannot
be done during scanning.  Instead, token tags are altered during parsing, which
must include symbol table construction.</p>

<p>With a few obvious cosmetic changes to the notation for compatibilty with
Pecan, the CFG-based grammar in the C11 standard (A.2.4) begins with:</p>

<pre>translation-unit =
    external-declaration | translation-unit external-declaration
</pre>

<p>Removing the left recursion, and adding end-of-file detection, this can be
translated into:</p>

<pre>translation-unit = external-declaration+ ``
</pre>

<p>The original grammar continues with:</p>

<pre>external-declaration = function-definition | declaration
</pre>

<p>The two alternatives are disjoint, because the grammar is unambiguous, but it
isn't immediately clear how to distinguish them. If it is just assumed that
there is no ambiguous overlap, then there is a direct translation into a Pecan
grammar rule by using lookahead to try one alternative and then the other:</p>

<pre>external-declaration = [function-definition] / declaration
</pre>

<p>However, since replacing the body of a function definition by a semicolon
yields a declaration, it is clear that the two alternatives share a lot in
common, to the point where it is worth merging them.  A fairly straightforward
transformation approach can be used to reach an equivalent form with no
lookahead needed. The relevant rules from the original grammar needed during the
transformation, with left recursion removed, are:</p>

<pre>function-definition =
    declaration-specifiers declarator declaration-list? compound-statement

declaration =
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration

init-declarator-list = init-declarator (`,` init-declarator)*

init-declarator = declarator (`=` initializer)?
</pre>

<p>This allows us to transform the rule for external declarations by expanding
<code>function-definition</code> and <code>declaration</code> to give:</p>

<pre>external-declaration =
    declaration-specifiers declarator declaration-list? compound-statement |
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration
</pre>

<p>The <code>static_assert-declaration</code> clause can be ut first because it
begins with a distinctive keyword, and the common left factor
<code>declaration-specifiers</code> can be taken out, to yield:</p>

<pre>external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        init-declarator-list? `;`
    )
</pre>

<p>Expanding <code>init-declarator-list</code> gives:</p>

<pre>external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (init-declarator (`,` init-declarator)*)? `;`
    )
</pre>

<p>Expanding the first <code>init-declarator</code> gives:</p>

<pre>external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (declarator (`=` initializer)? (`,` init-declarator)*)? `;`
    )
</pre>

<p>In order to get at the common left factor <code>declarator</code>, the second
alternative, which has the form <code>(x)? `;`</code>, can be replaced by
<code>x `;` / `;`</code> to give:</p>

<pre>external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        declarator (`=` initializer)? (`,` init-declarator)* `;` |
        `;`
    )
</pre>

<p>Taking out the left factor <code>declarator</code> from the first two
alternatives gives:</p>

<pre>external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator (
            declaration-list? compound-statement |
            (`=` initializer)? (`,` init-declarator)* `;`
        ) |
        `;`
    )
</pre>

<p>Looking at the two innermost alternatives, the second can clearly only start
with a token <code>`=`</code> or <code>`,`</code> or
<code>`;`</code>.  It is easy to check that the first alternative
cannot start with any of these, so no lookahead is necessary any more.</p>

<p>Converting to Pecan notation, adding some actions, and rearranging a bit,
gives:</p>

<pre>external-declaration =
    static_assert-declaration @1declaration /
    declaration-specifiers (
        `;` @1declaration /
        declarator (
            (`=` initializer)? (`,` init-declarator)* `;` @1declaration /
            declaration-list? compound-statement @1definition
        )
    )
</pre>

<p>A first prototype of the grammar, just demonstrating the handling of
definitions and declarations, is:</p>

<p class="indent"><a href="c-parse-a.txt">c-parse-a.txt</a></p>

<p>The next stage is to deal with declarations</p>

<h2>Parser: declarations</h2>

<p>Most of the problems faced in parsing declarations are fairly easy.  For
example, the original grammar rule from the C11 standard (A.2.2) for a struct or
union specifier is:</p>

<pre>struct-or-union-specifier =
    struct-or-union identifier? `{` struct-declaration-list `}` |
    struct-or-union identifier
</pre>

<p>Rearranging to remove the common left factors gives:</p>

<pre>struct-or-union-specifier = struct-or-union (
    identifier (`{` struct-declaration-list `}`)? /
    `{` struct-declaration-list `}`
)
</pre>

<p>The original grammar rules for enumeration specifiers are:</p>

<pre>enum-specifier =
    `enum` identifier? `{` enumerator-list `}`
    `enum` identifier? `{` enumerator-list `,` `}`
    `enum` identifier

enumerator-list = enumerator (`,` enumerator)
</pre>

<p>Perhaps the most obvious way to translate the first definition is:</p>

<pre>enum-specifier = `enum` (
    identifier (`{` enumerator-list `,`? `}`)? /
    `{` enumerator-list `,`? `}`
)
</pre>

<p>However, having a final optional comma means that care is needed to prevent
it from being matched in the second rule:</p>

<pre>enumerator-list = enumerator ((`,` `}`)! `,` enumerator)*
</pre>

<p>The original rule for <code>direct-declarator</code> is:</p>

<pre>direct-declarator:
    identifier |
    `(` declarator `)` |
    direct-declarator `[` type-qualifier-list? assignment-expression? `]` |
    direct-declarator `[` static type-qualifier-list? assignment-expression `]` |
    direct-declarator `[` type-qualifier-list static assignment-expression `]` |
    direct-declarator `[` type-qualifier-list? `*` `]` |
    direct-declarator `(` parameter-type-list `)` |
    direct-declarator `(` identifier-list? `)` |
</pre>

<p>Removing the left recursion and combining the contents of each kind of
bracket yields:</p>

<pre>direct-declarator = (identifier / `(` declarator `)`) (
    `[` (
        type-qualifier-list (`static`? assignment-expression / `*`?) /
        assignment-expression /
        `static` type-qualifier-list? assignment-expression /
        `*`?
    ) `]` /
    `(` (identifier&amp; identifier-list)? / parameter-type-list `)`
)*
</pre>

<p>Similarly, the original rule for <code>direct-abstract-declarator</code> can
be translated into:</p>

<pre>direct-abstract-declarator = `(` abstract-declarator `)` (
    `[` (
        type-qualifier-list (`static`? assignment-expression)? /
        assignment-expression /
        `static` type-qualifier-list? assignment-expression /
        `*`?
    ) `]` /
    `(` parameter-type-list? `)`
)*
</pre>

<p>The original rule for <code>parameter-declaration</code> is:</p>

<pre>parameter-declaration =
    declaration-specifiers declarator |
    declaration-specifiers abstract-declarator?
</pre>

<p>Taking out the common left factor, this becomes:</p>

<pre>parameter-declaration = declaration-specifiers (
    declarator |
    abstract-declarator?
)
</pre>

<p>The approach taken earlier to combine alternatives by transformation to find
their common prefixes doesn't work here, because recursion intervenes before the
issue is resolved.  So, it is better to use lookahead.  However, it is worth
finding a 'cheap' lookahead, not involving actions or complexities.  The main
difference between the alternatives is that <code>declarator</code> includes an
identifier.  Checking the possibilities, only <code>`*`</code> or
<code>type-qualifier</code> or <code>`(`</code> tokens can occur before the
identifier. On the other hand, in an <code>abstract-declarator</code>, a close
bracket must appear before the end.  This leads to:</p>

<pre>parameter-declaration = declaration-specifiers (
    ((`*` / type-qualifier / `(`)* `identifier`)&amp; declarator /
    abstract-declarator?
)
</pre>

<p><b><i>discussion incomplete</i></b>  Files which illustrate some further
steps are:</p>

<p class="indent"><a href="c11-b.txt">c11-b.txt</a><br/>
<a href="c11-c.txt">c11-c.txt</a></p>


<!--
<pre>
    direct-declarator = (identifier / `(` declarator `)`) dd*
    dd = `[` dd1 `]` / `(` dd2 `)`
    dd1 =
        type-qualifier-list (`static`? assignment-expression / `*`?) /
        assignment-expression /
        `static` type-qualifier-list? assignment-expression /
        `*`?
    dd2 = (identifier&amp; identifier-list)? / parameter-type-list

    direct-abstract-declarator = `(` abstract-declarator `)` dad*
    dad = `[` dad1 `]` / `(` dad2 `)`
    dad1 =
        type-qualifier-list (`static`? assignment-expression)? /
        assignment-expression /
        `static` type-qualifier-list? assignment-expression /
        `*`?
    dad2 = parameter-type-list?
</pre>
-->

</body>
</html>
