<!DOCTYPE html>
<!-- Free and open source, see licence.txt. -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial: C</title>
<style>
    body { font-size: 120%; }
    pre, .indent { margin-left: 40px; }
    pre.c11, code.c11 { color: #00a; }
    pre.pecan, code.pecan { color: #060; }
</style>
</head>
<body>

<img src="../pecan.png" width="300" height="65" />
<hr/>

<h1>The C parser</h1>

<p>The parser is defined separately, with tokens from the scanner as its input.
First, the relationship between the scanner and parser is established by
defining the tokens to be used in the parser in terms of the token tags produced
by the scanner. Then the rules are presented in stages, in the order given in
appendix A of the C11 standard.</p>

<h2>Tokens</h2>

<p>The rules for tokens are gathered into a separate file, forming a grammar
fragment to be included in later grammar files:</p>

<p class="indent"><a href="c-tokens.txt">c-tokens.txt</a></p>

<p>Definitions are introduced to recognize individual tokens, and establish
error markers. These are intended to make the rest of the grammar more readable
by making it more closely resemble the original C11 grammar. First there are
definitions which deal with types of token with variable spellings:</p>

<pre class="pecan">enumeration-constant = identifier
identifier = #atom %identifier @identifier
constant = #atom %constant @constant
string-literal = #atom %string-literal @string-literal
typedef-name = #atom %typedef-name @typedef-name
</pre>

<p>The rule for <code>enumeration-constant</code> has been taken from the
original lexical rules. The <code class="pecan">identifier</code> rule is
typical. It sets up an error marker, matches a token with tag <code
class="pecan">identifier</code> and converts it into an output item. There is a
group of rules for keywords:</p>

<pre class="pecan">`alignof` = %alignof
`auto` = #type %auto
...
`_Thread_local` = %_Thread_local
</pre>

<p>Explicit keyword spellings such as <code class="c11">"alignof"</code> from
the original grammar are translated into literal identifiers such as <code
class="pecan">`alignof`</code> in the Pecan grammar. Keywords which have to do
with types are marked with the <code class="pecan">#type</code> marker. Also,
keywords which continue a construct rather than start a new one are given error
markers. There is a group of definitions for punctuators:</p>

<pre class="pecan">`%:%:` = #op %`%:%:`
`<<=` = #op %`<<=`
...
`#` = %`#`
</pre>

<p>Again, explicit spellings such as <code class=c11>"%:%:"</code> are
translated using literal names such as <code class="pecan">`%:%:`</code>, and
various error markers are included.</p>

<h2>Expressions</h2>

<p>Expressions are covered in section A.2.1 of the C11 standard. Separate files
are used to define and test C expressions independently, before the remainder of
the grammar is developed:</p>

<p class="indent"><a href="c-expressions.txt">c-expressions.txt</a><br/>
<a href="c-expressions-test.txt">c-expressions-test.txt</a></p>

<p>The file <code>c-expressions.txt</code> is a grammar fragment which includes
<code>c-tokens.txt</code> and which will itself be included in later grammar
files. The test file contains:</p>

<pre class="pecan">start = expression &lt;>
type-name = %type-name @type-name
initializer-list = %initializer-list @initializer-list
{c-expressions.txt}
</pre>

<p>This adds three rules to the ones in <code>c-expressions.txt</code>. The
first rule establishes the <code class="pecan">expression</code> rule as the
entry point, and makes sure that it matches the whole of the input in each test.
The other two rules cope with forward references from expressions to later parts
of the C grammar. The two rules mentioned are temporarily defined as tokens,
to make expressions self-contained for testing.</p>

<p>The input to the parser is an array of tokens produced by the scanner. The
tag of a token is defined by the action used in the scanner to create it. It is
assumed, however, that a tag <code class="pecan">identifier</code> is changed
to <code class="pecan">typedef-name</code> where appropriate by the parser's
external code, in response to actions taken when parsing typedefs.</p>

<p>Precedence and associativity are dealt with in the original grammar by
defining hierarchically layered rules for expressions. The transformation into
Pecan follows the same style, and is reasonably straightforward. The original
rule for primary expressions is:</p>

<pre class="c11">primary-expression =
    identifier /
    constant /
    string-literal /
    `(` expression `)` /
    generic-selection
</pre>

<p>There are no translation problems, since each alternative starts with a
different type of token:</p>

<pre class="pecan">primary-expression =
    identifier /
    constant /
    string-literal /
    `(`expression `)` /
    generic-selection
</pre>

<p>Generic selections also cause no translation problems:</p>

<pre class="pecan">generic-selection =
    `_Generic` `(` (assignment-expression `,` generic-assoc-list `)` @2generic)

generic-assoc-list = generic-association (generic-association @2pair)*

generic-association =
    type-name `:` assignment-expression @2assoc /
    `default` @nothing `:` assignment-expression @2assoc
</pre>

<p>Actions can be thought of as creating parse tree node, where the type of the
node is given by the name of the action. The <code class="pecan">@2pair</code>
action is a general purpose one for building lists and other compound
structures. It is used often in this development whereas, in a practical
project, more informative node types would be needed.</p>

<p>The original rule for postfix expressions is:</p>

<pre class="c11">postfix-expression =
    primary-expression |
    postfix-expression '[' expression ']' |
    postfix-expression '(' argument-expression-list? ')' |
    postfix-expression '.' identifier |
    postfix-expression '->' identifier |
    postfix-expression '++' |
    postfix-expression '--' |
    '(' type-name ')' '{' initializer-list '}' |
    '(' type-name ')' '{' initializer-list ',' '}'
</pre>

<p>There is a problem here because the first alternative can be a bracketed
expression which begins with <code>'('</code>, and the last two alternatives
also begin with <code>'('</code>. An expression and a type name begin with
different tokens but, when bracketed, they require a two-token lookahead to
distinguish them.</p>

<p>In addition, the last two alternatives, which describe compound literals,
will cause an overlap later in the grammar with cast expressions, which also
begin with a bracketed type name.</p>

<p>Rather than stray too far from the structure of the original rules, a try
expression is used to check for the open curly bracket:</p>

<pre class="pecan">[`(` type-name `)` `{`]
</pre>

<p>Now the left recursion can be removed from the postfix expression rule, and
the last two alternatives can be merged and put at the beginning:</p>

<pre class="pecan">postfix-expression =
    [`(` type-name `)` `{`] initializer-list `,`? `}` @2compound /
    primary-expression (
        `[` expression `]` @2index /
        `(` (argument-expression-list / @nothing) `)` @2apply /
        `.` identifier @2field /
        `->` identifier @2arrow /
        `++` @1postInc /
        `--` @1postDec
    )*
</pre>

<p>The rule for an initializer list will later need to be defined to exclude the
optional final comma shown here. The rule for an argument expression list is
easy to translate. The next layer up in the expression hierarchy is unary
expressions, with original rule:</p>

<pre class="c11">unary-expression  =
    postfix-expression |
    '++' unary-expression |
    '--' unary-expression |
    unary-operator cast-expression |
    'sizeof' unary-expression |
    'sizeof' '(' type-name ')' |
    'alignof' '(' type-name ')'
</pre>

<p>The two alternatives starting with <code class="c11">sizeof</code> overlap,
because a <code class="c11">unary-expression</code> can be bracketed. To resolve
this, the two alternatives can be reversed and a try expression applied:</p>

<pre class="pecan">unary-expression  =
    postfix-expression /
    `++` unary-expression @1preInc /
    `--` unary-expression @1preDec /
    unary-operator cast-expression @2preOp /
    [`sizeof` `(` type-name `)`] @1sizeofType /
    `sizeof` unary-expression @1sizeofVar /
    `alignof` `(` type-name `)` @1align
</pre>

<p>The rule for a unary operator is easy to translate. The next layer up is cast
expressions, with original rule:</p>

<pre class="c11">cast-expression =
    unary-expression |
    "(" type-name ")" cast-expression
</pre>

<p>The first alternative overlaps with the second, because it can start with a
bracket. And the second alternative overlaps with compound literals. The
alternatives can be swapped, and a lookahead used to check for a type-name but
no curly bracket:</p>

<pre class="pecan">cast-expression =
    [`(` type-name `)` `{`!] cast-expression @2cast /
    unary-expression
</pre>

<p>The next level up in the expression hierarchy is multiplicative
expressions, defined by the original rule:</p>

<pre class="c11">multiplicative-expression =
    cast-expression |
    multiplicative-expression "*" cast-expression |
    multiplicative-expression "/" cast-expression |
    multiplicative-expression "%" cast-expression
</pre>

<p>This can be transformed in a straightforward way to:</p>

<pre class="pecan">multiplicative-expression =
    cast-expression (
        `*` cast-expression @2multiply /
        `/` cast-expression @2divide /
        `%` cast-expression @2remainder
    )*
</pre>

<p>The same approach can be taken to additive expressions, shift expressions,
relational expressions, equality expressions, AND expressions, exclusive OR
expressions, inclusive OR expressions, logical AND expressions, and logical OR
expressions. These all define the precedences of infix operators in the same
way.</p>

<p>The original rule for conditional expressions is:</p>

<pre class="c11">conditional-expression =
    logical-OR-expression |
    logical-OR-expression "?" expression ":" conditional-expression
</pre>

<p>This defines the ternary operator. It easy to handle by combining the
prefixes and making the suffix optional:</p>

<pre class="pecan">conditional-expression =
    logical-OR-expression (`?` expression `:` conditional-expression @3ifExp)?
</pre>

<p>The original rule for assignment expressions is:</p>

<pre class="c11">assignment-expression =
    conditional-expression |
    unary-expression assignment-operator assignment-expression
</pre>

<p>This uses right recursion rather than left recursion, to capture the right
associativity of the assignment operators. The right recursion can remain in the
translation. However, there is a problematic overlap between the two
alternatives. Perhaps the simplest approach is to swap the alternatives and use
lookahead to match the assignment operator before accepting the new first
alternative:</p>

<pre class="pecan">assignment-expression =
    [unary-expression assignment-operator] assignment-expression @3assign /
    conditional-expression
</pre>

<p>In a production compiler, to avoid the potentially expensive lookahead, it
might be better to parse the left hand side of an assignment as a conditional
expression instead of a unary expression, and then check the restriction to
unary expression after parsing.</p>

<p>The rule for an assignment operator is easy to translate. At the top of the
expression hierarchy is the expression rule:</p>

<pre class="c11">expression =
    assignment-expression |
    expression "," assignment-expression
</pre>

<p>This poses no problems, beyond the usual removal of left recursion:</p>

<pre class="pecan">expression =
    assignment-expression (`,` assignment-expression @2comma)*
</pre>

<p>The expression section of the C11 grammar has one more rule in it. It is
just a synonym which makes some of the later rules more readable. There is no
harm in including it in the Pecan translation:</p>

<pre class="pecan">constant-expression = conditional-expression
</pre>

<h2>Declarations</h2>

<p>These files are used to define and test C declarations:</p>

<p class="indent"><a href="c-declarations.txt">c-declarations.txt</a><br/>
<a href="c-declarations-test.txt">c-declarations-test.txt</a></p>

<p>The original rule for declarations is:</p>

<pre class="c11">declaration =
    declaration-specifiers init-declarator-list? ";" |
    static_assert-declaration
</pre>

<p>This can be translated directly as:</p>

<pre class="pecan">declaration =
    declaration-specifiers (init-declarator-list @2declaration)? `;` /
    static_assert-declaration
</pre>

<p>The original rule for declaration specifiers is:</p>

<pre class="c11">declaration-specifiers =
    storage-class-specifier declaration-specifiers? |
    type-specifier declaration-specifiers? |
    type-qualifier declaration-specifiers? |
    function-specifier declaration-specifiers? |
    alignment-specifier declaration-specifiers?
</pre>

<p>In the translation, it seems cleaner to define a single declaration specifier
separately:</p>

<pre class="pecan">declaration-specifier =
    storage-class-specifier /
    type-specifier /
    type-qualifier /
    function-specifier /
    alignment-specifier
</pre>

<p>Then the definition for a sequence of them can include an action to combine
them:</p>

<pre class="pecan">declaration-specifiers =
    declaration-specifier (declaration-specifier @2declaration-specifiers)*
</pre>

<p>The rules for <code class="pecan">init-declarator-list</code>, <code
class="pecan">init-declarator</code>, <code
class="pecan">storage-class-specifier</code>, and <code
class="pecan">type-specifier</code> are simple. The original rules for a struct
or union specifier are:</p>

<pre class="c11">struct-or-union-specifier =
    struct-or-union identifier? `{` struct-declaration-list `}` |
    struct-or-union identifier

struct-or-union = "struct" | "union"
</pre>

<p>Expanding the first alternative of the first rule, then rearranging to remove
the common left factors gives:</p>

<pre class="c11">struct-or-union-specifier = struct-or-union (
    identifier (`{` struct-declaration-list `}`)? /
    `{` struct-declaration-list `}`
)

struct-or-union = `struct` / `union`
</pre>

<p>However, to add actions, it seems preferable to organize the rules
differently, recognizing the main keywords first:</p>

<pre class="pecan">struct-or-union-specifier =
    `struct` struct-or-union-body @2struct /
    `union` struct-or-union-body @2union

struct-or-union-body =
    identifier (`{` struct-declaration-list `}` / @nothing) /
    @nothing `{` struct-declaration-list `}`
</pre>

<p>The rules for <code class="pecan">struct-declaration-list</code>, <code
class="pecan">struct-declaration</code>, <code
class="pecan">specifier-qualifier-list</code>, <code
class="pecan">struct-declarator-list</code> and <code
class="pecan">struct-declarator</code> are easy to handle.</p>

<p>The original grammar rules for enumeration specifiers are:</p>

<pre class="c11">enum-specifier =
    `enum` identifier? "{" enumerator-list "}" |
    `enum` identifier? "{" enumerator-list "," "}" |
    `enum` identifier

enumerator-list = enumerator | enumerator-list "," enumerator
</pre>

<p>Perhaps the most obvious way to translate the first definition, expanding,
rearranging and combining left factors as before, is:</p>

<pre class="pecan">enum-specifier = `enum` (
    identifier (`{` enumerator-list `,`? `}` / @nothing) @2enum /
    @nothing `{` enumerator-list `,`? `}` @2enum
)
</pre>

<p>However, the fact that there is an optional final comma before the close
curly bracket causes a problem. It means that care is needed to prevent it from
being matched in the second rule:</p>

<pre class="pecan">enumerator-list = enumerator ((`,` `}`)! `,` enumerator @2pair)*
</pre>

<p>The <code class="pecan">enumerator</code>, <code
class="pecan">atomic-type-specifier</code>, <code
class="pecan">type-qualifier</code>, <code
class="pecan">function-specifier</code>, <code
class="pecan">alignment-specifier</code>, and <code
class="pecan">declarator</code> rules are straightforward. The original rule for
<code>direct-declarator</code> is:</p>

<pre class="c11">direct-declarator:
    identifier |
    `(` declarator `)` |
    direct-declarator `[` type-qualifier-list? assignment-expression? `]` |
    direct-declarator `[` `static` type-qualifier-list? assignment-expression `]` |
    direct-declarator `[` type-qualifier-list `static` assignment-expression `]` |
    direct-declarator `[` type-qualifier-list? `*` `]` |
    direct-declarator `(` parameter-type-list `)` |
    direct-declarator `(` identifier-list? `)` |
</pre>

<p>Removing the left recursion, combining the contents of each kind of bracket,
disambiguating alternatives <code>parameter-type-list</code> and
<code>identifier-list</code> by reversing the alternatives and using lookahead
to check for the first identifier, inventing extra rules for clarity, and
tidying up, yields:</p>

<pre class="pecan">direct-declarator =
    (identifier / `(` declarator `)`) dd-bracket*

dd-bracket =
    `(` (dd-parameters / @nothing) `)` @2function /
    `[` (dd-array-size / @nothing) `]` @2array

dd-parameters =
    identifier& identifier-list / parameter-type-list

dd-array-size =
    `*` @star /
    `static` type-qualifiers assignment-expression @2pair @1staticSize /
    type-qualifier-list (dd-simple-array-size / @nothing) @2typeSize /
    assignment-expression @1size

dd-simple-array-size =
    `*` @star /
    `static` assignment-expression @1staticSize1 /
    assignment-expression @1size

type-qualifiers = type-qualifier-list / @nothing
</pre>

<p>The rules for <code class="pecan">pointer</code>, <code
class="pecan">type-qualifier-list</code>, <code
class="pecan">parameter-type-list</code>, and <code
class="pecan">parameter-list</code> are simple. The original rule for
<code>parameter-declaration</code> is:</p>

<pre class="c11">parameter-declaration =
    declaration-specifiers declarator |
    declaration-specifiers abstract-declarator?
</pre>

<p>Taking out the common left factor, this becomes:</p>

<pre class="c11">parameter-declaration = declaration-specifiers (
    declarator |
    abstract-declarator?
)
</pre>

<p>The two alternatives overlap. The approach of combining alternatives by
transformation to find their common prefixes doesn't work here, because
recursion intervenes before the issue is resolved. So, it is better to use
lookahead. However, it is worth finding a 'cheap' lookahead. The main difference
between the alternatives is that <code>declarator</code> includes an identifier.
Checking the possibilities, only <code>`*`</code> or <code>type-qualifier</code>
or <code>`(`</code> tokens can occur before the identifier. On the other hand,
in an <code>abstract-declarator</code>, a close bracket must appear before the
end. This leads to:</p>

<pre class="pecan">parameter-declaration = declaration-specifiers (
    has-identifier declarator @2declarator /
    (abstract-declarator @2abstract)?
)

has-identifier =
    ((`*` / type-qualifier / `(`)* `identifier`) &amp;
</pre>

<p>The <code class="pecan">identifier-list</code>, <code
class="pecan">type-name</code>, and <code
class="pecan">abstract-declarator</code> rules are simple. The original rule for
<code>direct-abstract-declarator</code> is:</p>

<pre class="c11">direct-abstract-declarator =
    `(` abstract-declarator `)` |
    direct-abstract-declarator? `[` type-qualifier-list? assignment-expression? `]` |
    direct-abstract-declarator? `[` `static` type-qualifier-list? assignment-expression `]` |
    direct-abstract-declarator? `[` type-qualifier-list `static` assignment-expression `]` |
    direct-abstract-declarator? `[` `*` `]` |
    direct-abstract-declarator? `(` parameter-type-list? `)`
</pre>

<p>This defines a sequence of clauses which have round or square brackets. There
is an overlap between the first and last alternatives, but it is a minor one
because an abstract declarator begins with a <code>*</code> or a bracket,
whereas a parameter type list begins with a keyword. That means the left
recursion can be removed from the rule, with a cheap lookahead:</p>

<pre class="pecan">direct-abstract-declarator =
    has-declarator `(` abstract-declarator `)` (dad-bracket @2dad)* /
    dad-bracket (dad-bracket @2dad)*

has-declarator = (`(` (`*` / `(` / `[`)) &amp;
</pre>

<p>The <code class="pecan">dad-bracket</code> rule can handle the overlap of the
square-bracket clauses simply by lifting out their contents into a separate
rule:</p>

<pre class="pecan">dad-bracket =
    `(` parameter-type-list / @nothing `)` @1parameters /
    `[` dad-array-size / @nothing `]` @1arraySize
</pre>

<p>Then <code class="pecan">dad-array-size</code> and <code
class="pecan">dad-simple-array-size</code> are easy:</p>

<pre class="pecan">dad-array-size =
    `*` @star /
    `static` type-qualifiers assignment-expression @2pair @1staticSize /
    type-qualifier-list (dad-simple-array-size / @nothing) @2pair /
    assignment-expression

dad-simple-array-size =
    assignment-expression / `static` assignment-expression @1staticSize
</pre>

<p>There is an original rule:</p>

<pre class="c11">typedef-name = identifier
</pre>

<p>This needs to be removed, because the external code associated with the
parser will distinguish between typedef names and identifiers by giving them
different tags.</p>

<p>The final rules for declarations are <code class="pecan">initializer</code>,
<code class="pecan">initializer-list</code>, <code
class="pecan">designation</code>, <code class="pecan">designator-list</code>,
<code class="pecan">designator</code>, and <code
class="pecan">static_assert-declaration</code>, are all straightforward.</p>

<h2>Statements</h2>

<p>The file of rules, and the file of tests, for statements are:</p>

<p class="indent"><a href="c-statements.txt">c-statements.txt</a><br/>
<a href="c-statements-test.txt">c-statements-test.txt</a></p>

<hr/>
<p><b>Development incomplete</b></p>
<hr/>

<h2>External definitions</h2>

<p>The remainder of the C11 grammar covering the parser rules will be tackled in
sections. A first prototype of the grammar, just demonstrating the handling of
external definitions in section A.2.4 of the standard, is:</p>

<p class="indent"><a href="c-parse-a.txt">c-parse-a.txt</a></p>

<p>With a few obvious cosmetic changes to the notation for compatibility with
Pecan, the CFG-based grammar begins with:</p>

<pre class="c11">translation-unit =
    external-declaration | translation-unit external-declaration
</pre>

<p>Removing the left recursion, adding an action to initialize an empty list of
external declarations, and adding end-of-file detection, this can be translated
into:</p>

<pre class="pecan">translation-unit = @0list external-declaration+ ``
</pre>

<p>The original grammar continues with:</p>

<pre class="c11">external-declaration = function-definition | declaration
</pre>

<p>The two alternatives are disjoint, because the grammar is unambiguous, but it
isn't immediately clear how to distinguish them. If it is just assumed that
there is no ambiguous overlap, then there is a direct translation into a Pecan
grammar rule by using lookahead to try one alternative and then the other:</p>

<pre class="c11">external-declaration = [function-definition] / declaration
</pre>

<p>However, since replacing the body of a function definition by a semicolon
yields a declaration, it is clear that the two alternatives share a lot in
common, to the point where it is worth merging them. A fairly straightforward
transformation approach can be used to reach an equivalent form with no
lookahead needed. The relevant rules from the original grammar needed during the
transformation, with left recursion removed, are:</p>

<pre class="c11">function-definition =
    declaration-specifiers declarator declaration-list? compound-statement

declaration =
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration

init-declarator-list = init-declarator (`,` init-declarator)*

init-declarator = declarator (`=` initializer)?
</pre>

<p>This allows us to transform the rule for external declarations by expanding
<code>function-definition</code> and <code>declaration</code> to give:</p>

<pre class="c11">external-declaration =
    declaration-specifiers declarator declaration-list? compound-statement |
    declaration-specifiers init-declarator-list? `;` |
    static_assert-declaration
</pre>

<p>The <code>static_assert-declaration</code> clause can be put first because it
begins with a distinctive keyword, and the common left factor
<code>declaration-specifiers</code> can be taken out, to yield:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        init-declarator-list? `;`
    )
</pre>

<p>Expanding <code>init-declarator-list</code> gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (init-declarator (`,` init-declarator)*)? `;`
    )
</pre>

<p>Expanding the first <code>init-declarator</code> gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        (declarator (`=` initializer)? (`,` init-declarator)*)? `;`
    )
</pre>

<p>In order to get at the common left factor <code>declarator</code>, the second
alternative, which has the form <code>(x)? `;`</code>, can be replaced by
<code>x `;` / `;`</code> to give:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator declaration-list? compound-statement |
        declarator (`=` initializer)? (`,` init-declarator)* `;` |
        `;`
    )
</pre>

<p>Taking out the left factor <code>declarator</code> from the first two
alternatives gives:</p>

<pre class="c11">external-declaration =
    static_assert-declaration /
    declaration-specifiers (
        declarator (
            declaration-list? compound-statement |
            (`=` initializer)? (`,` init-declarator)* `;`
        ) |
        `;`
    )
</pre>

<p>Looking at the two innermost alternatives, the second can clearly only start
with a token <code>`=`</code> or <code>`,`</code> or
<code>`;`</code>. It is easy to check that the first alternative
cannot start with any of these, so no lookahead is necessary any more.</p>

<p>Converting to Pecan notation, adding some actions, and rearranging a bit,
gives:</p>

<pre class="pecan">external-declaration =
    static_assert-declaration @1declaration /
    declaration-specifiers (
        `;` @1declaration /
        declarator (
            (`=` initializer)? (`,` init-declarator)* `;` @1declaration /
            declaration-list? compound-statement @1definition
        )
    )
</pre>

<p>It is worth pointing out that, since <code class="pecan">declarator</code>
includes function declarators, this grammar does not preclude a declaration of
the form <code>int f() = 3;</code>. A brief investigation of actual C compilers
suggests that this error is normally detected after, rather than during,
parsing.</p>

<p>The next stage is to deal with declarations</p>

<h2>Statements</h2>

<p>A third prototype, adding statement rules from A.2.3 of the standard, is</p>

<p class="indent"><a href="c-parse-c.txt">c-parse-c.txt</a></p>

<p>The original main rule for statements is:</p>

<pre class="c11">
statement =
    labeled-statement |
    compound-statement |
    expression-statement |
    selection-statement |
    iteration-statement |
    jump-statement
</pre>

<p>Most statements begin with a distinctive keyword. A simple check reveals that
the only overlap of first tokens is that <code>labeled-statement</code> and
<code>expression-statement</code> can both start with an identifier. However,
only in the <code>labeled-statement</code> case is it immediately followed by a
colon. Thus the above rule can be translated trivially, and
<code>labeled-statement</code> can be given a simple two-token lookahead:</p>

<pre class="pecan">
statement =
    labeled-statement /
    compound-statement /
    expression-statement /
    selection-statement /
    iteration-statement /
    jump-statement

labeled-statement =
    [identifier `:`] statement /
    `case` constant-expression `:` statement /
    DEFAULT `:` statement
</pre>

<p>The original rule for a compound statement is easily transformed directly
into:</p>

<pre class="pecan">compound-statement = `{` block-item* `}`
</pre>

<p>The original rule for a block item is:</p>

<pre class="c11">block-item = declaration | statement
</pre>

<p>The only overlap between the first tokens of the two alternatives is that a
declaration may start with an identifier which is a typedef name, and a
statement may begin with an identifier. Typedef names need to be recognised
separately. That is done by adding an action to the grammar at the point where
a typedef name is declared, as well as actions which keep track of scopes. The
action causes the externally linked code to record the new typedef name in a
symbol table. Thereafter, within the scope of the typedef name, tokens matching
the typedef name are presented to the parser with a different token type. In
addition, it is necessary to <em>remove</em> the rule from the grammar for
typedef names:</p>

<pre class="c11">typedef-name = identifier
</pre>

<p>It can be replaced by a rule which indicated that it is a token type:</p>

<pre class="pecan">typedef-name = `typedef-name`
</pre>

<p>With this understanding, the rule for block items can be accepted as it
is:</p>

<pre class="pecan">block-item = declaration / statement
</pre>

<p>The rule for expression statements is unproblematic:</p>

<pre class="pecan">expression-statement = expression? `;`
</pre>

<p>With selection statements, the original rule is:</p>

<pre class="c11">selection-statement =
    IF `(` expression `)` statement |
    IF `(` expression `)` statement ELSE statement |
    `switch` `(` expression `)` statement
</pre>

<p>This suffers from the infamous <a
href="https://en.wikipedia.org/wiki/Dangling_else">dangling else</a> ambiguity.
There is a well-known technique for resolving the ambiguity by having separate
rules for open and closed statements. That technique only applies to CFG
grammars, and doesn't directly help in transforming into Pecan (except perhaps
to clarify the meaning of the original grammar). However, the problem simply
goes away, if the obvious Pecan rule is written down. By the very nature of the
'greedy' <code>/</code> operator, an <code>else</code> clause will naturally be
attached to the closest <code>if</code> statement.</p>

<pre class="pecan">selection-statement =
    IF `(` expression `)` statement (ELSE statement)? /
    `switch` `(` expression `)` statement
</pre>

<p>The rule for iteration statements starts out as:</p>

<pre class="c11">iteration-statement =
    `while` `(` expression `)` statement |
    DO statement `while` `(` expression `)` `;` |
    FOR `(` expression? `;` expression? `;` expression? `)` statement |
    FOR `(` declaration expression? `;` expression? `)` statement
</pre>

<p>The only problem is with the last pair of alternatives concerning
<code>for</code> statements. The last alternatives look slightly odd, as if it
lacks a semicolon. That's because a declaration includes its terminating
semicolon. Given the treatment of typedef names already described, declarations
and expressions are easily distinguished by their first tokens, so the rule can
be transformed to:</p>

<pre class="pecan">iteration-statement =
    `while` `(` expression `)` statement /
    DO statement `while` `(` expression `)` `;` /
    FOR `(` for-start expression? `;` expression? `)` statement

for-start = declaration / expression? `;`
</pre>

<p>The rule for jump statements can be transformed directly into:</p>

<pre class="pecan">jump-statement =
    GOTO identifier `;` /
    `continue` `;` /
    `break` `;` /
    RETURN expression? `;`
</pre>

</body>
</html>
