<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial: C</title>
<style>
  pre, .indent { margin-left: 40px; }
  pre, code { color: #00a; }
  pre.pecan, code.pecan { color: #060; }
</style>
</head>
<body>

<img src="../pecan.png" width="300" height="65" />
<hr/>

<h1>Pecan Case study: C99</h1>

<p>The development of a scanner and parser for C99 presented here is based on
the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">C99
standard</a>. It demonstrates the use of Pecan and, in particular, the use of
(manual) transformation as a way of developing parsers.</p>

<p>The result is simply a literal translation of the official C99 grammar into
the Pecan notation.  It does not take into account common extensions or other
variations to the C99 language, or differing interpretations of the standard,
nor does it attempt to deal with all of the practical issues that arise in real
C compilers.  It has also only been lightly tested - it is not intended to be a
compiler-grade parser.</p>

<p>The rules from the C99 standard are presented with a few obvious cosmetic
changes to the notation for compatibility with Pecan.  Definitions <code>x:
y</code> have the colon replaced by an equal sign to give <code>x = y</code>,
the optional suffix <code>x<sub>opt</sub></code> is replaced by a question mark
<code>x?</code>, and choices which are implicit from the layout have explicit
choice operators <code>|</code> added.  Rules are effectively presented in a
mythical language which is Pecan with an extra <code>|</code> operator having
CFG semantics. The aim is to apply transformations until the alternatives of any
<code>|</code> operator can clearly be distinguished by the PEG operator
<code>/</code> instead, so that the <code>|</code> operator can be
eliminated.</p>

<p>Rules taken from the standard, or needing more transformation work, are
displayed in <code>blue</code>, whereas final Pecan rules are displayed in <code
class="pecan">green</code>.</p>

<p>The development described here amounts to translating the C99 syntax into a
near-recursive-descent form, which has been done before, perhaps most notably in
the clang compiler.</p>

<h2>Scanner</h2>

<p>The complete Pecan scanner for C99, and a small collection of tests, are in
the file:</p>

<p class="indent"><a href="c99-scan.txt">c99-scan.txt</a></p>

<p>The scanner is based on the lexical grammar which is gathered together in
appendix A.1 of the standard.  It is assumed that the implementation-defined
source character set consists of the visible unicode characters. It is assumed
that preprocessing, conversion of all newlines to <code>\n</code>, translation
of trigraphs, and splicing of lines which end in <code>\</code>, have already
been done.  Scanning does not then involve any changes to the source text.  The
initial rule of the scanner is:</p>

<pre class="pecan">tokens = @tokens token* Uc!
</pre>

<p>To ensure that the scanner produces a single output, there is an initial
action <code class="pecan">@tokens</code> which produces an empty list of
tokens. Thereafter, as each token is recognized, an action adds the token to the
list. The end of file is recognized using <code class="pecan">Uc!</code>. The
original rule for a token from the standard is:</p>

<pre>token = keyword | identifier | constant | string-literal | punctuator
</pre>

<p>In order to take a uniform approach to scanning, white space and comments,
described elsewhere in the standard, are included, so that all of the text is
processed.  Also, the order is changed to recognise string literals and
constants before keywords or identifiers, because of the possibility of a letter
<code>L</code> prefix at the start of a string literal or character constant.
Keywords are recognized before identifiers, to keep the definition of
identifiers simple, as in the original grammar.  So the translated rule is:</p>

<pre class="pecan">token =
    gap / comment / constant / string-literal /
    keyword / identifier / punctuator
</pre>

<p>White space and comments can be recognized as tokens, and then discarded,
like this:</p>

<pre class="pecan">gap = (' ' / newline / tab / vtab / formfeed)+ @

comment =
    "//" (newline! visible)* @ /
    "/*" ("*/"! visible)* "*/" @
</pre>

<p>Leaving constants until later, string literals are described in the original
grammar by:</p>

<pre>string-literal =
    '"' s-char-sequence? '"' |
    'L' '"' s-char-sequence? '"'
</pre>

<p>This can be translated into:</p>

<pre class="pecan">string-literal =
    '"' s-char-sequence? '"' @1string /
    ['L' '"'] s-char-sequence? '"' @1string
</pre>

<p>There is no facility in Pecan to include a double quote <code
class="pecan">"</code> in a string.  That is to avoid the ugly complexities of
escape mechanisms. Instead, the characters <code class="pecan">L"</code> have to
be separated, so that the double quote can be described using single quotes. The
two characters then need to be surrounded by a try construct <code
class="pecan">[...]</code> to ensure that an <code class="pecan">L</code> on its
own does not match. The characters inside a string literal are described in the
original grammar by:</p>

<pre>s-char-sequence =
    s-char |
    s-char-sequence s-char
</pre>

<p>Many of the original grammar rules use left recursion in this simple way to
express repetition.  Such rules can usually be translated in a routine way using
repetition operators like this:</p>

<pre class="pecan">s-char-sequence = s-char+
</pre>

<p>In C, as in many languages, a word like <code>int</code> is not recognized as
a keyword if it is followed by more letters or digits, e.g. <code>intx</code> is
a single identifier, not the keyword <code>int</code> followed by
<code>x</code>. This fact is not entirely clear from the original grammar, which
has a local ambiguity at this point.  Although it can be argued according to CFG
semantics that such ambiguities get resolved at a more global level, it is much
clearer to resolve them locally.  Many such ambiguities, including this one, can
be resolved using a greedy convention, sometimes called maximal munch, where it
is assumed that the longest alternative is the one intended. To deal with this
explicitly in the rule for keywords, lookahead is used:</p>

<pre class="pecan">keyword =
    ["auto" more!] @1auto /
    ["break" more!] @1break /
    ...
    ["_Imaginary" more!] @1Imaginary
</pre>

<p>Punctuators are easier to recognize than keywords, because it doesn't matter
what they are followed by. However, they have to be ordered so that if one is a
prefix of another, the longer one is recognized preferentially, according to the
greedy convention.  Perhaps the easiest way to be sure of that is to list them
in length order.</p>

<pre class="pecan">punctuator =
    "%:%:" @1hshs /
    "&lt;&lt;=" @1ltlteq /
    ">>=" @1gtgteq /
    "..." @1dtdtdt /
    "->" @1migt /
    ...
    "#" @1hs
</pre>

<p>Identifiers include type names introduced using <code>typedef</code>, and
enumeration constants, which can't be distinguished in the scanner.  They are
recognized during parsing.  The rules for identifiers are:</p>

<pre class="pecan">identifier = identifier-nondigit more* @1id
identifier-nondigit = nondigit / universal-character-name
more = identifier-nondigit / digit
nondigit = '_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
digit = '0123456789'
universal-character-name = "\u" hex-quad / "\U" hex-quad hex-quad
hex-quad =
    hexadecimal-digit hexadecimal-digit hexadecimal-digit hexadecimal-digit
hexadecimal-digit = '0123456789abcdefABCDEF'
</pre>

<p>Constants are described in the original grammar by:</p>

<pre>constant =
    integer-constant | floating-constant |
    enumeration-constant | character-constant
</pre>

<p>Enumeration constants can't be distinguished from identifiers in the scanner,
so they need to be removed from this rule and dealt with in the parser.
Character constants start with <code>"'"</code> or <code>"L'"</code>, and can be
recognised in a similar way to string literals. It is convenient to deal with
them as the first alternative to get them out of the way.  Numerical constants
cause a problem, because both integer and floating constants can start with
digits.  It is possible to translate directly into a Pecan grammar rule by using
lookahead to try one alternative and then the other:</p>

<pre>constant =
    character-constant / [integer-constant] / floating-constant
</pre>

<p>It is tempting to try to improve on this by using a transformation approach
to find an equivalent form where no lookahead is needed.  However, this turns
out to be impossible. That's because, for example, <code>08</code> is
technically two tokens because <code>8</code> is not an octal digit, whereas
<code>08.</code> is a single floating constant.  That means, after accepting the
<code>0</code>, lookahead is needed at least as far as the dot before knowing
whether the token has ended.  Detection of non-octal digits in octal constants
could be left until a later semantic pass, but perhaps a better approach is to
find a cheap lookahead which looks for the first non-digit.</p>

<pre class="pecan">constant =
    character-constant / is-float! integer-constant / floating-constant

is-float = "0x" ('.' / hexadecimal-digit+ '.pP') / ('.' / digit+ '.eE')
</pre>

<p>The original rule for <code>integer-constant</code> is:</p>

<pre>integer-constant =
    decimal-constant integer-suffix? |
    octal-constant integer-suffix? |
    hexadecimal-constant integer-suffix?
</pre>

<p>This is another place in the C99 grammar where there is a local ambiguity. If
the source text contains <code>0x1</code> then this could match
<code>hexadecimal-constant</code>, or the first <code>0</code> on its own could
match <code>octal-constant</code>.  The greedy convention suggests that the
hexadecimal case should be checked first:</p>

<pre class="pecan">integer-constant =
    hexadecimal-constant integer-suffix? @1hex /
    octal-constant integer-suffix? @1octal /
    decimal-constant integer-suffix? @1decimal
</pre>

<p>One of the alternatives for a decimal constant is a decimal floating
constant, with this original rule:</p>

<pre>decimal-floating-constant:
    fractional-constant exponent-part? floating-suffix? |
    digit-sequence exponent-part floating-suffix?
</pre>

<p>The alternatives have possible initial digits in common, so this needs some
work.  The original rule for <code>fractional-constant</code> is:</p>

<pre>fractional-constant =
    digit-sequence? '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>This is typical of many rules where there is a common left factor which is
reasonably easy to tranform away using routine transformations.  The first
alternative can be expanded into two alternatives, according to whether the
optional <code>digit-sequence</code> is absent or present:</p>

<pre>fractional-constant =
    '.' digit-sequence |
    digit-sequence '.' digit-sequence |
    digit-sequence '.'
</pre>

<p>Then the last two alternatives can be combined, and the choice operator
changed:</p>

<pre>fractional-constant =
    '.' digit-sequence /
    digit-sequence '.' digit-sequence?
</pre>

<p>This can now be substituted into the <code>decimal-floating-constant</code>
rule, and similar transformations applied to the result, to give:</p>

<pre class="pecan">decimal-floating-constant:
    '.' digit-sequence exponent-part? floating-suffix? /
    digit-sequence ('.' digit-sequence?)? exponent-part? floating-suffix?
</pre>

<p>The same approach can be taken to the remaining original rules.</p>

<p>Although this translation of the C99 lexical rules has involved some work, it
has had the effect of exposing and resolving some issues.</p>

<h2>Parser: external definitions</h2>

<p>A first prototype of the grammar, just demonstrating the handling of
definitions and declarations as described in this section, is:</p>

<p class="indent"><a href="c99-a.txt">c99-a.txt</a></p>

<p>Infamously, parsing of C requires type names introduced using
<code>typedef</code> to be differentiated from other identifiers.  This cannot
be done during scanning.  Instead, token tags are altered during parsing, which
must include symbol table construction.</p>

<p>With a few obvious cosmetic changes to the notation for compatibilty with
Pecan, the CFG-based grammar in the C99 standard (A.2.4) begins with:</p>

<pre>translation-unit =
    external-declaration | translation-unit external-declaration
</pre>

<p>Removing the left recursion, adding an action to initialize an empty list of
external declarations, and adding end-of-file detection, this can be translated
into:</p>

<pre class="pecan">translation-unit = @0list external-declaration+ ``
</pre>

<p>The original grammar continues with:</p>

<pre>external-declaration = function-definition | declaration
</pre>

<p>The two alternatives are disjoint, because the grammar is unambiguous, but it
isn't immediately clear how to distinguish them. If it is just assumed that
there is no ambiguous overlap, then there is a direct translation into a Pecan
grammar rule by using lookahead to try one alternative and then the other:</p>

<pre>external-declaration = [function-definition] / declaration
</pre>

<p>However, since replacing the body of a function definition by a semicolon
yields a declaration, it is clear that the two alternatives share a lot in
common, to the point where it is worth merging them.  A fairly straightforward
transformation approach can be used to reach an equivalent form with no
lookahead needed. The relevant rules from the original grammar needed during the
transformation, with left recursion removed, are:</p>

<pre>function-definition =
    declaration-specifiers declarator declaration-list? compound-statement

declaration = declaration-specifiers init-declarator-list? `;`

init-declarator-list = init-declarator (`,` init-declarator)*

init-declarator = declarator (`=` initializer)?
</pre>

<p>This allows us to transform the rule for external declarations by expanding
<code>function-definition</code> and <code>declaration</code> to give:</p>

<pre>external-declaration =
    declaration-specifiers declarator declaration-list? compound-statement |
    declaration-specifiers init-declarator-list? `;`
</pre>

<p>The common left factor <code>declaration-specifiers</code> can be
taken out, to yield:</p>

<pre>external-declaration = declaration-specifiers (
    declarator declaration-list? compound-statement |
    init-declarator-list? `;`
)
</pre>

<p>Expanding <code>init-declarator-list</code> gives:</p>

<pre>external-declaration = declaration-specifiers (
    declarator declaration-list? compound-statement |
    (init-declarator (`,` init-declarator)*)? `;`
)
</pre>

<p>Expanding the first <code>init-declarator</code> gives:</p>

<pre>external-declaration = declaration-specifiers (
    declarator declaration-list? compound-statement |
    (declarator (`=` initializer)? (`,` init-declarator)*)? `;`
)
</pre>

<p>In order to get at the common left factor <code>declarator</code>, the second
alternative, which has the form <code>(x)? `;`</code>, can be replaced by
<code>x `;` / `;`</code> to give:</p>

<pre>external-declaration = declaration-specifiers (
    declarator declaration-list? compound-statement |
    declarator (`=` initializer)? (`,` init-declarator)* `;` |
    `;`
)
</pre>

<p>Taking out the left factor <code>declarator</code> from the first two
alternatives gives:</p>

<pre>external-declaration = declaration-specifiers (
    declarator (
        declaration-list? compound-statement |
        (`=` initializer)? (`,` init-declarator)* `;`
    ) |
    `;`
)
</pre>

<p>Looking at the two innermost alternatives, the second can clearly only start
with a token <code>`=`</code> or <code>`,`</code> or
<code>`;`</code>.  It is easy to check that the first alternative
cannot start with any of these, so no lookahead is necessary any more.</p>

<p>Converting to Pecan notation, adding some actions, and rearranging a bit,
gives:</p>

<pre class="pecan">external-declaration = declaration-specifiers (
    `;` @1declaration /
    declarator (
        (`=` initializer)? (`,` init-declarator)* `;` @1declaration /
        declaration-list? compound-statement @1definition
    )
)
</pre>

<p>The next stage is to deal with declarations</p>

<h2>Parser: declarations</h2>

<p>Most of the problems faced in parsing declarations are fairly easy.  For
example, the original grammar rule from the C99 standard (A.2.2) for a struct or
union specifier is:</p>

<pre>struct-or-union-specifier =
    struct-or-union identifier? `{` struct-declaration-list `}` |
    struct-or-union identifier
</pre>

<p>Rearranging to remove the common left factors gives:</p>

<pre class="pecan">struct-or-union-specifier = struct-or-union (
    identifier (`{` struct-declaration-list `}`)? /
    `{` struct-declaration-list `}`
)
</pre>

<p>The original grammar rules for enumeration specifiers are:</p>

<pre>enum-specifier =
    `enum` identifier? `{` enumerator-list `}`
    `enum` identifier? `{` enumerator-list `,` `}`
    `enum` identifier

enumerator-list = enumerator (`,` enumerator)
</pre>

<p>Perhaps the most obvious way to translate the first definition is:</p>

<pre class="pecan">enum-specifier = `enum` (
    identifier (`{` enumerator-list `,`? `}`)? /
    `{` enumerator-list `,`? `}`
)
</pre>

<p>However, having a final optional comma means that care is needed to prevent
it from being matched in the second rule:</p>

<pre class="pecan">enumerator-list = enumerator ((`,` `}`)! `,` enumerator)*
</pre>

<p>The original rule for <code>direct-declarator</code> is:</p>

<pre>direct-declarator:
    identifier |
    `(` declarator `)` |
    direct-declarator `[` type-qualifier-list? assignment-expression? `]` |
    direct-declarator `[` static type-qualifier-list? assignment-expression `]` |
    direct-declarator `[` type-qualifier-list static assignment-expression `]` |
    direct-declarator `[` type-qualifier-list? `*` `]` |
    direct-declarator `(` parameter-type-list `)` |
    direct-declarator `(` identifier-list? `)` |
</pre>

<p>Removing the left recursion and combining the contents of each kind of
bracket yields:</p>

<pre class="pecan">direct-declarator = (identifier / `(` declarator `)`) (
    `[` (
        type-qualifier-list (`static`? assignment-expression / `*`?) /
        assignment-expression /
        `static` type-qualifier-list? assignment-expression /
        `*`?
    ) `]` /
    `(` (identifier&amp; identifier-list)? / parameter-type-list `)`
)*
</pre>

<p>Similarly, the original rule for <code>direct-abstract-declarator</code> can
be translated into:</p>

<pre class="pecan">direct-abstract-declarator = `(` abstract-declarator `)` (
    `[` (
        type-qualifier-list (`static`? assignment-expression)? /
        assignment-expression /
        `static` type-qualifier-list? assignment-expression /
        `*`?
    ) `]` /
    `(` parameter-type-list? `)`
)*
</pre>

<p>The original rule for <code>parameter-declaration</code> is:</p>

<pre>parameter-declaration =
    declaration-specifiers declarator |
    declaration-specifiers abstract-declarator?
</pre>

<p>Taking out the common left factor, this becomes:</p>

<pre>parameter-declaration = declaration-specifiers (
    declarator |
    abstract-declarator?
)
</pre>

<p>The approach taken earlier to combine alternatives by transformation to find
their common prefixes doesn't work here, because recursion intervenes before the
issue is resolved.  So, it is better to use lookahead.  However, it is worth
finding a 'cheap' lookahead, not involving actions or complexities.  The main
difference between the alternatives is that <code>declarator</code> includes an
identifier.  Checking the possibilities, only <code>`*`</code> or
<code>type-qualifier</code> or <code>`(`</code> tokens can occur before the
identifier. On the other hand, in an <code>abstract-declarator</code>, a close
bracket must appear before the end.  This leads to:</p>

<pre class="pecan">parameter-declaration = declaration-specifiers (
    ((`*` / type-qualifier / `(`)* `identifier`)&amp; declarator /
    abstract-declarator?
)
</pre>

<p><b><i>discussion incomplete</i></b>  Files which illustrate some further
steps are:</p>

<p class="indent"><a href="c99-b.txt">c99-b.txt</a><br/>
<a href="c99-c.txt">c99-c.txt</a></p>


<!--
<pre>
    direct-declarator = (identifier / `(` declarator `)`) dd*
    dd = `[` dd1 `]` / `(` dd2 `)`
    dd1 =
        type-qualifier-list (`static`? assignment-expression / `*`?) /
        assignment-expression /
        `static` type-qualifier-list? assignment-expression /
        `*`?
    dd2 = (identifier&amp; identifier-list)? / parameter-type-list

    direct-abstract-declarator = `(` abstract-declarator `)` dad*
    dad = `[` dad1 `]` / `(` dad2 `)`
    dad1 =
        type-qualifier-list (`static`? assignment-expression)? /
        assignment-expression /
        `static` type-qualifier-list? assignment-expression /
        `*`?
    dad2 = parameter-type-list?
</pre>
-->

</body>
</html>
