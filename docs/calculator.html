<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial</title>
<style> pre { margin-left:40px; } </style>
</head>
<body>

<img src="pecan.png" width="300" height="65" />
<hr/>

<h1>Developing a Calculator</h1>

<p>Suppose we want to implement a calculator where the user can type in a sum
such as <kbd>6+3*(10+2)</kbd> and get the answer <samp>42</samp>. A calculator
like this consists mostly of a parser for arithmetic expressions. Although it
would be easy to write by hand, it illustrates how to use Pecan to develop a
parser in a step-by-step, test-driven fashion.</p>

<!--
<p>It is possible to write a parser by hand, using the recursive descent
technique for example, but it can be very fiddly. Using a generator such as
Pecan has several potential advantages:</p>

<ul>

<li>it can speed up development because the code is compact</li>

<li>it can reduce the errors caused by verbose code</li>

<li>it can provide more expressive power than simple recursive descent</li>

<li>it can increase robustness by making consistency checks</li>

</ul>

<p>Pecan provides a language for writing parsers. While having a lot in common
with other grammar languages, it is specifically designed to be as simple as
possible for programmers who only rarely write parsers or are not grammar
experts. It can be thought of as a specialist scripting language for writing
parsers. A Pecan script can be run interpretively as it stands, e.g. for
testing purposes, or it can be used to generate code for a parser in a specific
programming language.</p>

<p>Since grammars are compact, they contain a lot of compressed detail, so they
are not necessarily easy to develop. Pecan provides features to help with
development, and in particular it promotes a test-driven style. This tutorial
illustrates the style by developing a calculator.</p>
-->

<h3>Step 1</h3>

<p>To make a start, create a file <code>sum.txt</code> containing:</p>

<pre>digit = '0..9' @number
</pre>

<p>This can be thought of as a prototype parser. It specifies a parsing function
called <code>digit</code> which recognises a single digit and then uses an
action <code>@number</code> to evaluate it. An expression such as
<code>'0'</code> in a definition matches a specific character in the input, and
<code>'0..9'</code> represents any character in the given range. An action such
as <code>@number</code> represents an operation to be applied to the text
matched so far.</p>

<p>An action such as <code>@number</code> can be thought of as representing an
external function call in the final parser which will be written or generated
when the prototype is complete. The function will generate an output item of
some kind. In this case, we are thinking of output items as numerical, but in
some other application such as a compiler, output items could be syntax
trees.</p>

<p>The prototype parser doesn't make external calls, but it can be tested
symbolically as it stands. We can add a test to the end of the file
<code>sum.txt</code>, like this:</p>

<pre>digit = '0..9' @number
==========
2
----------
number 2
</pre>

<p>The test file is divided into two parts by a line of equal signs. The first
part is a grammar to be used for subsequent tests. The second part is a test,
divided by a line of minus signs into the input and the expected output.  The
output produced represents the external calls which would be made by the final
parser, in this case a call to a function <code>number</code> with an argument
which represents the substring <code>"2"</code> of the input text.</p>

<p>In this case, the grammar is directly embedded in the test file. An
alternative is to have a separate grammar file, and to use the path to the
grammar file in place of the grammar in the test file.</p>

<p>If we don't know exactly what output we are expecting, we can put in a guess
and correct it later. Then we can run the test like this:</p>

<pre>pecan sum.txt
Pass 1 test.
</pre>

<p>It is assumed here that <code>pecan</code> is an alias for whatever command
has to be typed to run the pecan program, perhaps:</p>

<pre>java -jar pecan.jar sum.txt
Pass 1 test.
</pre>

<p>So far, so good.</p>

<h3>Step 2</h3>

<p>To extend the parser to handle multi-digit numbers, edit the parser at the
top of <code>sum.txt</code> to read:</p>

<pre>number = ('0..9')+ @number
</pre>

<p>The parsing rule and the action function now have the same name, but
there is no harm in that. The postfix operator <code>+</code> means that the
parser should try to match something one or more times. In this case, a number
consists of one or more digits. To see if this works, add another test to the
file <code>sum.txt</code> so that it now contains:</p>

<pre>number = ('0..9')+ @number
==========
2
----------
number 2
==========
42
----------
number 42
</pre>

<p>Over time, the test file can contain various parser fragments or parser
versions and their tests, representing the entire history of development. For
the calculator, we are discarding previous versions of the parser, but keeping
all the tests to make sure they still work:</p>

<pre>pecan sum.txt
Pass 2 tests.
</pre>

<p>We are making progress.</p>

<h3>Step 3</h3>

<p>To extend the parser to handle two numbers added together such as
<code>2+40</code>, edit the parser at the top of <code>sum.txt</code> to
read:</p>

<pre>sum = number / number '+' number @2add
number = ('0..9')+ @number
</pre>

<p>The <code>/</code> operator means "or", so the parser should recognise
either a single number, or two numbers with a plus sign in between, in which
case a function <code>add</code> is to be called to evaluate the sum. The
<code>2</code> in <code>@2add</code> indicates that the <code>add</code>
function is to be applied to the two previously created output items, rather
than to text from the input. Add a third test to the file:</p>

<pre>sum = number / number '+' number @2add
number = ('0..9')+ @number
==========
2
----------
number 2
==========
42
----------
number 42
==========
2+40
----------
number 2
number 40
add
</pre>

<p>The final three lines describe the calls which we would expect to be made by
the generated code, i.e. two calls to <code>number</code> followed by a call
to <code>add</code>, using the results of the previous calls as arguments.
Running the tests gives:</p>

<pre>pecan sum.txt
Fail test on line 12 of sum.txt:
========== Expected ==========
number 2
number 40
add
========== Actual ==========
number 2
</pre>

<p>This is a good opportunity to demonstrate a couple of Pecan features:</p>

<pre>pecan -trace sum.txt 12
I1: |2+40
P1: number / number '+' number @2add
P1: number
P2: ('0..9')+ @number
P2: ('0..9')+
P2: '0..9'
I1: 2|+40
P2: '0..9'
P2: @number
O: number
Fail test on line 12 of sum.txt:
========== Expected ==========
number 2
number 40
add
========== Actual ==========
number 2
</pre>

<p>A numerical argument to the <code>pecan</code> program represents the line
number of a single test in the test file. This makes sure only one test is run.
The <code>-trace</code> (or <code>-t</code>) option switches on trace output.
Although verbose, this can sometimes be used to resolve difficult issues. Each
line in the trace starts with <code>I</code>, <code>P</code> or <code>O</code>.
A line starting with <code>I</code> reports a change in the input position,
giving an input line number and marking the position in that line with a
vertical bar. A line starting with <code>P</code> reports a change in the
current parse expression being executed, displaying a parser line number and the
expression. A line starting with <code>O</code> reports an output action.</p>

<p>The trace shows that the parser has a choice <code>number / number '+'
...</code>, and the first alternative succeeds, so the second alternative isn't
tried. The choice operator <code>/</code> is sequential, as in PEG grammars, not
symmetrical like the <code>|</code> operator in CFG grammars. Also, our parser
doesn't yet specify that parsing must reach the end of the input, so recognising
just the first number from the input gives a successful result.</p>

<h3>Step 4</h3>

<p>Maybe we can fix things by changing the order of choice. Change the rules
at the top of <kbd>sum.txt</kbd> to:</p>

<pre>sum = number '+' number @2add / number
number = ('0..9')+ @number
</pre>

<p>Now running the tests gives:</p>

<pre>pecan sum.txt
Fail test on line 1 of sum.txt:
========== Expected ==========
number 2
========== Actual ==========
Error on line 1:
2
 ^
</pre>

<p>We have broken the first test, which used to work. It is very common to break
old tests, which is why we are keeping all the tests and re-running them in
every development step.</p>

<p>The reason the first test now fails is that the parser has made a start on
the first alternative <code>number '+' number @2add</code>, and the initial
part, <code>number</code>, has succeeded. The parser is now committed to this
first alternative, which then fails because there is no plus sign. By default,
a parser is committed to an alternative as soon as any progress is made.</p>

<h3>Step 5</h3>

<p>It is possible to specify the point at which the parser is committed to the
first alternative:</p>

<pre>sum = [number '+'] number @2add / number
number = ('0..9')+ @number
</pre>

<p>The square brackets indicate that the parser should commit to the first
alternative after the plus sign is found. If there is no plus sign, the
parser should backtrack to the beginning and try the second alternative.</p>

<p>However, this may involve re-parsing the first number. To keep parsers
efficient, it is best to use backtracking very sparingly, so let's try
something else.</p>

<h3>Step 6</h3>

<p>A better approach for our calculator is to recognise the first number, and
then look to see whether or not there is a following plus sign:</p>

<pre>sum = number ('+' number @2add)?
number = ('0..9')+ @number
</pre>

<p>The postfix operator <code>?</code> means that something is
optional, so <code>x?</code> represents a choice between <code>x</code> or
nothing. Running our tests now gives:</p>

<pre>pecan sum.txt
The test on line 12 fails:
========== Expected ==========
number 2
number 40
add
========== Actual ==========
number 2
number +40
add
</pre>

<p>Well, at least the first test is working again. The final test is nearly
working, except for the plus sign on the front of the number 40. That's
because every character in the input must be handled by some action. An action
such as <code>number</code> is passed all the characters matched since the
previous action.</p>

<h3>Step 7</h3>

<p>Since we don't need the plus sign once it has been matched,
we can add an action which discards it:</p>

<pre>sum = number ('+' @ number @2add)?
number = ('0..9')+ @number
</pre>

<p>An <code>@</code> sign on its own is an action which discards all characters
matched since the previous action. Does this finally sort out our tests?</p>

<pre>pecan sum.txt
Pass 3 tests.
</pre>

<p>Yes, it does.</p>

<h3>Step 8</h3>

<p>At this point, it might be just as well to solve the problem of making sure
that all the input is used:</p>

<pre>sum = number ('+' @ number @2add)? end
number = ('0..9')+ @number
end = 13? 10 @
</pre>

<p>A number such as <code>13</code> is the decimal code for a character, in this
case the carriage return control character <code>CR</code> also known as
<code>\r</code> or <code>CTRL+M</code> or <code>0D</code> (hexadecimal), and
<code>10</code> stands for the line feed control character <code>LF</code> also
known as <code>\n</code> or <code>CTRL+J</code> or <code>0A</code>
(hexadecimal).</p>

<p>Pecan normalizes the line endings of the test file when it is read in, so
they are all <code>10</code>, but the <code>end</code> definition covers the two
most common line ending conventions, which would make the final parser work on
most common platforms, without normalizing the input.</p>

<p>The <code>@</code> action discards the end-of-line character or characters
after matching them. Another test can be added to our file to make sure that the
parser reports an error if the end of the input isn't reached.</p>

<pre>...
==========
2+40%
----------
Error on line 1:
2+40%
    ^
</pre>

<p>The test says that the parser should produce an error with a specific
message. If it does, the test succeeds:</p>

<pre>pecan sum.txt
Pass 4 tests.
</pre>

<p>The error message in the last test isn't very good, because it doesn't
provide a reason for the failure. That's because we haven't specified any error
reporting details yet. For now, it is enough to point to the place where the
failure occurs.</p>

<h3>Step 9</h3>

<p>Now let's deal with any sequence of numbers added together.</p>

<pre>sum = number ('+' @ number @2add)* end
number = ('0..9')+ @number
end = 13? 10 @
</pre>

<p>All we've done is to replace the <code>?</code> operator by the
<code>*</code> operator, which says that something is to be repeated any number
of times. Unlike the <code>+</code> operator, it specifies zero or more times,
rather than one or more times. We can add a test:</p>

<pre>...
==========
2+10+12+18
----------
number 2
number 10
add
number 12
add
number 18
add
</pre>

<p>Running the tests produces:</p>

<pre>pecan sum.txt
Pass 5 tests.
</pre>

<p>All is well.</p>

<h3>Step 10</h3>

<p>The next step is to allow subtraction as well as addition:</p>

<pre>sum = number ('+' @ number @2add / '-' @ number @2subtract)* end
number = ('0..9')+ @number
end = 13? 10 @
</pre>

<p>A number can be followed by any number of clauses. Each clause is either a
plus sign or a minus sign followed by another number. Add an extra test for
subtraction:</p>

<pre>...
==========
2-10+53-3
----------
number 2
number 10
subtract
number 53
add
number 3
subtract
</pre>

<p>Run the tests:</p>

<pre>pecan sum.txt
Pass 6 tests.
</pre>

<p>We are making good progress.</p>

<h3>Step 11</h3>

<p>At this point, let's do something about the uninformative error messages.
Here is the one in our current test file:</p>

<pre>2+40%
----------
Error on line 1:
2+40%
    ^
</pre>

<p>This accurately reports the position in the input at which parsing failed,
but doesn't give any clue about why. The conventional approach is to list the
things which would allow further parsing. If the list were generated
automatically by Pecan, it might read:</p>

<pre>2+40%
----------
Error on line 1: expecting '0','1','2','3','4','5','6','7','8','9','+','-',13,10
2+40%
    ^
</pre>

<p>Messages like this are too long and detailed to be very useful. We need to
form a summary. To do that, we can add error handlers to the parser:</p>

<pre>sum = number ('+' @ number @2add / '-' @ number @2subtract)* end
number = (#digit '0..9')+ @number
end = #newline 13? 10 @
</pre>

<p>If we run the Pecan program on our test file, we get this:</p>

<pre>java pecan.Run tests/sum11.txt
Fail test on line 19 of tests/sum11.txt:
========== Expected ==========
Error on line 1:
2+40%
    ^
========== Actual ==========
Error on line 1: expecting digit, newline
2+40%
    ^
</pre>

<p>When an error handler such as <code>#digit</code> is encountered, it is
attached as a marker to the current position in the input. If progress is made
beyond that position, the marker is removed. If parsing fails, the markers
associated with the current input position are reported. In the example here,
the <code>#digit</code> handler summarises the set of digits which are expected,
and the handler <code>#newline</code> summarises the line endings.</p>

<p>If the error message is changed in the test file to match what is actually
reported, the tests all pass. A further test can be added to cover the case
where there is no number after an operator:</p>

<pre>...
==========
2+
----------
Error on line 1: expecting digit
2+
  ^
</pre>

<p>Running the tests gives:</p>

<pre>pecan sum.txt
Pass 7 tests.
</pre>

<p>This is good, but we need a more uniform approach to error handling to make
sure it is accurate.</p>

<h3>Step 12</h3>

<p>The operators <code>+</code> and <code>-</code> are not being reported
because there is no handler for them. Although it is often reasonable to leave
out relatively unimportant items from the 'expected' list, the operators ought
to be reported in our case. For uniformity, let's make sure that whenever a
character is matched in the input, there is a marker associated with it. We can
rewrite the parser as:</p>

<pre>sum = number (plus number @2add / minus number @2subtract)* end
number = digit+ @number
plus = #operator '+' @
minus = #operator '-' @
digit = #digit '0..9'
end = #newline 13? 10 @
</pre>

<p>Each expression where a character is recognised has been pulled out into its
own definition, with an error handler included. This is a rather minor example
of the transformation approach to parser development. We started with a
parser:</p>

<pre>sum = ... '+' @ ...
</pre>

<p>Then we transformed it by pulling a subexpression out into its own
rule before developing further:</p>

<pre>sum = ... plus ...
plus = '+' @
</pre>

<p>There are many transformations like this which can be performed on a Pecan
parser which are guaranteed not to change its meaning. For any input, the output
actions performed or the error report produced are not changed.</p>

<p>Running the tests produces:</p>

<pre>Fail test on line 22 of tests/sum12.txt:
========== Expected ==========
Error on line 1: expecting digit, newline
2+40%
    ^
========== Actual ==========
Error on line 1: expecting digit, newline, operator
2+40%
    ^
</pre>

<p>This shows that operators are now being reported. If we upgrade the error
message in the test file, the tests pass. The error handler
<code>#operator</code> is encountered twice while parsing, once for each
operator, but is only reported once.</p>

<h3>Step 13</h3>

<p>It is time to add the other two operators:</p>

<pre>sum = term (plus term @2add / minus term @2subtract)* end
term = number (times number @2multiply / over number @2divide)*
number = digit+ @number
plus = #operator '+' @
minus = #operator '-' @
times = #operator '*' @
over = #operator '/' @
digit = #digit '0..9'
end = #newline 13? 10 @
</pre>

<p>Using the two separate rules <code>sum</code> and <code>term</code> means
that we have specified that multiplication and division take precedence over
addition and subtraction. We need to add at least one more test to make sure
this is working:</p>

<pre>...
==========
5*8+12/6
----------
number 5
number 8
multiply
number 12
number 6
divide
add
</pre>

<p>Running the tests gives:</p>

<pre>pecan sum.txt
Pass 8 tests.
</pre>

<p>Now all the operators are in place, it is time to tackle brackets.</p>

<h3>Step 14</h3>

<p>Let's add a rule <code>atom</code> to mean either a number or a bracketed
subexpression:</p>

<pre>sum = term (plus term @2add / minus term @2subtract)* end
term = atom (times atom @2multiply / over atom @2divide)*
atom = number / open sum close
number = digit+ @number
plus = #operator '+' @
minus = #operator '-' @
times = #operator '*' @
over = #operator '/' @
open = #bracket '(' @
close = #bracket ')' @
digit = #digit '0..9'
end = #newline 13? 10 @
</pre>

<p>Running the existing tests shows up a slight problem:</p>

<pre>Fail test on line 54 of tests/sum14.txt:
========== Expected ==========
Error on line 1: expecting digit
2+
  ^
========== Actual ==========
Error on line 1: expecting bracket, digit
2+
  ^
</pre>

<p>The error message in that test needs to be upgraded in the test file. Now we
can add a simple test for brackets:</p>

<pre>...
==========
2*(20+1)
----------
number 2
number 20
number 1
add
multiply
</pre>

<p>Running the tests gives:</p>

<pre>pecan sum.txt
Fail test on line 70 of tests/sum14.txt:
========== Expected ==========
number 2
number 20
number 1
add
multiply
========== Actual ==========
Error on line 1: expecting digit, newline, operator
2*(20+1)
       ^
</pre>

<p>The new test for brackets fails. That is because we are using
the <code>sum</code> rule both for the expression as a whole, where we expect
the end of the input to follow, and for the inner subexpression, where we
expect a closing bracket to follow. We need to separate out these two
cases.</p>

<h3>Step 15</h3>

<p>All we need to do is to add an extra rule <code>expression</code> which is
the same as <code>sum</code>, but without the end of input test:</p>

<pre>sum = expression end
expression = term (plus term @2add / minus term @2subtract)*
term = atom (times atom @2multiply / over atom @2divide)*
atom = number / open expression close
number = digit+ @number
plus = #operator '+' @
minus = #operator '-' @
times = #operator '*' @
over = #operator '/' @
open = #bracket '(' @
close = #bracket ')' @
digit = #digit '0..9'
end = #newline 13? 10 @
</pre>

<p>Let's run the tests again:</p>

<pre>pecan sum.txt
Pass 9 tests.
</pre>

<p>Let's do one more development step, to illustrate allowing spaces.</p>

<h3>Step 16</h3>

<p>Handling spaces is a little bit difficult, because we are scanning and
parsing in one go, rather than writing a separate scanner and parser. To avoid
complicating the parser any more than necessary, the best approach is to skip
spaces at the start and after recognising each token:</p>

<pre>sum = gap expression end
expression = term (plus term @2add / minus term @2subtract)*
term = atom (times atom @2multiply / over atom @2divide)*
atom = number / open expression close
number = digit+ @number gap
plus = #operator '+' gap
minus = #operator '-' gap
times = #operator '*' gap
over = #operator '/' gap
open = #bracket '(' gap
close = #bracket ')' gap
digit = #digit '0..9'
gap = (#space ' ')* @
end = #newline 13? 10 @
</pre>

<p>A test can be added:</p>

<pre>...
==========
 2 * ( 20 + 1 )
----------
number 2
number 20
number 1
add
multiply
</pre>

<p>Running the tests gives:</p>

<pre>Fail test on line 30 of tests/sum16.txt:
========== Expected ==========
Error on line 1: expecting digit, newline, operator
2+40%
    ^
========== Actual ==========
Error on line 1: expecting digit, newline, operator, space
2+40%
    ^
</pre>

<p>Rather than change the error messages to add space as an extra expected item,
let's decide that error messages will look cleaner if spaces are not reported,
since they are allowed almost anywhere. So, we will change the grammar to:</p>

<pre>sum = gap expression end
expression = term (plus term @2add / minus term @2subtract)*
term = atom (times atom @2multiply / over atom @2divide)*
atom = number / open expression close
number = digit+ @number gap
plus = #operator '+' gap
minus = #operator '-' gap
times = #operator '*' gap
over = #operator '/' gap
open = #bracket '(' gap
close = #bracket ')' gap
digit = #digit '0..9'
gap = (' ')* @
end = #newline 13? 10 @
</pre>

<p>Let's run the tests just one more time:</p>

<pre>pecan sum.txt
Pass 10 tests.
</pre>

<p>Although there are many more features that could be added, let's stop and say
we have successfully developed a numerical expression parser.</p>

<h3>Step ?</h3>

<p><b><i>Not currently working</i></b></p>

<p>To generate code, the first thing to do is to write a skeleton calculator
program, in a file <kbd>Calculator.java</kbd>, say:</p>

<pre>class Calculator {
    public static void main(String[] args) { new Calculator().run(args[0]); }
    void run(String sum) { System.out.println(parse(sum + "\n")); }
    int number() { return Integer.parseInt(text.substring(start,end)); }
    int add(int m, int n) { return m+n; }
    int subtract(int m, int n) { return m-n; }
    int multiply(int m, int n) { return m*n; }
    int divide(int m, int n) { return m/n; }
    boolean err(int row, int col, String line, String[] ss) { return false; }
    // Begin generated parser: &lt;pecan grammar='calc.txt' type='int'&gt;
    // End parser &lt;/pecan&gt;
}
</pre>

<p>The <code>main</code> method gets the program going, assuming that one
command line argument is given, without doing any validation.
The <code>run</code> method adds a newline to the end of the text to match the
convention we have ued in the grammar, calls the <code>parse</code> method, and
prints the result. The <code>number</code>, <code>add</code>,
<code>subtract</code>, <code>multiply</code> and <code>divide</code> methods
are provided to be called from the parser. The <code>number</code> function
uses the <code>text</code>, <code>start</code> and <code>end</code> variables
provided by the parser code.</p>

<p>This program includes the action functions and error function which will be
called by the parser. It also calls
functions <code>parse</code>, <code>text</code> and <code>error</code> which
will be provided by the generated parser code.</p>

<p>The two comment lines near the end indicate where the generated code is to
be inserted. The first contains a tag <code>&lt;pecan...&gt;</code> in the XML
style, and the second contains the <code>&lt;/pecan&gt;</code> end tag.
The <code>grammar</code> parameter gives the path of the file containing the
grammar to generate code from. The path is relative to the location of the
source file. The <code>type</code> parameter gives the type of the items which
the action functions expect. The next step is:</p>

<pre>pecan -java Calculator.java
</pre>

<p>This specifies that Java code is to be generated and inserted into the
file <kbd>Calculator.java</kbd>, between the <code>&lt;pecan...&gt;</code>
and <code>&lt;/pecan&gt;</code> lines.</p>

<p>Once the generated calculator program has been compiled, the calculator is
used by passing an expression as a command line argument:</p>

<pre>javac Calculator.java
java Calculator "6+3*(10+2)"
42
</pre>

<p>In this case, the actions form an evaluator, but it would be just as easy to
specify a tree node class instead of <code>int</code> and to provide action
methods which build a parse tree.</p>

<hr/>

</body>
</html>
