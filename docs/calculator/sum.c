#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

// -----------------------------------------------------------------------------
// Change this section for different applications.

// Declare the parser type and input and output types. The input type should be
// char for a scanner or text-based parser, otherwise a token structure or token
// pointer. The output type should be a number or structure or pointer.
struct parser;
typedef struct parser parser;
typedef char input;
typedef int output;

// Error marker constants, and spellings.
enum marker { digit, operator, bracket, newline };
char *names[] = { "digit", "operator", "bracket", "newline" };

// Forward declarations of parser functions.
parser *newParser(int n, input[n]);
void freeParser(parser *p);
output answer(parser *p);
void report(parser *p, char *ds, char *f, char *names[]);

// Actions:: Create a number from given text, and arithmetic operations.
output number(int n, char s[n]) {
    output x = 0;
    for (int i = 0; i < n; i++) x = x * 10 + s[i] - '0';
    return x;
}
output add(output x, output y) { return x + y; }
output subtract(output x, output y) { return x - y; }
output multiply(output x, output y) { return x * y; }
output divide(output x, output y) { return x / y; }

// Forward declarations of parsing functions, to allow them to be recursive.
bool Psum(parser *p);
bool Pexpression(parser *p);
bool Pterm(parser *p);
bool Patom(parser *p);
bool Pnumber(parser *p);
bool Pgap(parser *p);
bool Pend(parser *p);
bool Pplus(parser *p);
bool Pminus(parser *p);
bool Ptimes(parser *p);
bool Pover(parser *p);
bool Popen(parser *p);
bool Pclose(parser *p);
bool Pdigit(parser *p);

int main() {
    char in[100];
    printf("Type a sum: ");
    char *r = fgets(in, 100, stdin);
    if (r == NULL) printf("Can't read stdin\n");
    parser *p = newParser(strlen(in), in);
    bool ok = Psum(p);
    if (ok) printf("%d\n", answer(p));
    else report(p, "Syntax error:\n", "Error: expecting %s, %s\n", names);
    freeParser(p);
}

// -----------------------------------------------------------------------------
// Forward declarations of supporting constants, structures and functions.

// Unicode category codes, in the order used in the lookup tables.
enum category {
    Cn, Lu, Ll, Lt, Lm, Lo, Mn, Me, Mc, Nd, Nl, No, Zs, Zl, Zp, Cc,
    Cf, Uc, Co, Cs, Pd, Ps, Pe, Pc, Po, Sm, Sc, Sk, So, Pi, Pf
};

// Small support functions, i.e. combinators.
static bool go(parser *p);
static bool ok(parser *p);
static bool alt(parser *p, bool b);
static bool opt(parser *p, bool b);
static bool has(parser *p, bool b);
static bool not(parser *p, bool b);
static bool try(parser *p, bool b);
static bool mark(parser *p, int m);
static bool cat(parser *p, int c);
static bool range(parser *p, int low, int high);
static bool text(parser *p, char *s);
static bool set(parser *p, char *s);
static bool drop(parser *p, int n);
static bool end(parser *p);

// Parser structure support functions.
static input *start(parser *p);
static int length(parser *p);
static output top(parser *p);
static output top1(parser *p);
static bool push(parser *p, output n);
static bool push2(parser *p, output n);

// The parsing functions themselves, as generated by Pecan. The attributes of
// the pecan tag are the patterns to be used to generate the functions.
/* <pecan
    comment  = "// %s"
    declare  = "bool P%s(parser *p) {"
    body     = "    return %s;"
    close    = "}"
    compact  = "bool P%s(parser *p) { return %s; }"
    call     = "P%s(p)"
    true     = "true"
    false    = "false"
    or       = "||"
    and      = "&&"
    char     = "'%c'"
    string   = '"%s"'
    bmp      = "\u%4x"
    unicode  = "\U%8x"
    act0     = "%s(p%.0s%.0s%.0s)"
    act2     = "%s(p%.0s%.0s%.0s)"
    tag      = "tag(p, %n%d)"
    do       = "go"
> */

// sum = gap expression end
bool Psum(parser *p) { return Pgap(p) && Pexpression(p) && Pend(p); }

// expression1 = (plus term @2add / minus term @2subtract expression1)?
bool Pexpression1(parser *p) {
    return ((alt(p,
        (go(p) && Pplus(p) && Pterm(p) && push2(p,add(top1(p),top(p)))) ||
        (ok(p) && Pminus(p) && Pterm(p) && push2(p,subtract(top1(p),top(p))))
    ) && Pexpression1(p)) || true);
}

// expression = term (plus term @2add / minus term @2subtract)*
bool Pexpression(parser *p) { return Pterm(p) && Pexpression1(p); }

// term1 = (times atom @2multiply / over atom @2divide term1)?
bool Pterm1(parser *p) {
    return ((alt(p,
        (go(p) && Ptimes(p) && Patom(p) && push2(p,multiply(top1(p),top(p)))) ||
        (ok(p) && Pover(p) && Patom(p) && push2(p,divide(top1(p),top(p))))
    ) && Pterm1(p)) || true);
}

// term = atom (times atom @2multiply / over atom @2divide)*
bool Pterm(parser *p) { return Patom(p) && Pterm1(p); }

// atom = number / open expression close
bool Patom(parser *p) {
    return Pnumber(p) || (Popen(p) && Pexpression(p) && Pclose(p));
}

// number1 = (digit) number1?
bool Pnumber1(parser *p) { return Pdigit(p) && (Pnumber1(p) || true); }

// number = digit+ @number gap
bool Pnumber(parser *p) {
    return Pnumber1(p) && push(p,number(length(p),start(p))) && Pgap(p);
}

// plus = #operator '+' gap
bool Pplus(parser *p) { return mark(p,operator) && text(p,"+") && Pgap(p); }

// minus = #operator '-' gap
bool Pminus(parser *p) { return mark(p,operator) && text(p,"-") && Pgap(p); }

// times = #operator '*' gap
bool Ptimes(parser *p) { return mark(p,operator) && text(p,"*") && Pgap(p); }

// over = #operator '/' gap
bool Pover(parser *p) { return mark(p,operator) && text(p,"/") && Pgap(p); }

// open = #bracket '(' gap
bool Popen(parser *p) { return mark(p,bracket) && text(p,"(") && Pgap(p); }

// close = #bracket ')' gap
bool Pclose(parser *p) { return mark(p,bracket) && text(p,")") && Pgap(p); }

// digit = #digit '0..9'
bool Pdigit(parser *p) { return mark(p,digit) && range(p,'0','9'); }

// gap1 = (' ' gap1)?
bool Pgap1(parser *p) { return (text(p," ") && Pgap1(p)) || true; }

// gap = (' ')* @
bool Pgap(parser *p) { return Pgap1(p) && drop(p,0); }

// end = #newline 13? 10 @
bool Pend(parser *p) {
    return mark(p,newline) && (text(p,"\r") || true) && text(p,"\n") &&
    drop(p,0);
}

// </pecan>

// Structure to hold input, stack of outputs, saved input positions, depth of
// lookahead, and error marking info, during parsing.
struct parser {
    int in, start, end; input *ins;
    int out, nouts; output *outs;
    int save, nsaves; int *saves;
    int look, marked; long markers;
};

// Create new parser object from given input.
parser *newParser(int n, input ins[n]) {
    parser *p = malloc(sizeof(parser));
    *p = (parser) {
        .in = 0, .start = 0, .end = n, .ins = ins,
        .out = 0, .nouts = 8, .outs = malloc(8 * sizeof(output)),
        .save = 0, .nsaves = 8, .saves = malloc(8 * sizeof(int)),
        .look = 0, .marked = 0, .markers = 0
    };
    return p;
}

// Free parser and its data.
void freeParser(parser *p) {
    free(p->outs);
    free(p->saves);
    free(p);
}

// Return final output item.
output answer(parser *p) {
    return p->outs[--p->out];
}

// Return a pointer to the text for an action.
static inline input *start(parser *p) {
    return &p->ins[p->start];
}

// Return the length of the text for an action.
static inline int length(parser *p) {
    return p->in - p->start;
}

// Push output item onto stack.
static inline bool push(parser *p, output n) {
    if (p->out >= p->nouts) {
        p->nouts = p->nouts * 2;
        p->outs = realloc(p->outs, p->nouts);
    }
    p->outs[p->out++] = n;
    return true;
}

// Push output item onto stack, after popping two items.
static inline bool push2(parser *p, output n) {
    p->out = p->out - 2;
    p->outs[p->out++] = n;
    return true;
}

// Return top output item.
static inline int top(parser *p) {
    return p->outs[p->out-1];
}

// Return second-top output item.
static inline int top1(parser *p) {
    return p->outs[p->out-2];
}

// Push saved input position onto stack.
static inline void save(parser *p, int n) {
    if (p->save >= p->nsaves) {
        p->nsaves = p->nsaves * 2;
        p->saves = realloc(p->saves, p->nsaves);
    }
    p->saves[p->save++] = n;
}

// Pop saved input position.
static inline int unsave(parser *p) {
    return p->saves[--p->save];
}

// Structure for returning length and value of a character (code point).
struct uchar { int len, code; };
typedef struct uchar uchar;

// Read a UTF-8 character and its length.
static inline uchar getUTF8(char const *s) {
    int len = 1, ch = s[0];
    if ((ch & 0x80) == 0) return (uchar) { len, ch };
    else if ((ch & 0xE0) == 0xC0) { len = 2; ch = ch & 0x3F; }
    else if ((ch & 0xF0) == 0xE0) { len = 3; ch = ch & 0x1F; }
    else if ((ch & 0xF8) == 0xF0) { len = 4; ch = ch & 0x0F; }
    for (int i = 1; i < len; i++) ch = (ch << 6) | (s[i] & 0x3F);
    return (uchar) { len, ch};
}

// Unicode category lookup tables, read in lazily in case not needed.
typedef unsigned char byte;
static byte *table1 = NULL, *table2 = NULL;

// Read in a binary file.
static byte *readFile(char *filename) {
    FILE *fp = fopen(filename, "rb");
    if (fp == NULL) { printf("Can't read %s\n", filename); exit(1); }
    fseek(fp, 0, SEEK_END);
    long size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    byte *content = malloc(size);
    int n = fread(content, 1, size, fp);
    if (n != size) { printf("Can't read %s\n", filename); exit(1); }
    fclose(fp);
    return content;
}

// Read in lookup tables.
static void readTables() {
    table1 = readFile("table1.bin");
    table2 = readFile("table2.bin");
}

// Prepare for a choice or lookahead by recording the input position.
static inline bool go(parser *p) {
    save(p, p->in);
    return true;
}

// Check whether a previous failed alternative has progressed.
static inline bool ok(parser *p) {
    return p->in == p->saves[p->save-1];
}

// Pop a saved position, and return the result of a choice.
static inline bool alt(parser *p, bool b) {
    unsave(p);
    return b;
}

// After parsing an optional item, pop saved position, and adjust the result.
static inline bool opt(parser *p, bool b) {
    return b || p->in == unsave(p);
}

// Backtrack to saved position, and return result of lookahead.
static inline bool has(parser *p, bool b) {
    p->in = unsave(p);
    return b;
}

// Backtrack to saved position and negate result of lookahead.
static inline bool not(parser *p, bool b) {
    p->in = unsave(p);
    return ! b;
}

// Backtrack on failure.
static inline bool try(parser *p, bool b) {
    int n = unsave(p);
    if (! b) p->in = n;
    return b;
}

// Record an error marker for the current input position.
static inline bool mark(parser *p, int m) {
    if (p->look > 0) return true;
    if (p->marked < p->in) {
        p->markers = 0L;
        p->marked = p->in;
    }
    p->markers = p->markers | (1L << m);
    return true;
}

// Check if next character is in given category.
static inline bool cat(parser *p, int c) {
    if (p->in >= p->end) return false;
    if (c == Uc) return true;
    if (table1 == NULL) readTables();
    uchar u = getUTF8(&p->ins[p->in]);
    int cat = table2[table1[u.code>>8]*256+(u.code&255)];
    bool ok = cat == c;
    if (ok) p->in += u.len;
    return ok;
}

// Check if a (UTF-8) character in a given range appears next in the input.
static inline bool range(parser *p, int first, int last) {
    if (p->in >= p->end) return false;
    uchar u = getUTF8(&p->ins[p->in]);
    if (u.code < first || u.code > last) return false;
    p->in = p->in + u.len;
    return true;
}

// Check for the given (UTF-8) string next in the input.
// Handles UTF-8, working byte-by-byte.
static inline bool text(parser *p, char *s) {
    int i;
    for (i = 0; s[i] != '\0'; i++) {
        if (p->in >= p->end || p->ins[p->in + i] != s[i]) return false;
    }
    p->in += i;
    return true;
}

// Check if one of the characters in a (UTF-8) set is next in the input.
static inline bool set(parser *p, char *s) {
    if (p->in >= p->end) return false;
    bool ok = false;
    uchar u1, u2;
    for (int i = 0; s[i] != '\0' && ! ok; ) {
        u1 = getUTF8(&s[i]);
        u2 = getUTF8(&p->ins[p->in]);
        if (u1.code == u2.code) ok = true;
        i = i + u1.len;
    }
    if (ok) p->in = p->in + u2.len;
    return ok;
}

// Drop the text matched recently, and drop n output items.
static inline bool drop(parser *p, int n) {
    p->start = p->in;
    p->out = p->out - n;
    return true;
}

// Match end of input.
static inline bool end(parser *p) {
    return p->in >= p->end;
}

// Line/column and start/end of line containing an input position
struct lineInfo { int line, column, start, end; };
typedef struct lineInfo lineInfo;

// Find the line/column and start/end of line containing an input position.
static void findLine(char *input, int at, lineInfo *li) {
    li->line = 1;
    li->start = 0;
    for (int i = 0; ; i++) {
        byte b = input[i];
        if (b == '\0') { li->end = i; break; }
        if (b != '\n') continue;
        li->line++;
        if (i + 1 <= at) li->start = i + 1;
        else { li->end = i; break; }
    }
    li->column = at - li->start;
}

static void reportLine(char *in, lineInfo *li) {
    fprintf(stderr, "%.*s\n", li->end - li->start, in + li->start);
}

static void reportColumn(lineInfo *li) {
    for (int i = 0; i < li->column; i++) fprintf(stderr, " ");
    fprintf(stderr, "^\n");
}

void report(parser *p, char *s0, char *s, char *names[]) {
    lineInfo liData;
    lineInfo *li = &liData;
    findLine(p->ins, p->in, li);
    if (p->markers == 0L) fprintf(stderr, "%s", s0);
    else {
        char text[100];
        strcpy(text, s);
        int n = strstr(text, "%s") - text;
        text[n] = '\0';
        fprintf(stderr, "%s", text);
        strcpy(text, text + n + 2);
        n = strstr(text, "%s") - text;
        text[n] = '\0';
        bool first = true;
        for (int i = 0; i < 64; i++) {
            if ((p->markers & (1L << i)) == 0) continue;
            if (! first) fprintf(stderr, "%s", text);
            first = false;
            fprintf(stderr, "%s", names[i]);
        }
        strcpy(text, text + n + 2);
        fprintf(stderr, "%s", text);
    }
    reportLine(p->ins, li);
    reportColumn(li);
}
