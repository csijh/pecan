<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial</title>
<style>
    body { font-size: 120%; }
    pre, .indent { margin-left:40px; }
</style>
</head>
<body>

<img src="pecan.png" width="300" height="65" />
<hr/>

<h1>Tokens and trees</h1>

<p>In this tutorial, the calculator example will be changed in two ways. First,
a scanner will be defined separately from the parser, so that the parser works
with tokens. Second, the program produced will generate a parse tree from an
arithmetic expression and print it out, rather than calculate its value. The
example will thus be closer to what is needed for practical parsing in larger
scale situations such as compilers for programming languages.</p>

<h3>A scanner</h3>

<p>It is easy enough to develop a scanner, based on the full calculator in
the previous tutorial:</p>

<pre>tokens = gap @tokens token* end
token = number / plus / minus / times / over / open / close / bad
number = ('0..9')+ @1number gap
plus = '+' @1plus gap
minus = '-' @1minus gap
times = '*' @1times gap
over = '/' @1over gap
open = '(' @1open gap
close = ')' @1close gap
bad = (13 / 10)! Uc @1bad
end = 13? 10 @1end / @1bad
gap = (' ')* @
</pre>

<p>The grammar recognises a sequence of tokens, separated by spaces. There is a
final <code>end</code> token, which is common in scanners because it can be
convenient for recognising the last token in a token parser. With the exception
of <code>tokens</code>, each action creates a token. The name of the action will
be used as the token's tag.</p>

<p>There are no error markers. If an illegal character or lack of line ending is
encountered, a token with tag <code>bad</code> is created for it. That means the
scanner never fails, and errors are passed on to the parser for reporting. A
parse error early on in the text is thus reported in preference to a scan error
later on, creating the illusion for the user that scanning and parsing are done
together.</p>

<p>One slight worry with this scanner is that the <code>token</code> rule, if
handled naively, consists of a series of if-then-else tests, which could be
inefficient. We will deal with this issue in the optimisation tutorial.</p>

<p>In the previous tutorial, the grammar under development and its tests were
stored in a single file. This time, the grammar is in one file and the tests are
in a separate file:</p>

<p class="indent"><a href="scan.txt">scan.txt</a><br/>
<a href="scan-test.txt">scan-test.txt</a></p>

<p>The test file begins with a line which specifies the grammar file. Running
the tests through Pecan shows all is well:</p>

<pre>pecan scan-test.txt
Pass 10 tests.
</pre>

<p>The next task is to turn the grammar into a program. A skeleton program is
written, using the generic bytecode interpreter as before:</p>

<p class="indent"><a href="scan.c">scan.c</a><br/>
<a href="interpret.h">interpret.h</a><br/>
<a href="interpret.c">interpret.c</a></p>

<p>The grammar is compiled into bytecode within the skeleton program:</p>

<pre>pecan scan.txt -o scan.c
</pre>

<p>Then the program is compiled:</p>

<pre>gcc -std=c11 -Wall -O2 scan.c interpret.c -o scan
</pre>

<p>The program reads in a line of text from the user, breaks it into an array of
tokens, then prints out their tags, and their positions and lengths in the
source text.</p>

<h3>A token parser</h3>

</body>
</html>
