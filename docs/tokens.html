<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial</title>
<style>
    body { font-size: 120%; }
    pre, .indent { margin-left:40px; }
</style>
</head>
<body>

<img src="pecan.png" width="300" height="65" />
<hr/>

<h1>Tokens and trees</h1>

<p>In this tutorial, the calculator example will be changed in two ways. First,
a scanner will be defined separately from the parser, so that the parser works
with tokens. Second, the program produced will generate a parse tree from an
arithmetic expression and print it out, rather than calculate its value. The
example will thus be closer to what is needed for practical parsing in larger
scale situations such as compilers for programming languages.</p>

<h3>The scanner</h3>

<p>A scanner for sums can be developed from the full calculator in the previous
tutorial by extracting and adapting the low level rules:</p>

<pre>tokens = gap @tokens token* end
token = number / plus / minus / times / over / open / close / bad
number = ('0..9')+ @1number gap
plus = '+' @1plus gap
minus = '-' @1minus gap
times = '*' @1times gap
over = '/' @1over gap
open = '(' @1open gap
close = ')' @1close gap
bad = (13 / 10)! Uc @1bad
end = 13? 10 @1end / @1bad
gap = (' ')* @
</pre>

<p>This grammar recognises a sequence of tokens, possibly separated by spaces.
There is a final <code>end</code> token, which is common in scanners because it
can be convenient for recognising the last token in a token parser. With the
exception of <code>tokens</code>, each action creates a token. The name of the
action will be used as the token's tag.</p>

<p>There are no error markers. If an illegal character or lack of line ending is
encountered, a token with tag <code>bad</code> is created for it. That means the
scanner never fails, and errors are passed on to the parser for reporting. A
parse error early on in the text is thus reported in preference to a scan error
later on, creating the illusion for the user that scanning and parsing are done
together.</p>

<p>One slight worry with this scanner is that the <code>token</code> rule, if
handled naively, consists of a series of if-then-else tests, which could be
inefficient. We will deal with this issue in the optimisation tutorial.</p>

<p>In the previous tutorial, the grammar under development and its tests were
stored in a single file. This time, the grammar is in one file and the tests are
in a separate file:</p>

<p class="indent"><a href="scan.txt">scan.txt</a><br/>
<a href="scan-test.txt">scan-test.txt</a></p>

<p>The test file begins with a line which specifies the grammar file. Running
the tests through Pecan shows all is well:</p>

<pre>pecan scan-test.txt
Pass 10 tests.
</pre>

<p>The next task is to turn the grammar into a program. A skeleton program is
written, using the generic bytecode interpreter as before:</p>

<p class="indent"><a href="scan.c">scan.c</a><br/>
<a href="interpret.h">interpret.h</a><br/>
<a href="interpret.c">interpret.c</a></p>

<p>The grammar is compiled into bytecode within the skeleton program:</p>

<pre>pecan scan.txt -o scan.c
</pre>

<p>Then the program is compiled:</p>

<pre>gcc -std=c11 -Wall -O2 scan.c interpret.c -o scan
</pre>

<p>The program reads in a line of text from the user, breaks it into an array of
tokens, then prints out their tags, and their positions and lengths in the
source text.</p>

<h3>The parser</h3>

<p>A token-based parser for sums can be developed from the full calculator in
the previous tutorial, replacing the low level rules by tags:</p>

<pre>sum = exp #newline %end
exp = term (#op %plus term @2add / #op %minus term @2subtract)*
term = atom (#op %times atom @2multiply / #op %over atom @2divide)*
atom = #digit %number @value / bracket
bracket = #bracket %open @start exp #bracket %close @end @3group
</pre>

<p>The grammar avoids name clashes between actions, tags and markers. The
intention is that in the final parser, each action will form a tree node with
some constituent subnodes as children, according to its arity.</p>

<p>In the <code>bracket</code> rule, open and close brackets are converted into
nodes and pushed onto the output stack, and then discarded by the
<code>group</code> action, which creates a tree node for the bracketed
expression, with the inner expression as its only child. This allows the text
extent of the bracketed expression, i.e. its start and end in the input text, to
be calculated accurately. Moreover, other tree nodes which include the bracketed
expression will also have their text extents calculated accurately. The text
extent of every node is simply the union of the text extents of its
constituents. The bracketed expression nodes can be discarded after tree
construction, if desired. The remaining nodes will have accurate text extents,
which can be used to form good quality error messages in any further processing
done on the tree.</p>

<p>The grammar is stored in a file, and its tests are stored in a separate
file:</p>

<p class="indent"><a href="parse.txt">parse.txt</a><br/>
<a href="parse-test.txt">parse-test.txt</a></p>

<p>The tests are checked with Pecan as usual:</p>

<pre>pecan parse-test.txt
Pass 7 tests
</pre>

<p>Errors are reported by token index. In the real parser, with the original
text available, the token index can be converted into a text position, to
produce a conventional error message.</p>

<p>The next step is to write a skeleton parser:</p>

<p class="indent"><a href="parse.c">parse.c</a></p>

</body>
</html>
