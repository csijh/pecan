<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-gb" xml:lang="en-gb">
<head>
<title>Pecan Tutorial</title>
<style>
    body { font-size: 120%; }
    pre, .indent { margin-left:40px; }
</style>
</head>
<body>

<img src="pecan.png" width="300" height="65" />
<hr/>

<h1>Tokens and trees</h1>

<p>In this tutorial, the calculator example will be changed in two ways. First,
a scanner will be defined separately from the parser, so that the parser works
with tokens. Second, the program produced will generate a parse tree from an
arithmetic expression and print it out, rather than calculate its value. The
example will thus be closer to what is needed for practical parsing in larger
scale situations such as compilers for programming languages.</p>

<h3>The scanner</h3>

<p>A scanner for sums can be developed from the full calculator in the previous
tutorial by extracting and adapting the low level rules:</p>

<pre>tokens = gap @tokens token* end
token = number / plus / minus / times / over / open / close / bad
number = ('0..9')+ @1number gap
plus = '+' @1plus gap
minus = '-' @1minus gap
times = '*' @1times gap
over = '/' @1over gap
open = '(' @1open gap
close = ')' @1close gap
bad = (13 / 10)! Uc @1bad
end = 13? 10 / @1bad
gap = (' ')* @
</pre>

<p>This grammar recognises a sequence of tokens, possibly separated by spaces.
With the exception of <code>tokens</code>, each action creates a token. The name
of the action will be used as the token's tag.</p>

<p>There are no error markers. If an illegal character or lack of line ending is
encountered, a token with tag <code>bad</code> is created for it. That means the
scanner never fails, and errors are passed on to the parser for reporting. A
parse error early on in the text is thus reported in preference to a scan error
later on, creating the illusion for the user of the final program that scanning
and parsing are done together.</p>

<p>In the previous tutorial, the grammar under development and its tests were
stored in a single file. This time, the grammar is in one file and the tests are
in a separate file:</p>

<p class="indent"><a href="scan.txt">scan.txt</a><br/>
<a href="scan-test.txt">scan-test.txt</a></p>

<p>The test file begins with a line which specifies the grammar file. Running
the tests through Pecan shows that all is well:</p>

<pre>pecan scan-test.txt
Pass 10 tests.
</pre>

<p>The next task is to turn the grammar into a program. A skeleton program is
written, using the generic bytecode interpreter as before:</p>

<p class="indent"><a href="scan.h">scan.h</a>
<a href="scan.c">scan.c</a><br/>
<a href="interpret.h">interpret.h</a><br/>
<a href="interpret.c">interpret.c</a></p>

<p>The <code>scan</code> program is written as a reusable module, but with a
<code>main</code> function available with the <code>scanTest</code> conditional
compilation flag, so that the program can be interactively tested on its own. It
provides a <code>scan</code> function which returns an array of token
structures. There is a final sentinel structure with a negative tag, so that the
length of the array does not need to be passed around with the array. The
grammar is compiled into bytecode within the skeleton program:</p>

<pre>pecan scan.txt -o scan.c
</pre>

<p>Then the program is compiled, with the conditional compilation flag:</p>

<pre>gcc -std=c11 -Wall -O2 -DscanTest scan.c interpret.c -o scan
</pre>

<p>The program reads in a line of text from the user, breaks it into an array of
tokens, then prints out their tags, and their positions and lengths in the
source text:</p>

<pre>./scan
Type a sum: 2+2
number 0 1
plus 1 1
number 2 1
</pre>

<h3>The parser</h3>

<p>A token-based parser for sums can be developed from the full calculator in
the previous tutorial, replacing the low level rules by tags:</p>

<pre>sum = exp #newline %end
exp = term (#op %plus term @2add / #op %minus term @2subtract)*
term = atom (#op %times atom @2multiply / #op %over atom @2divide)*
atom = #digit %number @value / #bracket %open exp #bracket %close
</pre>

<p>The grammar avoids name clashes between actions, tags and markers. The
intention is that in the final program, each action will form a tree node with
some constituent subnodes as children, according to its arity. The grammar is
stored in a file, and its tests are stored in a separate file:</p>

<!--
<p>In the <code>bracket</code> rule, open and close brackets are converted into
nodes and pushed onto the output stack, and then discarded by the
<code>group</code> action, which creates a tree node for the bracketed
expression, with the inner expression as its only child. This allows the text
extent of the bracketed expression, i.e. its start and end in the input text, to
be calculated accurately. Moreover, other tree nodes which include the bracketed
expression will also have their text extents calculated accurately. The text
extent of every node is simply the union of the text extents of its
constituents. The bracketed expression nodes can be discarded after tree
construction, if desired. The remaining nodes will have accurate text extents,
which can be used to form good quality error messages in any further processing
done on the tree.</p>
-->


<p class="indent"><a href="parse.txt">parse.txt</a><br/>
<a href="parse-test.txt">parse-test.txt</a></p>

<p>The tests are checked with Pecan as usual:</p>

<pre>pecan parse-test.txt
Pass 7 tests
</pre>

<p>When an error is reported, its token index is given. In the real parser, with
the original text available, the token index can be converted into a text
position, to produce a conventional error message. The next step is to write a
skeleton parser, which uses both the scanner module and the provided bytecode
interpreter:</p>

<p class="indent"><a href="parse.c">parse.c</a><br/>
<a href="scan.h">scan.h</a>
<a href="scan.c">scan.c</a><br/>
<a href="interpret.h">interpret.h</a><br/>
<a href="interpret.c">interpret.c</a></p>

</body>
</html>
