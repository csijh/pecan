#include "scan.h"
#include "interpret.h"
#include <stdio.h>
#include <stdlib.h>

// Node types, also used as actions, and their spellings.
enum type { value, add, subtract, multiply, divide };
static char *typeNames[] = { "value", "add", "subtract", "multiply", "divide" };

// Error marker constants, and spellings.
enum marker { digit, op, bracket, newline };
static char *markNames[] = { "digit", "operator", "bracket", "newline" };

// Array to hold scanner bytecode generated by pecan.
static byte code[] = {
// <pecan>
// </pecan>
};

// Node structure for storing a parse tree node.
struct node { int type, value; struct node *left, *right; };
typedef struct node node;

// State structure to hold the input, as text and tokens, and a stack of nodes.
struct state { char *input; token *tokens; int top, max; node **nodes; };
typedef struct state state;

// Create a new state with a given input and room for n nodes.
static inline state *newState(char *in, token *ts, int n) {
    state *s = malloc(sizeof(state));
    *s = (state) {
        .input = in, .tokens = ts, .top = 0, .max = n,
        .nodes = malloc(n * sizeof(node *))
    };
    return s;
}

// Free the state and its tokens and nodes.
static inline void freeState(state *s) {
    free(s->tokens);
    free(s->nodes);
    free(s);
}

// Add a node, doubling the capacity if necessary.
static inline void addNode(state *s, int type, int v, node *left, node *right) {
    if (s->top >= s->max) {
        s->max = s->max * 2;
        s->nodes = realloc(s->nodes, s->max * sizeof(node));
    }
    node *p = malloc(sizeof(node));
    *p = (node) { .type = type, .value = v, .left = left, .right = right };
    s->nodes[s->top++] = p;
}

// Get the tag of the i'th token.
static int tag(void *vs, int i) {
    state *s = vs;
    token *t = &s->tokens[i];
    return t->tag;
}

// Carry out an action, to create a tree node.
static void act(void *vs, int a, int p, int n) {
    state *s = vs;
    if (a == value) {
        token *t = &s->tokens[p + n - 1];
        int p = t->at, n = t->length;
        int x = 0;
        for (int i = 0; i < n; i++) x = x * 10 + (s->input[p + i] - '0');
        addNode(s, a, x, NULL, NULL);
    }
    else {
        node *r = s->nodes[--s->top];
        node *l = s->nodes[--s->top];
        addNode(s, a, 0, l, r);
    }
}

// Print out a node with the given indent.
static void printNode(node *p, int indent) {
    for (int i = 0; i < indent; i++) printf(" ");
    printf("%s", typeNames[p->type]);
    if (p->type == value) printf(" %d", p->value);
    printf("\n");
    if (p->left != NULL) printNode(p->left, indent + 2);
    if (p->right != NULL) printNode(p->right, indent + 2);
}

int main() {
    char input[100];
    printf("Type a sum: ");
    char *out = fgets(input, 100, stdin);
    if (out == NULL) printf("Can't read stdin\n");
    token *ts = scan(input);
    state *s = newState(input, ts, 8);
    result *r = malloc(sizeof(result));
    parseTokens(code, tag, act, s, r);
    if (r->ok) printNode(s->nodes[--s->top], 0);
    else {
        printf("at %d in %d\n", r->at, s->tokens[r->at].at);
        r->at = s->tokens[r->at].at;
        report(
            input, r, "Syntax error:\n", "Error: expecting %s, %s\n", markNames
        );
    }
    free(r);
    freeState(s);
}
