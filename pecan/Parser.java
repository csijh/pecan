// Pecan 1.0 parser. Free and open source. See licence.txt.

package pecan;

import java.util.*;
import static pecan.Category.*;
import static pecan.Op.*;
import static pecan.Parser.Marker.*;
import java.nio.*;
import java.nio.file.*;
import java.nio.charset.*;

/* Parse a Pecan source text, assumed to be in UTF-8 format, producing a tree.

The parser is translated from the grammar rules in the comments. The grammar (a)
has repetitions lifted to the top level as separate rules, (b) has no left-hand
alternative starting with an action and (b) has no try construct containing
error markers or actions. That means one rule corresponds to one function, and
actions don't need to be delayed, just switched off during lookahead. The
functions can be hand-maintained to keep this class self-contained and avoid
bootstrap problems.

The grammar is concrete, i.e. it creates extra nodes for postfix operator
symbols, brackets, and bracketed subexpressions, and then removes them at the
end. This allows the text extent of a node to be found uniformly by combining
the text extents of its children. For example, given an expression (x)y, the
combination of two nodes with extents "x" and "y" is "(x)y" and not "x)y". An
alternative, to increase the  extent "x" to "(x)" wouldn't work when x is an
identifier, because then the node's text would not be the name of the id. */

class Parser implements Testable {
    private Source input;
    private Node[] output;
    private Set<Marker> markers;
    private int[] saves;
    private Set<String> cats;
    private int start, in, out, look, marked, save;
    private Op Postop = Temp, Bracket = Temp, Bracketed = Temp, Include = Temp;

    public static void main(String[] args) {
        Test.run(new Parser(), args);
    }

    // Parse the grammar, returning a node (possibly an error node).
    public Node run(Source s) {
        input = s;
        if (output == null) output = new Node[1];
        if (markers == null) markers = EnumSet.noneOf(Marker.class);
        markers.clear();
        saves = new int[100];
        cats = new HashSet<String>();
        for (Category cat : Category.values()) cats.add(cat.toString());
        start = in = out = look = marked = save = 0;
        boolean ok = grammar();
        if (! ok) {
            Node err = new Node(Error, s, in, in);
            if (marked < in) markers.clear();
            err.note(s.error(in, in, message()));
            return err;
        }
        assert(save == 0);
        assert(out == 1);
        Node root = output[0];
        root = prune(root);
        root = merge(root);
        return root;
    }

    // Error markers, in alphabetical order. In messages, names are made lower
    // case and underscores are replaced with spaces.
    enum Marker {
        ATOM, BRACKET, DOT, END_OF_TEXT, EQUALS, GREATER_THAN_SIGN, ID, LETTER,
        NEWLINE, OPERATOR, QUOTE, TAG
    }

    // ---------- Generated by <pecan> from the grammar ------------------------

    // grammar = skip rules #end <>
    private boolean grammar() {
        return skip() && rules() && MARK(END_OF_TEXT) && END();
    }

    // rules = (inclusion / rule) (rules @2list)?
    // rules = (inclusion / rule) (rules / @empty) @2list
    private boolean rules() {
        return (
            ALT(DO() && inclusion() || OR() && rule()) &&
            ALT(DO() && rules() || ACT(Empty)) &&
            ACT2(List)
        );
    }

    // inclusion = include newline @include skip
    private boolean inclusion() {
        return include() && newline() && ACT1(Include) && skip();
    }

    // rule = #id id equals expression newline @2rule skip
    private boolean rule() {
        return MARK(ID) && id() && equals() && exp() && newline() &&
        ACT2(Rule) && skip();
    }

    // expression = term (slash expression @2or)?
    private boolean exp() {
        return term() && OPT(
            DO() && slash() && exp() && ACT2(Or)
        );
    }

    // term = factor (term @2and)?
    private boolean term() {
        return factor() && OPT(DO() && term() && ACT2(And));
    }

    // factor = #atom atom postops
    private boolean factor() {
        return MARK(ATOM) && atom() && postops();
    }

    // postops = (postop postops)?
    private boolean postops() {
        return OPT(DO() && postop() && postops());
    }

    // postop = opt @1opt / any @1any / some @1some / has @1has / not @1not
    private boolean postop() {
        switch (NEXT()) {
            case '?': return (opt() && ACT2(Opt));
            case '*': return (any() && ACT2(Any));
            case '+': return (some() && ACT2(Some));
            case '&': return (has() && ACT2(Has));
            case '!': return (not() && ACT2(Not));
            default: return false;
        }
    }

    // atom = bracket / try / id / act / mark / tag /
    //     codes / code / range / set / string / split / category
    private boolean atom() {
        switch (NEXT()) {
            case '(': return bracket();
            case '[': return try_();
            case '@': return act();
            case '#': return mark();
            case '<': return split();
            case '%': return tag();
            case '\'': return ALT(DO() && range() || OR() && set());
            case '"': return string();
            default: return ALT(
                DO() && category() ||
                OR() && id() ||
                OR() && codes() ||
                OR() && code()
            );
        }
    }

    // bracket = open expression close @3bracket
    private boolean bracket() {
        return open() && exp() && close() && ACT3(Bracketed);
    }

    // try = sopen expression sclose @3try
    private boolean try_() {
        return sopen() && exp() && sclose() && ACT3(Try);
    }

    // id = (cat alpha!)! name @id blank
    private boolean id() {
        return NOT(
            DO() && cat() && NOT(DO() && alpha())
        ) && name() && ACT(Id) && blank();
    }

    // act = '@' decimals name? @act blank
    private boolean act() {
        return CHAR('@') && decimals() && OPT(DO() && name()) && ACT(Act) &&
        blank();
    }

    // mark = "#" #letter name @mark blank
    private boolean mark() {
        return CHAR('#') && MARK(LETTER) && name() && ACT(Mark) && blank();
    }

    // tag = "%" #letter name @tag blank
    private boolean tag() {
        return CHAR('%') && MARK(LETTER) && name() && ACT(Tag) && blank();
    }

    // codes = [digits '.'] #dot '.' digits @codes blank
    private boolean codes() {
        return TRY(
            DO() && digits() && CHAR('.')
        ) && MARK(DOT) && CHAR('.') && digits() && ACT(Codes) && blank();
    }

    // code = digits @code blank
    private boolean code() {
        return digits() && ACT(Code) && blank();
    }

    // range = ["'" noquote ".."] noquote #quote "'" @range blank
    private boolean range() {
        return TRY(
            DO() && CHAR('\'') && noquote() && STRING("..")
        ) && noquote() && MARK(QUOTE) && CHAR('\'') && ACT(Range) && blank();
    }

    // set = "'" noquotes #quote "'" @set blank
    private boolean set() {
        return (
            CHAR('\'') && noquotes() && MARK(QUOTE) &&
            CHAR('\'') && ACT(Set) && blank()
        );
    }

    // string = '"' nodquotes #quote '"' @string blank
    private boolean string() {
        return (
            CHAR('"') && nodquotes() && MARK(QUOTE) &&
            CHAR('"') && ACT(String) && blank()
        );
    }

    // split = '<' noangles #gt '>' @split) blank
    private boolean split() {
        return (
            CHAR('<') && noangles() && MARK(GREATER_THAN_SIGN) && CHAR('>') &&
            ACT(Split) && blank()
        );
    }

    // include = "{" nocurlies #bracket "}" @string blank
    private boolean include() {
        return CHAR('{') && nocurlies() && MARK(BRACKET) && CHAR('}') &&
        ACT(String) && blank();
    }

    // equals = #equals "=" gap
    private boolean equals() {
        return MARK(EQUALS) && CHAR('=') && gap();
    }

    // slash = #op "/" gap
    private boolean slash() {
        return MARK(OPERATOR) && CHAR('/') && gap();
    }

    // has = "&" @postop blank
    private boolean has() {
        return CHAR('&') && ACT(Postop) && blank();
    }

    // not = "!" @postop blank
    private boolean not() {
        return CHAR('!') && ACT(Postop) && blank();
    }

    // opt = "?" @postop blank
    private boolean opt() {
        return CHAR('?') && ACT(Postop) && blank();
    }

    // any = "*" @postop blank
    private boolean any() {
        return CHAR('*') && ACT(Postop) && blank();
    }

    // some = "+" @postop blank
    private boolean some() {
        return CHAR('+') && ACT(Postop) && blank();
    }

    // open = "(" @bracket gap
    private boolean open() {
        return CHAR('(') && ACT(Bracket) && gap();
    }

    // sopen = "[" @bracket gap
    private boolean sopen() {
        return CHAR('[') && ACT(Bracket) && gap();
    }

    // close = ")" @bracket blank
    private boolean close() {
        return MARK(BRACKET) && CHAR(')') && ACT(Bracket) && blank();
    }

    // sclose = "]" @bracket blank
    private boolean sclose() {
        return MARK(BRACKET) && CHAR(']') && ACT(Bracket) && blank();
    }

    // category = [cat alpha!] @cat blank
    private boolean category() {
        return TRY(
            DO() && cat() && NOT(DO() && alpha())
        ) && ACT(Cat) && blank();
    }

    // cat = "Uc" / "Cc" / "Cf" / "Cn" / "Co" / "Cs" / "Ll" / "Lm" / "Lo" /
    //    "Lt" / "Lu" / "Mc" / "Me" / "Mn" / "Nd" / "Nl" / "No" / "Pc" / "Pd" /
    //    "Pe" / "Pf" / "Pi" / "Po" / "Ps" / "Sc" / "Sk" / "Sm" / "So" / "Zl" /
    //    "Zp" / "Zs"
    // Hand optimised.
    private boolean cat() {
        if (in >= input.length() - 2) return false;
        boolean ok = cats.contains(input.substring(in, in + 2));
        if (ok) in = in + 2;
        return ok;
    }

    // blank = spaces [endline spaces '=/)]' &]? @
    private boolean blank() {
        return spaces() && OPT(DO() && TRY(
            DO() && endline() && spaces() && HAS(DO() && SET("=/)]"))
        )) && ACT();
    }

    // gap = spaces (newline spaces)? @
    private boolean gap() {
        return spaces() && OPT(DO() && newline() && spaces()) && ACT();
    }

    // skip = ((space / comment / newline) @ skip)?
    private boolean skip() {
        return OPT(DO() &&
            ALT(DO() &&
                space() || OR() && comment() || OR() && newline()
            ) && ACT() && skip()
        );
    }

    // comment = "--" visibles newline
    private boolean comment() {
        return STRING("--") && visibles() && newline();
    }

    // newline = #newline endline @
    private boolean newline() {
        return MARK(NEWLINE) && endline() && ACT();
    }

    // space = ' '
    private boolean space() {
        return CHAR(' ');
    }

    // spaces = space*
    private boolean spaces() {
        return OPT(DO() && space() && spaces());
    }

    // visible = (Cc/Cn/Co/Cs/Zl/Zp)! Uc
    private boolean visible() {
        if (in >= input.length()) return false;
        int ch = input.codePointAt(in);
        Category cat = Category.get(ch);
        if (cat == Cn || cat == Cc || cat == Co) return false;
        if (cat == Cs || cat == Zl || cat == Zp) return false;
        in += Character.charCount(ch);
        return true;
    }

    // visibles = visible*
    private boolean visibles() {
        return OPT(DO() && visible() && visibles());
    }

    // alpha = letter / Nd / '-'
    private boolean alpha() {
        return letter() || CAT(Nd) || CHAR('-');
    }

    // alphas = alpha*
    private boolean alphas() {
        return OPT(DO() && alpha() && alphas());
    }

    // letter = Lu / Ll / Lt / Lm / Lo / '_'
    private boolean letter() {
        if (in >= input.length()) return false;
        if (input.startsWith("_", in)) { in++; return true; }
        int ch = input.codePointAt(in);
        Category cat = Category.get(ch);
        boolean ok = (
            cat == Lu || cat == Ll || cat == Lt || cat == Lm || cat == Lo
        );
        if (ok) in += Character.charCount(ch);
        return ok;
    }

    // name = letter alphas / literal
    private boolean name() {
        return letter() && alphas() || literal();
    }

    // literal = "`" nobquotes #quote "`"
    private boolean literal() {
        return CHAR('`') && nobquotes() && MARK(QUOTE) && CHAR('`');
    }

    // initial = #letter letter
    private boolean initial() {
        return MARK(LETTER) && letter();
    }

    // decimal = '0..9'
    private boolean decimal() {
        return RANGE('0', '9');
    }

    // decimals = decimal*
    private boolean decimals() {
        return OPT(DO() && decimal() && decimals());
    }

    // hex = decimal / 'ABCDEFabcdef'
    private boolean hex() {
        return ALT(DO() && decimal() || OR() && SET("ABCDEFabcdef"));
    }

    // hexes = hex*
    private boolean hexes() {
        return OPT(DO() && hex() && hexes());
    }

    // digits = ('1..9' decimals) / '0' hexes
    private boolean digits() {
        return ALT(
            DO() && RANGE('1','9') && decimals() || OR() && CHAR('0') && hexes()
        );
    }

    // noquote = "'"! visible
    private boolean noquote() {
        return NOT(DO() && CHAR('\'')) && visible();
    }

    // noquotes = ("'"! visible)*
    private boolean noquotes() {
        return OPT(DO() && NOT(DO() && CHAR('\'')) && visible() && noquotes());
    }

    // nodquotes = ('"'! visible)*
    private boolean nodquotes() {
        return OPT(DO() && NOT(DO() && CHAR('"')) && visible() && nodquotes());
    }

    // nobquotes = ("`"! '!..~')*
    private boolean nobquotes() {
        return OPT(
            DO() && NOT(DO() && CHAR('`')) && RANGE('!','~') && nobquotes()
        );
    }

    // noangles = ('>'! visible)*
    private boolean noangles() {
        return OPT(DO() && NOT(DO() && CHAR('>')) && visible() && noangles());
    }

    // nocurlies = ('}'! visible)*
    private boolean nocurlies() {
        return OPT(DO() && NOT(DO() && CHAR('}')) && visible() && nocurlies());
    }

    // endline = 13? 10
    private boolean endline() {
        return (CHAR('\r') || true) && CHAR('\n');
    }

    // ---------- Support functions --------------------------------------------

    // Prepare for a choice or lookahead by recording the input position.
    private boolean DO() {
        if (save >= saves.length) {
            saves = Arrays.copyOf(saves, saves.length * 2);
        }
        saves[save++] = in;
        return true;
    }

    // Check an alternative to see whether to try the next one.
    private boolean OR() {
        return in == saves[save-1];
    }

    // Check the result of a choice and pop the saved position.
    private boolean ALT(boolean b) {
        --save;
        return b;
    }

    // Pop saved position, make the result success if fail with no progress
    private boolean OPT(boolean b) {
        --save;
        return b || in == saves[save];
    }

    // Backtrack to saved position.
    private boolean HAS(boolean b) {
        in = saves[--save];
        return b;
    }

    // Backtrack to saved position and negate result.
    private boolean NOT(boolean b) {
        in = saves[--save];
        return !b;
    }

    // Backtrack on failure.
    private boolean TRY(boolean b) {
        if (b) --save;
        else in = saves[--save];
        return b;
    }

    // Record an error marker for the current input position.
    private boolean MARK(Marker m) {
        if (look > 0) return true;
        if (marked > in) throw new Error("marked " + marked + " in " + in);
        if (marked < in) {
            markers.clear();
            marked = in;
        }
        markers.add(m);
        return true;
    }

    // Nd
    private boolean CAT(Category c) {
        if (in >= input.length()) return false;
        int ch = input.codePointAt(in);
        Category cat = Category.get(ch);
        if (cat != c) return false;
        in += Character.charCount(ch);
        return true;
    }

    // Check if a character (ascii) appears next in the input.
    private boolean CHAR(char ch) {
        if (in >= input.length()) return false;
        if (input.charAt(in) != ch) return false;
        in++;
        return true;
    }

    // Check if a character (ascii) in a given range appears next in the input.
    private boolean RANGE(char first, char last) {
        if (in >= input.length()) return false;
        if (input.charAt(in) < first || input.charAt(in) > last) return false;
        in++;
        return true;
    }

    // Check for the given (ascii) string next in the input.
    private boolean STRING(String s) {
        if (in + s.length() > input.length()) return false;
        for (int i = 0; i < s.length(); i++) {
            if (input.charAt(in + i) != s.charAt(i)) return false;
        }
        in += s.length();
        return true;
    }

    // Check if a character (ascii) in a given range appears next in the input.
    private boolean SET(String s) {
        if (in >= input.length()) return false;
        char ch = input.charAt(in);
        boolean found = false;
        for (int i = 0; i < s.length() && ! found; i++) {
            if (ch == s.charAt(i)) found = true;
        }
        if (found) in++;
        return found;
    }

    // Return the next character in the input.
    private char NEXT() {
        if (in >= input.length()) return '\0';
        return input.charAt(in);
    }

    private boolean END() {
        return in >= input.length();
    }

    // @
    private boolean ACT() {
        if (look > 0) return true;
        start = in;
        return true;
    }

    // @a
    private boolean ACT(Op op) {
        if (look > 0) return true;
        if (out >= output.length) {
            output = Arrays.copyOf(output, output.length * 2);
        }
        output[out++] = new Node(op, input, start, in);
        start = in;
        return true;
    }

    // @1a. Do inclusion of sub-grammar here.
    private boolean ACT1(Op op) {
        if (look > 0) return true;
        start = in;
        Node x = output[--out];
        if (op == Include) {
            String file = Source.relativeFile(input.fileName(), x.name());
            String s = Source.readFile(file);
            Source source2 = new Source(s, file);
            Parser parser2 = new Parser();
            Node g = parser2.run(source2);
            Node include = new Node(Include, g, input, x.start(), x.end());
            output[out++] = include;
            return true;
        }
        Node y = new Node(op, x, input, x.start(), x.end());
        output[out++] = y;
        return true;
    }

    // @2a
    private boolean ACT2(Op op) {
        if (look > 0) return true;
        start = in;
        Node y = output[--out];
        Node x = output[--out];
        Node r = new Node(op, x, y, input, x.start(), y.end());
        output[out++] = r;
        return true;
    }

    // @3a used for bracketed subexpressions (x) or [x], discarding brackets.
    private boolean ACT3(Op op) {
        if (look > 0) return true;
        start = in;
        Node close = output[--out];
        Node x = output[--out];
        Node open = output[--out];
        Node y = new Node(op, x, input, open.start(), close.end());
        output[out++] = y;
        return true;
    }

    // Produce an error message from the markers at the current input position.
    private String message() {
        if (markers.size() == 0) return "";
        String s = "expecting ";
        boolean first = true;
        for (Marker m : markers) {
            if (! first) s = s + ", ";
            first = false;
            s = s + m.toString().toLowerCase().replaceAll("_"," ");
        }
        return s;
    }

    // Remove temporary nodes (brackets, postix, inclusions)
    private Node prune(Node r) {
        if (r == null) return null;
        Op op = r.op();
        r.left(prune(r.left()));
        r.right(prune(r.right()));
        if (r.right() != null && r.right().op() == Temp) r.right(null);
        if (op == Temp) return r.left();
        return r;
    }

    // Merge lists caused by inclusions.
    private Node merge(Node r) {
        if (r.op() == Empty) return r;
        assert(r.op() == List);
        if (r.left().op() == Rule) { merge(r.right()); return r; }
        Node n = r.left();
        assert(n.op() == List);
        r.left(n.left());
        if (n.right().op() == Empty) return r;
        n.left(n.right());
        n.right(r.right());
        r.right(n);
        merge(r);
        return r;
    }
}
