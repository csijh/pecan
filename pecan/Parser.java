// Pecan 1.0 parser. Free and open source. See licence.txt.

package pecan;

import java.util.*;
import static pecan.Category.*;
import static pecan.Op.*;
import static pecan.Parser.Marker.*;

/* Parse a Pecan source text, assumed to be in UTF-8 format, producing a tree.

The parser is translated from the grammar rules in the comments. The grammar (a)
has repetitions lifted to the top level as separate rules, (b) has no left-hand
alternative starting with an action and (b) has no try construct containing
error markers or actions. That means one rule corresponds to one function, and
actions don't need to be delayed, just switched off during lookahead. The
functions can be hand-maintained to keep this class self-contained and avoid
bootstrap problems.

The grammar is concrete, i.e. it creates extra nodes for postfix operator
symbols, brackets, and bracketed subexpressions, and then removes them at the
end. This allows the text extent of a node to be found uniformly by combining
the text extents of its children. For example, given an expression (x)y, the
combination of two nodes with extents "x" and "y" is "(x)y" and not "x)y". An
alternative, to increase the  extent "x" to "(x)" wouldn't work when x is an
identifier, because then the node's text would not be the name of the id. */

class Parser implements Testable {
    private Source input;
    private Node[] output;
    private Set<Marker> markers;
    private int[] saves;
    private Set<String> cats;
    private int start, in, out, look, marked, save;
    private Op Postop = Temp, Bracket = Temp, Bracketed = Temp;

    public static void main(String[] args) {
        Test.run(new Parser(), args);
    }

    // Parse the grammar, returning a node (possibly an error node).
    public Node run(Source s) {
        input = s;
        if (output == null) output = new Node[1];
        if (markers == null) markers = EnumSet.noneOf(Marker.class);
        markers.clear();
        saves = new int[100];
        cats = new HashSet<String>();
        for (Category cat : Category.values()) cats.add(cat.toString());
        start = in = out = look = marked = save = 0;
        boolean ok = grammar();
        if (! ok) {
            Node err = new Node(Error, s, in, in);
            if (marked < in) markers.clear();
            err.note(s.error(in, in, message()));
            return err;
        }
        assert(save == 0);
        assert(out == 1);
        return prune(output[0]);
    }

    // Error markers, in alphabetical order. In messages, names are made lower
    // case and underscores are replaced with spaces.
    enum Marker {
        ATOM, BRACKET, DOT, END_OF_TEXT, EQUALS, GREATER_THAN_SIGN, ID, LETTER,
        NEWLINE, OPERATOR, QUOTE, TAG
    }

    // ---------- Generated by <pecan> from the grammar ------------------------

    // grammar = skip rules #end <>
    private boolean grammar() {
        return skip() && rules() && MARK(END_OF_TEXT) && END();
    }

    // rules = (inclusion / rule) (rules @2list)?
    private boolean rules() {
        return (
            ALT(GO() && inclusion() || OR() && rule()) &&
            OPT(GO() && rules() && ACT2(List))
        );
    }

    // inclusion = string endline @1include skip
    private boolean inclusion() {
        return string() && endline() && ACT1(Include) && skip();
    }

    // rule = #id (id / backquote) equals expression newline @2rule skip
    private boolean rule() {
        return MARK(ID) && ALT(
            GO() && id() ||
            OR() && backquote()
        ) && equals() && exp() && newline() && ACT2(Rule) && skip();
    }

    // expression = term (slash expression @2or)?
    private boolean exp() {
        return term() && OPT(
            GO() && slash() && exp() && ACT2(Or)
        );
    }

    // term = factor (term @2and)?
    private boolean term() {
        return factor() && OPT(GO() && term() && ACT2(And));
    }

    // factor = #atom atom postops
    private boolean factor() {
        return MARK(ATOM) && atom() && postops();
    }

    // postops = (postop postops)?
    private boolean postops() {
        return OPT(GO() && postop() && postops());
    }

    // postop = opt @1opt / any @1any / some @1some / has @1has / not @1not
    private boolean postop() {
        switch (NEXT()) {
            case '?': return (opt() && ACT2(Opt));
            case '*': return (any() && ACT2(Any));
            case '+': return (some() && ACT2(Some));
            case '&': return (has() && ACT2(Has));
            case '!': return (not() && ACT2(Not));
            default: return false;
        }
    }

    // atom = bracket / try / id / backquote / act / mark / tag /
    //     codes / code / range / set / string / split / category
    private boolean atom() {
        switch (NEXT()) {
            case '(': return bracket();
            case '[': return try_();
            case '`': return backquote();
            case '@': return act();
            case '#': return mark();
            case '<': return split();
            case '%': return tag();
            case '\'': return ALT(GO() && range() || OR() && set());
            case '"': return string();
            default: return ALT(
                GO() && category() ||
                OR() && id() ||
                OR() && codes() ||
                OR() && code()
            );
        }
    }

    // bracket = open expression close @3bracket
    private boolean bracket() {
        return open() && exp() && close() && ACT3(Bracketed);
    }

    // try = sopen expression sclose @3try
    private boolean try_() {
        return sopen() && exp() && sclose() && ACT3(Try);
    }

    // id = (cat alpha!)! letter alphas @id blank
    private boolean id() {
        return NOT(
            GO() && cat() && NOT(GO() && alpha())
        ) && letter() && alphas() && ACT(Id) && blank();
    }

    // backquote = "`" nobquotes #quote "`" @id blank
    private boolean backquote() {
        return (
            CHAR('`') && nobquotes() && MARK(QUOTE) && CHAR('`') &&
            ACT(Id) && blank()
        );
    }

    // act = '@' decimals alphas @act blank
    private boolean act() {
        return CHAR('@') && decimals() && alphas() && ACT(Act) && blank();
    }

    // mark = "#" initial alphas @mark blank
    private boolean mark() {
        return CHAR('#') && initial() && alphas() && ACT(Mark) && blank();
    }

    // tag = "%" initial alphas @tag blank
    private boolean tag() {
        return CHAR('%') && initial() && alphas() && ACT(Tag) && blank();
    }

    // codes = [digits '.'] #dot '.' digits @codes blank
    private boolean codes() {
        return TRY(
            GO() && digits() && CHAR('.')
        ) && MARK(DOT) && CHAR('.') && digits() && ACT(Codes) && blank();
    }

    // code = digits @code blank
    private boolean code() {
        return digits() && ACT(Code) && blank();
    }

    // range = ["'" noquote ".."] noquote #quote "'" @range blank
    private boolean range() {
        return TRY(
            GO() && CHAR('\'') && noquote() && STRING("..")
        ) && noquote() && MARK(QUOTE) && CHAR('\'') && ACT(Range) && blank();
    }

    // set = "'" noquotes #quote "'" @set blank
    private boolean set() {
        return (
            CHAR('\'') && noquotes() && MARK(QUOTE) &&
            CHAR('\'') && ACT(Set) && blank()
        );
    }

    // string = '"' nodquotes #quote '"' @string blank
    private boolean string() {
        return (
            CHAR('"') && nodquotes() && MARK(QUOTE) &&
            CHAR('"') && ACT(String) && blank()
        );
    }

    // split = '<' noangles #gt '>' @split) blank
    private boolean split() {
        return (
            CHAR('<') && noangles() && MARK(GREATER_THAN_SIGN) && CHAR('>') &&
            ACT(Split) && blank()
        );
    }

    // equals = #equals "=" gap
    private boolean equals() {
        return MARK(EQUALS) && CHAR('=') && gap();
    }

    // slash = #op "/" gap
    private boolean slash() {
        return MARK(OPERATOR) && CHAR('/') && gap();
    }

    // has = "&" @postop blank
    private boolean has() {
        return CHAR('&') && ACT(Postop) && blank();
    }

    // not = "!" @postop blank
    private boolean not() {
        return CHAR('!') && ACT(Postop) && blank();
    }

    // opt = "?" @postop blank
    private boolean opt() {
        return CHAR('?') && ACT(Postop) && blank();
    }

    // any = "*" @postop blank
    private boolean any() {
        return CHAR('*') && ACT(Postop) && blank();
    }

    // some = "+" @postop blank
    private boolean some() {
        return CHAR('+') && ACT(Postop) && blank();
    }

    // open = "(" @bracket gap
    private boolean open() {
        return CHAR('(') && ACT(Bracket) && gap();
    }

    // sopen = "[" @bracket gap
    private boolean sopen() {
        return CHAR('[') && ACT(Bracket) && gap();
    }

    // close = ")" @bracket blank
    private boolean close() {
        return MARK(BRACKET) && CHAR(')') && ACT(Bracket) && blank();
    }

    // sclose = "]" @bracket blank
    private boolean sclose() {
        return MARK(BRACKET) && CHAR(']') && ACT(Bracket) && blank();
    }

    // category = [cat alpha!] @cat blank
    private boolean category() {
        return TRY(
            GO() && cat() && NOT(GO() && alpha())
        ) && ACT(Cat) && blank();
    }

    // cat = "Uc" / "Cc" / "Cf" / "Cn" / "Co" / "Cs" / "Ll" / "Lm" / "Lo" /
    //    "Lt" / "Lu" / "Mc" / "Me" / "Mn" / "Nd" / "Nl" / "No" / "Pc" / "Pd" /
    //    "Pe" / "Pf" / "Pi" / "Po" / "Ps" / "Sc" / "Sk" / "Sm" / "So" / "Zl" /
    //    "Zp" / "Zs"
    // Hand optimised.
    private boolean cat() {
        if (in >= input.length() - 2) return false;
        boolean ok = cats.contains(input.substring(in, in + 2));
        if (ok) in = in + 2;
        return ok;
    }

    // blank = spaces [endline spaces '=/)]' &]? @
    private boolean blank() {
        return spaces() && OPT(GO() && TRY(
            GO() && endline() && spaces() && HAS(GO() && SET("=/)]"))
        )) && ACT();
    }

    // gap = spaces (newline spaces)? @
    private boolean gap() {
        return spaces() && OPT(GO() && newline() && spaces()) && ACT();
    }

    // skip = ((space / comment / newline) @ skip)?
    private boolean skip() {
        return OPT(GO() &&
            ALT(GO() &&
                space() || OR() && comment() || OR() && newline()
            ) && ACT() && skip()
        );
    }

    // comment = "--" visibles newline
    private boolean comment() {
        return STRING("--") && visibles() && newline();
    }

    // newline = #newline endline @
    private boolean newline() {
        return MARK(NEWLINE) && endline() && ACT();
    }

    // space = ' '
    private boolean space() {
        return CHAR(' ');
    }

    // spaces = space*
    private boolean spaces() {
        return OPT(GO() && space() && spaces());
    }

    // visible = (Cc/Cn/Co/Cs/Zl/Zp)! Uc
    private boolean visible() {
        if (in >= input.length()) return false;
        int ch = input.codePointAt(in);
        Category cat = Category.get(ch);
        if (cat == Cn || cat == Cc || cat == Co) return false;
        if (cat == Cs || cat == Zl || cat == Zp) return false;
        in += Character.charCount(ch);
        return true;
    }

    // visibles = visible*
    private boolean visibles() {
        return OPT(GO() && visible() && visibles());
    }

    // alpha = letter / Nd / '_' / '-'
    private boolean alpha() {
        return letter() || CAT(Nd) || CHAR('_') || CHAR('-');
    }

    // alphas = alpha*
    private boolean alphas() {
        return OPT(GO() && alpha() && alphas());
    }

    // letter = Lu / Ll / Lt / Lm / Lo
    private boolean letter() {
        if (in >= input.length()) return false;
        int ch = input.codePointAt(in);
        Category cat = Category.get(ch);
        boolean ok = (
            cat == Lu || cat == Ll || cat == Lt || cat == Lm || cat == Lo
        );
        if (ok) in += Character.charCount(ch);
        return ok;
    }

    // initial = #letter letter
    private boolean initial() {
        return MARK(LETTER) && letter();
    }

    // decimal = '0..9'
    private boolean decimal() {
        return RANGE('0', '9');
    }

    // decimals = decimal*
    private boolean decimals() {
        return OPT(GO() && decimal() && decimals());
    }

    // hex = decimal / 'ABCDEFabcdef'
    private boolean hex() {
        return ALT(GO() && decimal() || OR() && SET("ABCDEFabcdef"));
    }

    // hexes = hex*
    private boolean hexes() {
        return OPT(GO() && hex() && hexes());
    }

    // digits = ('1..9' decimals) / '0' hexes
    private boolean digits() {
        return ALT(
            GO() && RANGE('1','9') && decimals() || OR() && CHAR('0') && hexes()
        );
    }

    // noquote = "'"! visible
    private boolean noquote() {
        return NOT(GO() && CHAR('\'')) && visible();
    }

    // noquotes = ("'"! visible)*
    private boolean noquotes() {
        return OPT(GO() && NOT(GO() && CHAR('\'')) && visible() && noquotes());
    }

    // nodquotes = ('"'! visible)*
    private boolean nodquotes() {
        return OPT(GO() && NOT(GO() && CHAR('"')) && visible() && nodquotes());
    }

    // nobquotes = ("`"! visible)*
    private boolean nobquotes() {
        return OPT(GO() && NOT(GO() && CHAR('`')) && visible() && nobquotes());
    }

    // noangles = ('>'! visible)*
    private boolean noangles() {
        return OPT(GO() && NOT(GO() && CHAR('>')) && visible() && noangles());
    }

    // endline = 13? 10
    private boolean endline() {
        return (CHAR('\r') || true) && CHAR('\n');
    }

    // ---------- Support functions --------------------------------------------

    // Prepare for a choice or lookahead by recording the input position.
    private boolean GO() {
        if (save >= saves.length) {
            saves = Arrays.copyOf(saves, saves.length * 2);
        }
        saves[save++] = in;
        return true;
    }

    // Check an alternative to see whether to try the next one.
    private boolean OR() {
        return in == saves[save-1];
    }

    // Check the result of a choice and pop the saved position.
    private boolean ALT(boolean b) {
        --save;
        return b;
    }

    // Pop saved position, make the result success if fail with no progress
    private boolean OPT(boolean b) {
        --save;
        return b || in == saves[save];
    }

    // Backtrack to saved position.
    private boolean HAS(boolean b) {
        in = saves[--save];
        return b;
    }

    // Backtrack to saved position and negate result.
    private boolean NOT(boolean b) {
        in = saves[--save];
        return !b;
    }

    // Backtrack on failure.
    private boolean TRY(boolean b) {
        if (b) --save;
        else in = saves[--save];
        return b;
    }

    // Record an error marker for the current input position.
    private boolean MARK(Marker m) {
        if (look > 0) return true;
        if (marked > in) throw new Error("marked " + marked + " in " + in);
        if (marked < in) {
            markers.clear();
            marked = in;
        }
        markers.add(m);
        return true;
    }

    // Nd
    private boolean CAT(Category c) {
        if (in >= input.length()) return false;
        int ch = input.codePointAt(in);
        Category cat = Category.get(ch);
        if (cat != c) return false;
        in += Character.charCount(ch);
        return true;
    }

    // Check if a character (ascii) appears next in the input.
    private boolean CHAR(char ch) {
        if (in >= input.length()) return false;
        if (input.charAt(in) != ch) return false;
        in++;
        return true;
    }

    // Check if a character (ascii) in a given range appears next in the input.
    private boolean RANGE(char first, char last) {
        if (in >= input.length()) return false;
        if (input.charAt(in) < first || input.charAt(in) > last) return false;
        in++;
        return true;
    }

    // Check for the given (ascii) string next in the input.
    private boolean STRING(String s) {
        if (in + s.length() > input.length()) return false;
        for (int i = 0; i < s.length(); i++) {
            if (input.charAt(in + i) != s.charAt(i)) return false;
        }
        in += s.length();
        return true;
    }

    // Check if a character (ascii) in a given range appears next in the input.
    private boolean SET(String s) {
        if (in >= input.length()) return false;
        char ch = input.charAt(in);
        boolean found = false;
        for (int i = 0; i < s.length() && ! found; i++) {
            if (ch == s.charAt(i)) found = true;
        }
        if (found) in++;
        return found;
    }

    // Return the next character in the input.
    private char NEXT() {
        if (in >= input.length()) return '\0';
        return input.charAt(in);
    }

    private boolean END() {
        return in >= input.length();
    }

    // @
    private boolean ACT() {
        if (look > 0) return true;
        start = in;
        return true;
    }

    // @a
    private boolean ACT(Op op) {
        if (look > 0) return true;
        if (out >= output.length) {
            output = Arrays.copyOf(output, output.length * 2);
        }
        output[out++] = new Node(op, input, start, in);
        start = in;
        return true;
    }

    // @1a
    private boolean ACT1(Op op) {
        if (look > 0) return true;
        start = in;
        Node x = output[--out];
        Node y = new Node(op, x, input, x.start(), x.end());
        output[out++] = y;
        return true;
    }

    // @2a
    private boolean ACT2(Op op) {
        if (look > 0) return true;
        start = in;
        Node y = output[--out];
        Node x = output[--out];
        Node r = new Node(op, x, y, input, x.start(), y.end());
        output[out++] = r;
        return true;
    }

    // @3a used for bracketed subexpressions (x) or [x], discarding brackets.
    private boolean ACT3(Op op) {
        if (look > 0) return true;
        start = in;
        Node close = output[--out];
        Node x = output[--out];
        Node open = output[--out];
        Node y = new Node(op, x, input, open.start(), close.end());
        output[out++] = y;
        return true;
    }

    // Produce an error message from the markers at the current input position.
    private String message() {
        if (markers.size() == 0) return "";
        String s = "expecting ";
        boolean first = true;
        for (Marker m : markers) {
            if (! first) s = s + ", ";
            first = false;
            s = s + m.toString().toLowerCase().replaceAll("_"," ");
        }
        return s;
    }

    // Remove postfix operator, bracket, and bracketed expression nodes.
    private Node prune(Node r) {
        if (r == null) return null;
        Op op = r.op();
        r.left(prune(r.left()));
        r.right(prune(r.right()));
        if (r.right() != null && r.right().op() == Temp) r.right(null);
        if (op == Temp) return r.left();
        return r;
    }
}
