// One rule
x = "a"
----------
Rule x
  Char "a" 97
==========
// One call action
x = "x" @1act
----------
Rule x
  And "x" @1act
    Char "x" 120
    Act @1act
==========
// A divider
x = <abc> "y" / "z"
----------
Rule x
  Or <abc> "y" / "z"
    And <abc> "y"
      Divider <abc>
      Char "y" 121
    Char "z" 122
==========
// A token parser
x = %t
----------
Rule x
  Tag %t
==========
// Brackets
exp = (exp) END
END = 10
----------
Rule exp
  And (exp) END
    Id exp
    Id END
Rule END
  Char 10 10
==========
// Set with duplicate character
s = 'abcdefcghi'
----------
Error on line 2: set contains duplicate character
s = 'abcdefcghi'
    ^^^^^^^^^^^^
==========
// Number too big
m = 1114111
n = 1114112
----------
Error on line 3: number too big
n = 1114112
    ^^^^^^^
==========
// Number too big
m = 010ffff
n = 0110000
----------
Error on line 3: number too big
n = 0110000
    ^^^^^^^
==========
// Unicode supplementary characters (beyond 16 bits), 195101 = last letter.
char = "\195101"
x = "x"
----------
Rule char
  Char "\195101" 195101
Rule x
  Char "x" 120
==========
// Bad range
s = 'ab..c'
----------
Error on line 2: range must have one character at each end
s = 'ab..c'
    ^^^^^^^
==========
// Bad range
s = 'a..bc'
----------
Error on line 2: range must have one character at each end
s = 'a..bc'
    ^^^^^^^
==========
// Bad range
s = '..a'
----------
Error on line 2: range must have one character at each end
s = '..a'
    ^^^^^
==========
// Bad range
s = 'a..'
----------
Error on line 2: range must have one character at each end
s = 'a..'
    ^^^^^
==========
// Bad range
s = 'b..a'
----------
Error on line 2: empty range
s = 'b..a'
    ^^^^^^
==========
// Bad range
s = 33..32
----------
Error on line 2: empty range
s = 33..32
    ^^^^^^
==========
// Just OK range
s = 33..33
----------
Rule s
  Range 33..33
    Char 33 33
    Char 33 33
==========
// Name clash
x = @2add @3add
----------
Error on line 2: clashes with @2add
x = @2add @3add
          ^^^^^
==========
// Complete scanner/parser grammar for sums
exp = term ("+" term @2add / "-" term @2sub)* ''
term = factor ("*" factor @2mul / "/" factor @2div)*
factor = primary ("^" factor @2pow)?
primary = number / "(" exp ")"
number = digit+ @number
digit = '0123456789'
----------
Rule exp
  And term ("+" term @2add / "-" term @2sub)* ''
    Id term
    Any ("+" term @2add / "-" term @2sub)*
      Or "+" term @2add / "-" term @2sub
        And "+" term @2add
          Char "+" 43
          Id term
          Act @2add
        And "-" term @2sub
          Char "-" 45
          Id term
          Act @2sub
    Set ''
Rule term
  And factor ("*" factor @2mul / "/" factor @2div)*
    Id factor
    Any ("*" factor @2mul / "/" factor @2div)*
      Or "*" factor @2mul / "/" factor @2div
        And "*" factor @2mul
          Char "*" 42
          Id factor
          Act @2mul
        And "/" factor @2div
          Char "/" 47
          Id factor
          Act @2div
Rule factor
  And primary ("^" factor @2pow)?
    Id primary
    Opt ("^" factor @2pow)?
      And "^" factor @2pow
        Char "^" 94
        Id factor
        Act @2pow
Rule primary
  Or number / "(" exp ")"
    Id number
    And "(" exp ")"
      Char "(" 40
      Id exp
      Char ")" 41
Rule number
  And digit+ @number
    Some digit+
      Id digit
    Act @number
Rule digit
  Set '0123456789'
==========
// Unknown rule name
x = z
y = "a"
----------
Error on line 2: unknown name
x = z
    ^
==========
// Duplicate rule names
x = "x"
y = "y"
x = "z"
----------
Error on line 4: x is already defined
x = "z"
^
==========
// Example sum3.pecan
sum = number / number "+" number @2add
number = ('0123456789')+ @read
----------
Rule sum
  Or number / number "+" number @2add
    Id number
    And number "+" number @2add
      Id number
      Char "+" 43
      Id number
      Act @2add
Rule number
  And ('0123456789')+ @read
    Some ('0123456789')+
      Set '0123456789'
    Act @read
==========
// Error handling
string = '"' visible* #badstring '"'
visible = "x"
----------
Rule string
  And '"' visible* #badstring '"'
    Char '"' 34
    Any visible*
      Id visible
    Mark #badstring
    Char '"' 34
Rule visible
  Char "x" 120
==========
// Unicode category
upper = Lu
----------
Rule upper
  Cat Lu
==========
// Attempt to redefine category
Lu = 'x'
----------
Error on line 2: Lu is a unicode id
Lu = 'x'
^^
==========
// Number too big
big = 1114112
----------
Error on line 2: number too big
big = 1114112
      ^^^^^^^
==========
// Complete scanner for pecan itself
tokens = skip token*
token = id / number / set / string / matcher / action / handler / key / bad
id = name @Id skip1
number = ('0' hex* / digit+) @Char skip1
set = "'" ("'"! visible)* #BADSet "'" @Set skip1
string = '"' ('"'! visible)* #BADString '"' @String skip1
matcher = "%" name @MATCH skip1
action = "@" (digit+ name @Act / name @READ / @Drop) skip1
handler = "#" name @HAndLE skip1
key = prefix skip2 / infix skip2 / postfix skip1
prefix = "(" @RB / "[" @SB / "<" @AB
infix = "=" @Id / "/" @SL / ".." @DD
postfix = "!" @EM / "?" @QM / "+" @PL / "*" @ST / ")" @RE / "]" @SE / ">" @AE
bad =  #BADSet Uc skip1
skip = (space / comment / newline)* @
skip1 = space @ (newline ([space (letter / newline)] @NL)? skip)?
skip2 = space (newline space)? @
name = letter alpha*
hex = digit / 'A..F' / 'a..f'
digit = '0..9'
letter = 'A..Z' / 'a..z'
alpha = letter / digit / '_-'
newline = 10 / 133 / 8232 / 13 10 / 13 133 / 13
visible = ' ..~'
comment = "//" visible*
space = " "*
----------
Rule tokens
  And skip token*
    Id skip
    Any token*
      Id token
Rule token
  Or id / number / set / string / matcher / action / handler / key / bad
    Id id
    Id number
    Id set
    Id string
    Id matcher
    Id action
    Id handler
    Id key
    Id bad
Rule id
  And name @Id skip1
    Id name
    Act @Id
    Id skip1
Rule number
  And ('0' hex* / digit+) @Char skip1
    Or '0' hex* / digit+
      And '0' hex*
        Char '0' 48
        Any hex*
          Id hex
      Some digit+
        Id digit
    Act @Char
    Id skip1
Rule set
  And "'" ("'"! visible)* #BADSet "'" @Set skip1
    Char "'" 39
    Any ("'"! visible)*
      And "'"! visible
        Not "'"!
          Char "'" 39
        Id visible
    Mark #BADSet
    Char "'" 39
    Act @Set
    Id skip1
Rule string
  And '"' ('"'! visible)* #BADString '"' @String skip1
    Char '"' 34
    Any ('"'! visible)*
      And '"'! visible
        Not '"'!
          Char '"' 34
        Id visible
    Mark #BADString
    Char '"' 34
    Act @String
    Id skip1
Rule matcher
  And "%" name @MATCH skip1
    Char "%" 37
    Id name
    Act @MATCH
    Id skip1
Rule action
  And "@" (digit+ name @Act / name @READ / @Drop) skip1
    Char "@" 64
    Or digit+ name @Act / name @READ / @Drop
      And digit+ name @Act
        Some digit+
          Id digit
        Id name
        Act @Act
      And name @READ
        Id name
        Act @READ
      Act @Drop
    Id skip1
Rule handler
  And "#" name @HAndLE skip1
    Char "#" 35
    Id name
    Act @HAndLE
    Id skip1
Rule key
  Or prefix skip2 / infix skip2 / postfix skip1
    And prefix skip2
      Id prefix
      Id skip2
    And infix skip2
      Id infix
      Id skip2
    And postfix skip1
      Id postfix
      Id skip1
Rule prefix
  Or "(" @RB / "[" @SB / "<" @AB
    And "(" @RB
      Char "(" 40
      Act @RB
    And "[" @SB
      Char "[" 91
      Act @SB
    And "<" @AB
      Char "<" 60
      Act @AB
Rule infix
  Or "=" @Id / "/" @SL / ".." @DD
    And "=" @Id
      Char "=" 61
      Act @Id
    And "/" @SL
      Char "/" 47
      Act @SL
    And ".." @DD
      String ".."
      Act @DD
Rule postfix
  Or "!" @EM / "?" @QM / "+" @PL / "*" @ST / ")" @RE / "]" @SE / ">" @AE
    And "!" @EM
      Char "!" 33
      Act @EM
    And "?" @QM
      Char "?" 63
      Act @QM
    And "+" @PL
      Char "+" 43
      Act @PL
    And "*" @ST
      Char "*" 42
      Act @ST
    And ")" @RE
      Char ")" 41
      Act @RE
    And "]" @SE
      Char "]" 93
      Act @SE
    And ">" @AE
      Char ">" 62
      Act @AE
Rule bad
  And #BADSet Uc skip1
    Mark #BADSet
    Cat Uc
    Id skip1
Rule skip
  And (space / comment / newline)* @
    Any (space / comment / newline)*
      Or space / comment / newline
        Id space
        Id comment
        Id newline
    Drop @
Rule skip1
  And space @ (newline ([space (letter / newline)] @NL)? skip)?
    Id space
    Drop @
    Opt (newline ([space (letter / newline)] @NL)? skip)?
      And newline ([space (letter / newline)] @NL)? skip
        Id newline
        Opt ([space (letter / newline)] @NL)?
          And [space (letter / newline)] @NL
            Try [space (letter / newline)]
              And space (letter / newline)
                Id space
                Or letter / newline
                  Id letter
                  Id newline
            Act @NL
        Id skip
Rule skip2
  And space (newline space)? @
    Id space
    Opt (newline space)?
      And newline space
        Id newline
        Id space
    Drop @
Rule name
  And letter alpha*
    Id letter
    Any alpha*
      Id alpha
Rule hex
  Or digit / 'A..F' / 'a..f'
    Id digit
    Range 'A..F'
      Char 'A. 65
      Char .F' 70
    Range 'a..f'
      Char 'a. 97
      Char .f' 102
Rule digit
  Range '0..9'
    Char '0. 48
    Char .9' 57
Rule letter
  Or 'A..Z' / 'a..z'
    Range 'A..Z'
      Char 'A. 65
      Char .Z' 90
    Range 'a..z'
      Char 'a. 97
      Char .z' 122
Rule alpha
  Or letter / digit / '_-'
    Id letter
    Id digit
    Set '_-'
Rule newline
  Or 10 / 133 / 8232 / 13 10 / 13 133 / 13
    Char 10 10
    Char 133 133
    Char 8232 8232
    And 13 10
      Char 13 13
      Char 10 10
    And 13 133
      Char 13 13
      Char 133 133
    Char 13 13
Rule visible
  Range ' ..~'
    Char ' . 32
    Char .~' 126
Rule comment
  And "//" visible*
    String "//"
    Any visible*
      Id visible
Rule space
  Any " "*
    Char " " 32
