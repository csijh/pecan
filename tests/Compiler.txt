-- Single matcher
x = 'a'
..........
// x = 'a'
bool x() { return CHAR('a'); }
==========
-- Sequence
x = 'a' 'b'
..........
// x = 'a' 'b'
bool x() { return CHAR('a') && CHAR('b'); }
==========
-- Simple choice (LHS doesn't have FP)
x = 'a' / 'b'
..........
// x = 'a' / 'b'
bool x() { return CHAR('a') || CHAR('b'); }
==========
-- General choice (LHS does have FP)
x = 'a' 'b' / 'c'
..........
// x = 'a' 'b' / 'c'
bool x() { return ALT(DO() && CHAR('a') && CHAR('b') || OR() && CHAR('c')); }
==========
-- Option
x = 'a'?
..........
// x = 'a'?
bool x() { return (CHAR('a') || true); }
==========
-- Long sequence
x = 'a' 'b' 'c' 'd' 'e' 'f' 'g'
..........
// x = 'a' 'b' 'c' 'd' 'e' 'f' 'g'
bool x() {
    return CHAR('a') && CHAR('b') && CHAR('c') && CHAR('d') && CHAR('e') &&
    CHAR('f') && CHAR('g');
}
==========
-- Long choice
x = 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g'
..........
// x = 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g'
bool x() {
    return CHAR('a') || CHAR('b') || CHAR('c') || CHAR('d') || CHAR('e') ||
    CHAR('f') || CHAR('g');
}
==========
-- Long complex choice
x = 'a' '1' / 'b' / 'c' / 'd' / 'e' '2' / 'f' / 'g'
..........
// x = 'a' '1' / 'b' / 'c' / 'd' / 'e' '2' / 'f' / 'g'
bool x() {
    return ALT(
        DO() && CHAR('a') && CHAR('1') ||
        OR() && CHAR('b') ||
        CHAR('c') ||
        CHAR('d') ||
        CHAR('e') && CHAR('2') ||
        OR() && CHAR('f') ||
        CHAR('g')
    );
}
==========
-- Multiline comment
x = 'a' '1' / 'b' /
    'c' / 'd' / 'e' '2' /
    'f' / 'g'
..........
// x = 'a' '1' / 'b' /
//     'c' / 'd' / 'e' '2' /
//     'f' / 'g'
bool x() {
    return ALT(
        DO() && CHAR('a') && CHAR('1') ||
        OR() && CHAR('b') ||
        CHAR('c') ||
        CHAR('d') ||
        CHAR('e') && CHAR('2') ||
        OR() && CHAR('f') ||
        CHAR('g')
    );
}
==========
-- Simple try
x = ['a']
..........
// x = ['a']
bool x() { return TRY(DO() && CHAR('a')); }
==========
-- Complex try
x = ['a' @a]
..........
// x = ['a' @a]
bool x() { return HAS(DO() && CHAR('a') && ACT(a)) && CHAR('a') && ACT(a); }
==========
-- Two rules
x = 'a'
y = 'b'
..........
// x = 'a'
bool x() { return CHAR('a'); }

// y = 'b'
bool y() { return CHAR('b'); }
==========
-- Action
x = 'a' @a
..........
// x = 'a' @a
bool x() { return CHAR('a') && ACT(a); }
==========
-- Lift out * loop
x = 'a' 'b'*
..........
// x1 = ('b' x1)?
bool x1() { return (CHAR('b') && x1() || true); }

// x = 'a' 'b'*
bool x() { return CHAR('a') && x1(); }
==========
-- Lift out + loop
x = 'a' 'b'+
..........
// x1 = ('b') x1?
bool x1() { return CHAR('b') && (x1() || true); }

// x = 'a' 'b'+
bool x() { return CHAR('a') && x1(); }
==========
sum = gap expression end
expression = term (plus term @2add / minus term @2subtract)*
term = atom (times atom @2multiply / over atom @2divide)*
atom = number / open expression close
number = digit+ @number gap
plus = #operator '+' gap
minus = #operator '-' gap
times = #operator '*' gap
over = #operator '/' gap
open = #bracket '(' gap
close = #bracket ')' gap
digit = #digit '0..9'
gap = (' ')* @
end = #newline 13? 10 @
..........
// sum = gap expression end
bool sum() { return gap() && expression() && end(); }

// expression1 = (plus term @2add / minus term @2subtract expression1)?
bool expression1() {
    return ((ALT(
        DO() && plus() && term() && ACT2(add) ||
        OR() && minus() && term() && ACT2(subtract)
    )) && expression1() || true);
}

// expression = term (plus term @2add / minus term @2subtract)*
bool expression() { return term() && expression1(); }

// term1 = (times atom @2multiply / over atom @2divide term1)?
bool term1() {
    return ((ALT(
        DO() && times() && atom() && ACT2(multiply) ||
        OR() && over() && atom() && ACT2(divide)
    )) && term1() || true);
}

// term = atom (times atom @2multiply / over atom @2divide)*
bool term() { return atom() && term1(); }

// atom = number / open expression close
bool atom() { return number() || open() && expression() && close(); }

// number1 = (digit) number1?
bool number1() { return digit() && (number1() || true); }

// number = digit+ @number gap
bool number() { return number1() && ACT(number) && gap(); }

// plus = #operator '+' gap
bool plus() { return MARK(operator) && CHAR('+') && gap(); }

// minus = #operator '-' gap
bool minus() { return MARK(operator) && CHAR('-') && gap(); }

// times = #operator '*' gap
bool times() { return MARK(operator) && CHAR('*') && gap(); }

// over = #operator '/' gap
bool over() { return MARK(operator) && CHAR('/') && gap(); }

// open = #bracket '(' gap
bool open() { return MARK(bracket) && CHAR('(') && gap(); }

// close = #bracket ')' gap
bool close() { return MARK(bracket) && CHAR(')') && gap(); }

// digit = #digit '0..9'
bool digit() { return MARK(digit) && RANGE('0','9'"); }

// gap1 = (' ' gap1)?
bool gap1() { return (CHAR(' ') && gap1() || true); }

// gap = (' ')* @
bool gap() { return gap1() && DROP(0); }

// end = #newline 13? 10 @
bool end() {
    return MARK(newline) && (CODE(13) || true) && CODE(10) && DROP(0);
}
