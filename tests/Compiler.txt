-- Single matcher
x = 'a'
..........
// x = 'a'
bool x() { return text("a"); }
==========
-- Sequence
x = 'a' 'b'
..........
// x = 'a' 'b'
bool x() { return text("a") && text("b"); }
==========
-- Simple choice (LHS doesn't have FP)
x = 'a' / 'b'
..........
// x = 'a' / 'b'
bool x() { return text("a") || text("b"); }
==========
-- General choice (LHS does have FP)
x = 'a' 'b' / 'c'
..........
// x = 'a' 'b' / 'c'
bool x() {
    return alt((go() && text("a") && text("b")) || (ok() && text("c")));
}
==========
-- Option
x = 'a'?
..........
// x = 'a'?
bool x() { return (text("a") || true); }
==========
-- Long sequence
x = 'a' 'b' 'c' 'd' 'e' 'f' 'g'
..........
// x = 'a' 'b' 'c' 'd' 'e' 'f' 'g'
bool x() {
    return text("a") && text("b") && text("c") && text("d") && text("e") &&
    text("f") && text("g");
}
==========
-- Long choice
x = 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g'
..........
// x = 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g'
bool x() {
    return text("a") || text("b") || text("c") || text("d") || text("e") ||
    text("f") || text("g");
}
==========
-- Long complex choice
x = 'a' '1' / 'b' / 'c' / 'd' / 'e' '2' / 'f' / 'g'
..........
// x = 'a' '1' / 'b' / 'c' / 'd' / 'e' '2' / 'f' / 'g'
bool x() {
    return alt(
        (go() && text("a") && text("1")) ||
        (ok() && text("b")) ||
        text("c") ||
        text("d") ||
        (text("e") && text("2")) ||
        (ok() && text("f")) ||
        text("g")
    );
}
==========
-- Multiline comment
x = 'a' '1' / 'b' /
    'c' / 'd' / 'e' '2' /
    'f' / 'g'
..........
// x = 'a' '1' / 'b' /
//     'c' / 'd' / 'e' '2' /
//     'f' / 'g'
bool x() {
    return alt(
        (go() && text("a") && text("1")) ||
        (ok() && text("b")) ||
        text("c") ||
        text("d") ||
        (text("e") && text("2")) ||
        (ok() && text("f")) ||
        text("g")
    );
}
==========
-- Simple see
x = ['a']
..........
// x = ['a']
bool x() { return see(go() && text("a")); }
==========
-- Complex see
x = ['a' @a]
..........
// x = ['a' @a]
bool x() { return has(go() && text("a") && act0(a)) && text("a") && act0(a); }
==========
-- Two rules
x = 'a'
y = 'b'
..........
// x = 'a'
bool x() { return text("a"); }

// y = 'b'
bool y() { return text("b"); }
==========
-- Action
x = 'a' @a
..........
// x = 'a' @a
bool x() { return text("a") && act0(a); }
==========
-- Lift out * loop
x = 'a' 'b'*
..........
// x1 = ('b' x1)?
bool x1() { return ((text("b") && x1()) || true); }

// x = 'a' 'b'*
bool x() { return text("a") && x1(); }
==========
-- Lift out + loop
x = 'a' 'b'+
..........
// x1 = ('b') x1?
bool x1() { return text("b") && (x1() || true); }

// x = 'a' 'b'+
bool x() { return text("a") && x1(); }
==========
sum = gap expression end
expression = term (plus term @2add / minus term @2subtract)*
term = atom (times atom @2multiply / over atom @2divide)*
atom = number / open expression close
number = #integer digit+ @number gap
plus = #operator '+' gap
minus = #operator '-' gap
times = #operator '*' gap
over = #operator '/' gap
open = #bracket '(' gap
close = #bracket ')' gap
digit = '0..9'
gap = (' ')* @
end = #newline '\13'? '\10' @
..........
// sum = gap expression end
bool sum() { return gap() && expression() && end(); }

// expression1 = (plus term @2add / minus term @2subtract expression1)?
bool expression1() {
    return (((alt(
        (go() && plus() && term() && act2(add)) ||
        (ok() && minus() && term() && act2(subtract))
    )) && expression1()) || true);
}

// expression = term (plus term @2add / minus term @2subtract)*
bool expression() { return term() && expression1(); }

// term1 = (times atom @2multiply / over atom @2divide term1)?
bool term1() {
    return (((alt(
        (go() && times() && atom() && act2(multiply)) ||
        (ok() && over() && atom() && act2(divide))
    )) && term1()) || true);
}

// term = atom (times atom @2multiply / over atom @2divide)*
bool term() { return atom() && term1(); }

// atom = number / open expression close
bool atom() { return number() || (open() && expression() && close()); }

// number1 = (digit) number1?
bool number1() { return digit() && (number1() || true); }

// number = #integer digit+ @number gap
bool number() { return mark(integer) && number1() && act0(number) && gap(); }

// plus = #operator '+' gap
bool plus() { return mark(operator) && text("+") && gap(); }

// minus = #operator '-' gap
bool minus() { return mark(operator) && text("-") && gap(); }

// times = #operator '*' gap
bool times() { return mark(operator) && text("*") && gap(); }

// over = #operator '/' gap
bool over() { return mark(operator) && text("/") && gap(); }

// open = #bracket '(' gap
bool open() { return mark(bracket) && text("(") && gap(); }

// close = #bracket ')' gap
bool close() { return mark(bracket) && text(")") && gap(); }

// digit = '0..9'
bool digit() { return range('0','9'); }

// gap1 = (' ' gap1)?
bool gap1() { return ((text(" ") && gap1()) || true); }

// gap = (' ')* @
bool gap() { return gap1() && drop(0); }

// end = #newline '\13'? '\10' @
bool end() {
    return mark(newline) && (text("\015") || true) && text("\012") && drop(0);
}
