// One-liner
x = x
----------
Rule x
  Id x
==========
// Choice
x = x / x
----------
Rule x
  Or x / x
    Id x
    Id x
==========
// Bracket
x = (y / z)
----------
Rule x
  Or y / z
    Id y
    Id z
==========
----------
Error on line 1: expecting newline, atom

^
==========
// Expecting =
x
----------
Error on line 2: expecting equals
x
 ^
==========
// Normal \n line endings
x = x
y = y
---------
Rule x
  Id x
Rule y
  Id y
==========
// Windows \r\n line endings
x=x\13\10\
y=y\13\10\
----------
Rule x
  Id x
Rule y
  Id y
==========
// Line containing only spaces is a comment
// comment

x = x
----------
Rule x
  Id x
==========
// Trailing spaces
x = x    \10
         \10
y = y    \10
----------
Rule x
  Id x
Rule y
  Id y
==========
// Trailing blank line
x = x
y = y

----------
Rule x
  Id x
Rule y
  Id y
==========
// Trailing blank lines
x = x
y = y


----------
Rule x
  Id x
Rule y
  Id y
==========
// No final newline
x = x
y = y\
----------
Error on line 3: expecting newline, atom
y = y
     ^
==========
// No final newline
x = x
// comment\
----------
Error on line 3: expecting newline
// comment
          ^
==========
// Varied comments and empty lines
// initial comment

x = y

// middle comment
y = z

// end comment
----------
Rule x
  Id y
Rule y
  Id z
==========
// Scanner error
x = |y|
----------
Error on line 2: expecting newline, atom
x = |y|
    ^
==========
// Incomplete string
x = "abc
----------
Error on line 2: expecting quote
x = "abc
        ^
==========
// Incomplete set
x = 'abc
----------
Error on line 2: expecting quote
x = 'abc
        ^
==========
// One rule
x = "a"
----------
Rule x
  String "a"
==========
// Two rules
x = "a"
y = "b"
----------
Rule x
  String "a"
Rule y
  String "b"
==========
// Expecting equals
x
----------
Error on line 2: expecting equals
x
 ^
==========
// Expecting atom
x = /
----------
Error on line 2: expecting newline, atom
x = /
    ^
==========
// Missing close bracket
x = (y
y = z
----------
Error on line 2: expecting bracket, atom
x = (y
      ^
==========
// Dot in the wrong place
x = .
----------
Error on line 2: expecting newline, atom
x = .
    ^
==========
// Incomplete dot dot
x = 0.
----------
Error on line 2: expecting dot
x = 0.
      ^
==========
// Incomplete action
x = @3
----------
Error on line 2: expecting letter
x = @3
      ^
==========
// Tag
x = %x
----------
Rule x
  Tag %x
==========
// Bad marker
x = 'x' #3
----------
Error on line 2: expecting letter
x = 'x' #3
         ^
==========
// Continuation lines
x =
y /
z
x =
(
a) [
c]
x
= y
/ z
x
= y (a
) [c
]
----------
Rule x
  Or y /...
    Id y
    Id z
Rule x
  And (...
    Id a
    Try [...
      Id c
Rule x
  Or y...
    Id y
    Id z
Rule x
  And y (a...
    Id y
    Id a
    Try [c...
      Id c
==========
// Brackets
exp = (exp) end
exp = [exp] end
----------
Rule exp
  And (exp) end
    Id exp
    Id end
Rule exp
  And [exp] end
    Try [exp]
      Id exp
    Id end
==========
// The + * ? postfix operators
exp = exp* exp+ exp? end
----------
Rule exp
  And exp* exp+ exp? end
    Any exp*
      Id exp
    Some exp+
      Id exp
    Opt exp?
      Id exp
    Id end
==========
// Complete scan-parser grammar for sums
exp = term ("+" term @2add / "-" term @2sub)* ''
term = factor ("*" factor @2mul / "/" factor @2div)*
factor = primary ("^" factor @2pow)?
primary = number / "(" exp ")"
number = digit+ @number
digit = '0123456789'
----------
Rule exp
  And term ("+" term @2add / "-" term @2sub)* ''
    Id term
    Any ("+" term @2add / "-" term @2sub)*
      Or "+" term @2add / "-" term @2sub
        And "+" term @2add
          String "+"
          Id term
          Act @2add
        And "-" term @2sub
          String "-"
          Id term
          Act @2sub
    Set ''
Rule term
  And factor ("*" factor @2mul / "/" factor @2div)*
    Id factor
    Any ("*" factor @2mul / "/" factor @2div)*
      Or "*" factor @2mul / "/" factor @2div
        And "*" factor @2mul
          String "*"
          Id factor
          Act @2mul
        And "/" factor @2div
          String "/"
          Id factor
          Act @2div
Rule factor
  And primary ("^" factor @2pow)?
    Id primary
    Opt ("^" factor @2pow)?
      And "^" factor @2pow
        String "^"
        Id factor
        Act @2pow
Rule primary
  Or number / "(" exp ")"
    Id number
    And "(" exp ")"
      String "("
      Id exp
      String ")"
Rule number
  And digit+ @number
    Some digit+
      Id digit
    Act @number
Rule digit
  Set '0123456789'
==========
// Error markers
assignment = left #equals "=" right
----------
Rule assignment
  And left #equals "=" right
    Id left
    Mark #equals
    String "="
    Id right
==========
// Error on line 3
x = y /
z / /
----------
Error on line 3: expecting newline, atom
z / /
    ^
==========
// Line 1 of scanner for pecan itself
tokens = skip token*
----------
Rule tokens
  And skip token*
    Id skip
    Any token*
      Id token
==========
// Next line of pecan scanner
token = number / id / string / set / matcher / action / handler / key
----------
Rule token
  Or number / id / string / set / matcher / action / handler / key
    Id number
    Id id
    Id string
    Id set
    Id matcher
    Id action
    Id handler
    Id key
==========
// Next line of pecan scanner
number = ('0' hex* / digit+) @NUMBER skip1
----------
Rule number
  And ('0' hex* / digit+) @NUMBER skip1
    Or '0' hex* / digit+
      And '0' hex*
        Set '0'
        Any hex*
          Id hex
      Some digit+
        Id digit
    Act @NUMBER
    Id skip1
==========
// Next line of pecan scanner
id = name @Id skip1
----------
Rule id
  And name @Id skip1
    Id name
    Act @Id
    Id skip1
==========
// Next line of pecan scanner
string = '"' ('"'! visible)* #BADString '"' @String skip1
----------
Rule string
  And '"' ('"'! visible)* #BADString '"' @String skip1
    Set '"'
    Any ('"'! visible)*
      And '"'! visible
        Not '"'!
          Set '"'
        Id visible
    Mark #BADString
    Set '"'
    Act @String
    Id skip1
==========
// Next line of pecan scanner
set = "'" ("'"! visible)* #BADSet "'" @Set skip1
----------
Rule set
  And "'" ("'"! visible)* #BADSet "'" @Set skip1
    String "'"
    Any ("'"! visible)*
      And "'"! visible
        Not "'"!
          String "'"
        Id visible
    Mark #BADSet
    String "'"
    Act @Set
    Id skip1
==========
// Next line of pecan scanner
action = "@" (digit+ name @Act / name @READ / @Drop) skip1
----------
Rule action
  And "@" (digit+ name @Act / name @READ / @Drop) skip1
    String "@"
    Or digit+ name @Act / name @READ / @Drop
      And digit+ name @Act
        Some digit+
          Id digit
        Id name
        Act @Act
      And name @READ
        Id name
        Act @READ
      Act @Drop
    Id skip1
==========
// Next line of pecan scanner
handler = "#" name @HAndLE skip1
----------
Rule handler
  And "#" name @HAndLE skip1
    String "#"
    Id name
    Act @HAndLE
    Id skip1
==========
// Next line of pecan scanner
key
= "!" @EM skip1 / "=" @Rule skip2 / "/" @SL skip2 / "?" @QM skip1
/ "+" @PL skip1 / "*" @ST skip1 / "(" @RB skip2 / ")" @RE skip1
/ "[" @SB skip2 / "]" @SE skip1 / "<" @AB skip2 / ">" @AE skip1
/ ".." @DD skip2
/ #BADSet Uc skip1
----------
Rule key
  Or "!" @EM skip1 / "=" @Rule skip2 / "/" @SL skip2 / "?" @QM skip1...
    And "!" @EM skip1
      String "!"
      Act @EM
      Id skip1
    And "=" @Rule skip2
      String "="
      Act @Rule
      Id skip2
    And "/" @SL skip2
      String "/"
      Act @SL
      Id skip2
    And "?" @QM skip1
      String "?"
      Act @QM
      Id skip1
    And "+" @PL skip1
      String "+"
      Act @PL
      Id skip1
    And "*" @ST skip1
      String "*"
      Act @ST
      Id skip1
    And "(" @RB skip2
      String "("
      Act @RB
      Id skip2
    And ")" @RE skip1
      String ")"
      Act @RE
      Id skip1
    And "[" @SB skip2
      String "["
      Act @SB
      Id skip2
    And "]" @SE skip1
      String "]"
      Act @SE
      Id skip1
    And "<" @AB skip2
      String "<"
      Act @AB
      Id skip2
    And ">" @AE skip1
      String ">"
      Act @AE
      Id skip1
    And ".." @DD skip2
      String ".."
      Act @DD
      Id skip2
    And #BADSet Uc skip1
      Mark #BADSet
      Id Uc
      Id skip1
==========
// Next line of pecan scanner
skip = (space / comment / newline)* @
----------
Rule skip
  And (space / comment / newline)* @
    Any (space / comment / newline)*
      Or space / comment / newline
        Id space
        Id comment
        Id newline
    Drop @
==========
// Next line of pecan scanner
skip1 = space @ (newline ([space (letter / newline)]& @NL)? skip)?
----------
Rule skip1
  And space @ (newline ([space (letter / newline)]& @NL)? skip)?
    Id space
    Drop @
    Opt (newline ([space (letter / newline)]& @NL)? skip)?
      And newline ([space (letter / newline)]& @NL)? skip
        Id newline
        Opt ([space (letter / newline)]& @NL)?
          And [space (letter / newline)]& @NL
            Has [space (letter / newline)]&
              Try [space (letter / newline)]
                And space (letter / newline)
                  Id space
                  Or letter / newline
                    Id letter
                    Id newline
            Act @NL
        Id skip
==========
// Next line of pecan scanner
skip2 = space (newline space)? @
----------
Rule skip2
  And space (newline space)? @
    Id space
    Opt (newline space)?
      And newline space
        Id newline
        Id space
    Drop @
==========
// Next line of pecan scanner
name = letter alpha*
----------
Rule name
  And letter alpha*
    Id letter
    Any alpha*
      Id alpha
==========
// Next line of pecan scanner (ranges to be handled in binder)
hex = digit / 'A..F' / 'a..f'
----------
Rule hex
  Or digit / 'A..F' / 'a..f'
    Id digit
    Set 'A..F'
    Set 'a..f'
==========
// Unicode letters and digits and numbers
x = abc\960
y = 123\1636
z = 1114111 / 0ffff
----------
Rule x
  Id abc\960
Rule y
  Char 123\1636
Rule z
  Or 1114111 / 0ffff
    Char 1114111
    Char 0ffff
==========
// Strings, character sets, unicode
x = "abc" " !#$%^&*()_-=+[]`{};:'@#~"
y = 'abc' ' !#$%^&*()_-=+[]`{};:"@#~'
pi = "\960"
----------
Rule x
  And "abc" " !#$%^&*()_-=+[]`{};:'@#~"
    String "abc"
    String " !#$%^&*()_-=+[]`{};:'@#~"
Rule y
  And 'abc' ' !#$%^&*()_-=+[]`{};:"@#~'
    Set 'abc'
    Set ' !#$%^&*()_-=+[]`{};:"@#~'
Rule pi
  String "\960"
==========
// Actions, tests, numbers and errors
x = %x @0x @1x @ @x
y = 0 1 2 10 12 123
z = 0ffff 01ABCDEF23 0FG
u = #err ''
----------
Rule x
  And %x @0x @1x @ @x
    Tag %x
    Act @0x
    Act @1x
    Drop @
    Act @x
Rule y
  And 0 1 2 10 12 123
    Char 0
    Char 1
    Char 2
    Char 10
    Char 12
    Char 123
Rule z
  And 0ffff 01ABCDEF23 0FG
    Char 0ffff
    Char 01ABCDEF23
    Char 0F
    Id G
Rule u
  And #err ''
    Mark #err
    Set ''
==========
// Brackets and operators
x = (y / z) / y?
x = (y/z)+ / y*
x = y z w ! / y
x = [y z] / w
----------
Rule x
  Or (y / z) / y?
    Or y / z
      Id y
      Id z
    Opt y?
      Id y
Rule x
  Or (y/z)+ / y*
    Some (y/z)+
      Or y/z
        Id y
        Id z
    Any y*
      Id y
Rule x
  Or y z w ! / y
    And y z w !
      Id y
      Id z
      Not w !
        Id w
    Id y
Rule x
  Or [y z] / w
    Try [y z]
      And y z
        Id y
        Id z
    Id w
==========
// Comments before and after continuation lines
x =
 // comment
 y /
 // comment
 z
x
 // Comment
= y
 // Comment
/ z
----------
Rule x
  Or y /...
    Id y
    Id z
Rule x
  Or y...
    Id y
    Id z
==========
// String with supplementary unicode character 195101/2fa1d (last letter)
// Represent in the UTF-16 source as two chars, upper/lower surrogates.
range = "\55422\56861" / '\55422\56861'
----------
Rule range
  Or "\195101" / '\195101'
    String "\195101"
    Set '\195101'
==========
// Angle brackets now used for dividers
keyword = <do> keyword1 / keyword2
keyword1 = "break" / "case" / "catch" / "continue" / "default"
keyword2 = "do" / "else" / "for" / "if" / "switch" / "while"
----------
Rule keyword
  Or <do> keyword1 / keyword2
    And <do> keyword1
      Divider <do>
      Id keyword1
    Id keyword2
Rule keyword1
  Or "break" / "case" / "catch" / "continue" / "default"
    String "break"
    String "case"
    String "catch"
    String "continue"
    String "default"
Rule keyword2
  Or "do" / "else" / "for" / "if" / "switch" / "while"
    String "do"
    String "else"
    String "for"
    String "if"
    String "switch"
    String "while"
==========
end = #end Uc!
----------
Rule end
  And #end Uc!
    Mark #end
    Not Uc!
      Id Uc
==========
// Underscore
a_b = xy_
----------
Rule a_b
  Id xy_
==========
// Hyphen
a-b = xy-
----------
Rule a-b
  Id xy-
==========
// End-of-file tag
end = %
----------
Rule end
  Tag %
==========
// Backslash in quotes
bs = '\\'
----------
Rule bs
  Set '\\'
