// One-liner
x = x
----------
Rule x
  Id x
==========
// Choice
x = x / x
----------
Rule x
  Or x / x
    Id x
    Id x
==========
// Bracket
x = (y / z)
----------
Rule x
  Or y / z
    Id y
    Id z
==========
----------
Error on line 1: expecting rule

^
==========
// Expecting equals
x
----------
Error on line 2: expecting =
x
 ^
==========
// Normal \n line endings
x = x
y = y
---------
Rule x
  Id x
Rule y
  Id y
==========
// Old Mac \r line endings
x=x\13\
y=y\13\
----------
Rule x
  Id x
Rule y
  Id y
==========
// Windows \r\n line endings
x=x\13\10\
y=y\13\10\
----------
Rule x
  Id x
Rule y
  Id y
==========
// Line containing only spaces is a comment
// comment

x = x
----------
Rule x
  Id x
==========
// Trailing spaces
x = x    \10
         \10
y = y    \10
----------
Rule x
  Id x
Rule y
  Id y
==========
// Trailing blank line
x = x
y = y

----------
Rule x
  Id x
Rule y
  Id y
==========
// Trailing blank lines
x = x
y = y


----------
Rule x
  Id x
Rule y
  Id y
==========
// No final newline
x = x
y = y\
----------
Error on line 3: expecting newline
y = y
     ^
==========
// No final newline
x = x
// comment\
----------
Error on line 3: expecting newline
// comment
          ^
==========
// Varied comments and empty lines
// initial comment

x = y

// middle comment
y = z

// end comment
----------
Rule x
  Id y
Rule y
  Id z
==========
// Scanner error
x = <y>
----------
Error on line 2: expecting expression
x = <y>
    ^
==========
// Incomplete string
x = "abc
----------
Error on line 2: expecting visible character or "
x = "abc
        ^
==========
// Incomplete set
x = 'abc
----------
Error on line 2: expecting visible character or '
x = 'abc
        ^
==========
// One rule
x = "a"
----------
Rule x
  STRING "a"
==========
// Two rules
x = "a"
y = "b"
----------
Rule x
  STRING "a"
Rule y
  STRING "b"
==========
// Expecting equals
x
----------
Error on line 2: expecting =
x
 ^
==========
// Expecting atom
x = /
----------
Error on line 2: expecting expression
x = /
    ^
==========
// Missing close bracket
x = (y
y = z
----------
Error on line 2: expecting )
x = (y
      ^
==========
// Dot in the wrong place
x = .
----------
Error on line 2: expecting expression
x = .
    ^
==========
// Incomplete dot dot
x = 'x'.
----------
Error on line 2: expecting dot
x = 'x'.
        ^
==========
// Incomplete action
x = @3
----------
Error on line 2: expecting letter
x = @3
      ^
==========
// Tag
x = %x
----------
Rule x
  TAG %x
==========
// Bad marker
x = 'x' #3
----------
Error on line 2: expecting letter
x = 'x' #3
         ^
==========
// Continuation lines
x =
y /
z
x =
(
a) [
c]
x
= y
/ z
x
= y (a
) [c
]
----------
Rule x
  Or y /...
    Id y
    Id z
Rule x
  And (...
    Id a
    TRY [...
      Id c
Rule x
  Or y...
    Id y
    Id z
Rule x
  And y (a...
    Id y
    Id a
    TRY [c...
      Id c
==========
// Brackets
exp = (exp) end
exp = [exp] end
----------
Rule exp
  And (exp) end
    Id exp
    Id end
Rule exp
  And [exp] end
    TRY [exp]
      Id exp
    Id end
==========
// The + * ? postfix operators
exp = exp* exp+ exp? end
----------
Rule exp
  And exp* exp+ exp? end
    MANY exp*
      Id exp
    SOME exp+
      Id exp
    OPT exp?
      Id exp
    Id end
==========
// Complete scan-parser grammar for sums
exp = term ("+" term @2add / "-" term @2sub)* ''
term = factor ("*" factor @2mul / "/" factor @2div)*
factor = primary ("^" factor @2pow)?
primary = number / "(" exp ")"
number = digit+ @number
digit = '0123456789'
----------
Rule exp
  And term ("+" term @2add / "-" term @2sub)* ''
    Id term
    MANY ("+" term @2add / "-" term @2sub)*
      Or "+" term @2add / "-" term @2sub
        And "+" term @2add
          STRING "+"
          Id term
          ACT @2add
        And "-" term @2sub
          STRING "-"
          Id term
          ACT @2sub
    SET ''
Rule term
  And factor ("*" factor @2mul / "/" factor @2div)*
    Id factor
    MANY ("*" factor @2mul / "/" factor @2div)*
      Or "*" factor @2mul / "/" factor @2div
        And "*" factor @2mul
          STRING "*"
          Id factor
          ACT @2mul
        And "/" factor @2div
          STRING "/"
          Id factor
          ACT @2div
Rule factor
  And primary ("^" factor @2pow)?
    Id primary
    OPT ("^" factor @2pow)?
      And "^" factor @2pow
        STRING "^"
        Id factor
        ACT @2pow
Rule primary
  Or number / "(" exp ")"
    Id number
    And "(" exp ")"
      STRING "("
      Id exp
      STRING ")"
Rule number
  And digit+ @number
    SOME digit+
      Id digit
    ACT @number
Rule digit
  SET '0123456789'
==========
// Error markers
assignment = left #equals "=" right
----------
Rule assignment
  And left #equals "=" right
    Id left
    MARK #equals
    STRING "="
    Id right
==========
// Error on line 3
x = y /
z / /
----------
Error on line 3: expecting expression
z / /
    ^
==========
// Line 1 of scanner for pecan itself
tokens = skip token*
----------
Rule tokens
  And skip token*
    Id skip
    MANY token*
      Id token
==========
// Next line of pecan scanner
token = number / id / string / set / matcher / action / handler / key
----------
Rule token
  Or number / id / string / set / matcher / action / handler / key
    Id number
    Id id
    Id string
    Id set
    Id matcher
    Id action
    Id handler
    Id key
==========
// Next line of pecan scanner
number = ('0' hex* / digit+) @NUMBER skip1
----------
Rule number
  And ('0' hex* / digit+) @NUMBER skip1
    Or '0' hex* / digit+
      And '0' hex*
        SET '0'
        MANY hex*
          Id hex
      SOME digit+
        Id digit
    ACT @NUMBER
    Id skip1
==========
// Next line of pecan scanner
id = name @Id skip1
----------
Rule id
  And name @Id skip1
    Id name
    ACT @Id
    Id skip1
==========
// Next line of pecan scanner
string = '"' ('"'! visible)* #BADSTRING '"' @STRING skip1
----------
Rule string
  And '"' ('"'! visible)* #BADSTRING '"' @STRING skip1
    SET '"'
    MANY ('"'! visible)*
      And '"'! visible
        NOT '"'!
          SET '"'
        Id visible
    MARK #BADSTRING
    SET '"'
    ACT @STRING
    Id skip1
==========
// Next line of pecan scanner
set = "'" ("'"! visible)* #BADSET "'" @SET skip1
----------
Rule set
  And "'" ("'"! visible)* #BADSET "'" @SET skip1
    STRING "'"
    MANY ("'"! visible)*
      And "'"! visible
        NOT "'"!
          STRING "'"
        Id visible
    MARK #BADSET
    STRING "'"
    ACT @SET
    Id skip1
==========
// Next line of pecan scanner
action = "@" (digit+ name @ACT / name @READ / @DROP) skip1
----------
Rule action
  And "@" (digit+ name @ACT / name @READ / @DROP) skip1
    STRING "@"
    Or digit+ name @ACT / name @READ / @DROP
      And digit+ name @ACT
        SOME digit+
          Id digit
        Id name
        ACT @ACT
      And name @READ
        Id name
        ACT @READ
      ACT @DROP
    Id skip1
==========
// Next line of pecan scanner
handler = "#" name @HAndLE skip1
----------
Rule handler
  And "#" name @HAndLE skip1
    STRING "#"
    Id name
    ACT @HAndLE
    Id skip1
==========
// Next line of pecan scanner
key
= "!" @EM skip1 / "=" @Rule skip2 / "/" @SL skip2 / "?" @QM skip1
/ "+" @PL skip1 / "*" @ST skip1 / "(" @RB skip2 / ")" @RE skip1
/ "[" @SB skip2 / "]" @SE skip1 / "<" @AB skip2 / ">" @AE skip1
/ ".." @DD skip2
/ #BADSET Uc skip1
----------
Rule key
  Or "!" @EM skip1 / "=" @Rule skip2 / "/" @SL skip2 / "?" @QM skip1...
    And "!" @EM skip1
      STRING "!"
      ACT @EM
      Id skip1
    And "=" @Rule skip2
      STRING "="
      ACT @Rule
      Id skip2
    And "/" @SL skip2
      STRING "/"
      ACT @SL
      Id skip2
    And "?" @QM skip1
      STRING "?"
      ACT @QM
      Id skip1
    And "+" @PL skip1
      STRING "+"
      ACT @PL
      Id skip1
    And "*" @ST skip1
      STRING "*"
      ACT @ST
      Id skip1
    And "(" @RB skip2
      STRING "("
      ACT @RB
      Id skip2
    And ")" @RE skip1
      STRING ")"
      ACT @RE
      Id skip1
    And "[" @SB skip2
      STRING "["
      ACT @SB
      Id skip2
    And "]" @SE skip1
      STRING "]"
      ACT @SE
      Id skip1
    And "<" @AB skip2
      STRING "<"
      ACT @AB
      Id skip2
    And ">" @AE skip1
      STRING ">"
      ACT @AE
      Id skip1
    And ".." @DD skip2
      STRING ".."
      ACT @DD
      Id skip2
    And #BADSET Uc skip1
      MARK #BADSET
      Id Uc
      Id skip1
==========
// Next line of pecan scanner
skip = (space / comment / newline)* @
----------
Rule skip
  And (space / comment / newline)* @
    MANY (space / comment / newline)*
      Or space / comment / newline
        Id space
        Id comment
        Id newline
    DROP @
==========
// Next line of pecan scanner
skip1 = space @ (newline ([space (letter / newline)]& @NL)? skip)?
----------
Rule skip1
  And space @ (newline ([space (letter / newline)]& @NL)? skip)?
    Id space
    DROP @
    OPT (newline ([space (letter / newline)]& @NL)? skip)?
      And newline ([space (letter / newline)]& @NL)? skip
        Id newline
        OPT ([space (letter / newline)]& @NL)?
          And [space (letter / newline)]& @NL
            HAS [space (letter / newline)]&
              TRY [space (letter / newline)]
                And space (letter / newline)
                  Id space
                  Or letter / newline
                    Id letter
                    Id newline
            ACT @NL
        Id skip
==========
// Next line of pecan scanner
skip2 = space (newline space)? @
----------
Rule skip2
  And space (newline space)? @
    Id space
    OPT (newline space)?
      And newline space
        Id newline
        Id space
    DROP @
==========
// Next line of pecan scanner
name = letter alpha*
----------
Rule name
  And letter alpha*
    Id letter
    MANY alpha*
      Id alpha
==========
// Next line of pecan scanner
hex = digit / 'A'..'F' / 'a'..'f'
----------
Rule hex
  Or digit / 'A'..'F' / 'a'..'f'
    Id digit
    RANGE 'A'..'F'
      SET 'A'
      SET 'F'
    RANGE 'a'..'f'
      SET 'a'
      SET 'f'
==========
// Unicode letters and digits and numbers
x = abc\960
y = 123\1636
z = 1114111 / 0ffff
----------
Rule x
  Id abc\960
Rule y
  CHAR 123\1636
Rule z
  Or 1114111 / 0ffff
    CHAR 1114111
    CHAR 0ffff
==========
// Strings, character sets, unicode
x = "abc" " !#$%^&*()_-=+[]`{};:'@#~"
y = 'abc' ' !#$%^&*()_-=+[]`{};:"@#~'
pi = "\960"
----------
Rule x
  And "abc" " !#$%^&*()_-=+[]`{};:'@#~"
    STRING "abc"
    STRING " !#$%^&*()_-=+[]`{};:'@#~"
Rule y
  And 'abc' ' !#$%^&*()_-=+[]`{};:"@#~'
    SET 'abc'
    SET ' !#$%^&*()_-=+[]`{};:"@#~'
Rule pi
  STRING "\960"
==========
// Actions, tests, numbers and errors
x = %x @0x @1x @ @x
y = 0 1 2 10 12 123
z = 0ffff 01ABCDEF23 0FG
u = #err ''
----------
Rule x
  And %x @0x @1x @ @x
    TAG %x
    ACT @0x
    ACT @1x
    DROP @
    ACT @x
Rule y
  And 0 1 2 10 12 123
    CHAR 0
    CHAR 1
    CHAR 2
    CHAR 10
    CHAR 12
    CHAR 123
Rule z
  And 0ffff 01ABCDEF23 0FG
    CHAR 0ffff
    CHAR 01ABCDEF23
    CHAR 0F
    Id G
Rule u
  And #err ''
    MARK #err
    SET ''
==========
// Brackets and operators
x = (y / z) / y?
x = (y/z)+ / y*
x = y z w ! / y
x = [y z] / w
----------
Rule x
  Or (y / z) / y?
    Or y / z
      Id y
      Id z
    OPT y?
      Id y
Rule x
  Or (y/z)+ / y*
    SOME (y/z)+
      Or y/z
        Id y
        Id z
    MANY y*
      Id y
Rule x
  Or y z w ! / y
    And y z w !
      Id y
      Id z
      NOT w !
        Id w
    Id y
Rule x
  Or [y z] / w
    TRY [y z]
      And y z
        Id y
        Id z
    Id w
==========
// Full dot-dot
x = 'a'..'z'
----------
Rule x
  RANGE 'a'..'z'
    SET 'a'
    SET 'z'
==========
// Comments before and after continuation lines
x =
 // comment
 y /
 // comment
 z
x
 // Comment
= y
 // Comment
/ z
----------
Rule x
  Or y /...
    Id y
    Id z
Rule x
  Or y...
    Id y
    Id z
==========
// String with supplementary unicode character 195101/2fa1d (last letter)
// Represent in the UTF-16 source as two chars, upper/lower surrogates.
range = "\55422\56861" / '\55422\56861'
----------
Rule range
  Or "\195101" / '\195101'
    STRING "\195101"
    SET '\195101'
==========
// Angle brackets no longer accepted
set = "'" (<"'"> visible)* ("'" @SET / #BADSET) skip1
----------
Error on line 2: expecting expression
set = "'" (<"'"> visible)* ("'" @SET / #BADSET) skip1
           ^
==========
// Check NEL line endings
x=x\133y=y\133\
----------
Rule x
  Id x
Rule y
  Id y
==========
// Check \r NEL line endings
x=x\13\133y=y\13\133\
----------
Rule x
  Id x
Rule y
  Id y
==========
// Check LS line endings
x=x\8232y=y\8232\
----------
Rule x
  Id x
Rule y
  Id y
==========
end = #end Uc!
----------
Rule end
  And #end Uc!
    MARK #end
    NOT Uc!
      Id Uc
==========
// Underscore
a_b = xy_
----------
Rule a_b
  Id xy_
==========
// Hyphen
a-b = xy-
----------
Rule a-b
  Id xy-
==========
// Tag with backquotes
x = `++`
----------
Rule x
  TAG `++`
==========
// End-of-file tags
end1 = %
end2 = ``
----------
Rule end1
  TAG %
Rule end2
  TAG ``
==========
// Backslash in quotes
bs = '\\'
----------
Rule bs
  SET '\\'
